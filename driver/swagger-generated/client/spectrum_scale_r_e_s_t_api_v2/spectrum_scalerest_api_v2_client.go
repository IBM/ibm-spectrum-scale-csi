// Code generated by go-swagger; DO NOT EDIT.

package spectrum_scale_r_e_s_t_api_v2

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new spectrum scale r e s t api v2 API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for spectrum scale r e s t api v2 API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientService is the interface for Client methods
type ClientService interface {
	AcPutEntryv2(params *AcPutEntryv2Params, authInfo runtime.ClientAuthInfoWriter) (*AcPutEntryv2Accepted, error)

	ACLDeleteEntryv2(params *ACLDeleteEntryv2Params, authInfo runtime.ClientAuthInfoWriter) (*ACLDeleteEntryv2Accepted, error)

	ACLDeletev2(params *ACLDeletev2Params, authInfo runtime.ClientAuthInfoWriter) (*ACLDeletev2Accepted, error)

	ACLGetNamev2(params *ACLGetNamev2Params, authInfo runtime.ClientAuthInfoWriter) (*ACLGetNamev2OK, error)

	ACLGetv2(params *ACLGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*ACLGetv2OK, error)

	ACLGetv20(params *ACLGetv20Params, authInfo runtime.ClientAuthInfoWriter) (*ACLGetv20OK, error)

	ACLPostv2(params *ACLPostv2Params, authInfo runtime.ClientAuthInfoWriter) (*ACLPostv2Accepted, error)

	AuditLogGetv2(params *AuditLogGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*AuditLogGetv2OK, error)

	AuthenticationKeyGetv2(params *AuthenticationKeyGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*AuthenticationKeyGetv2OK, error)

	AuthenticationKeyPostv2(params *AuthenticationKeyPostv2Params, authInfo runtime.ClientAuthInfoWriter) (*AuthenticationKeyPostv2Accepted, error)

	AuthenticationKeyPutv2(params *AuthenticationKeyPutv2Params, authInfo runtime.ClientAuthInfoWriter) (*AuthenticationKeyPutv2Accepted, error)

	CallhomeGet(params *CallhomeGetParams, authInfo runtime.ClientAuthInfoWriter) (*CallhomeGetOK, error)

	CesServicesServiceGetv2(params *CesServicesServiceGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*CesServicesServiceGetv2OK, error)

	CesaddressesCesAddressGetv2(params *CesaddressesCesAddressGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*CesaddressesCesAddressGetv2OK, error)

	CesaddressesGetv2(params *CesaddressesGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*CesaddressesGetv2OK, error)

	CesservicesGetv2(params *CesservicesGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*CesservicesGetv2OK, error)

	ClusterGetv2(params *ClusterGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*ClusterGetv2OK, error)

	ClusterJobsDeletev2(params *ClusterJobsDeletev2Params, authInfo runtime.ClientAuthInfoWriter) (*ClusterJobsDeletev2OK, error)

	ClusterJobsGetv2(params *ClusterJobsGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*ClusterJobsGetv2OK, error)

	ClusterJobsGetv20(params *ClusterJobsGetv20Params, authInfo runtime.ClientAuthInfoWriter) (*ClusterJobsGetv20OK, error)

	CoffeeGetv2(params *CoffeeGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*CoffeeGetv2OK, error)

	CoffeePostv2(params *CoffeePostv2Params, authInfo runtime.ClientAuthInfoWriter) (*CoffeePostv2OK, error)

	ConfigGetv2(params *ConfigGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*ConfigGetv2OK, error)

	ConfigPut(params *ConfigPutParams, authInfo runtime.ClientAuthInfoWriter) (*ConfigPutAccepted, error)

	CosDirPostv2(params *CosDirPostv2Params, authInfo runtime.ClientAuthInfoWriter) (*CosDirPostv2Accepted, error)

	CosFilesetsPostv2(params *CosFilesetsPostv2Params, authInfo runtime.ClientAuthInfoWriter) (*CosFilesetsPostv2Accepted, error)

	DeleteBucketKeysv2(params *DeleteBucketKeysv2Params, authInfo runtime.ClientAuthInfoWriter) (*DeleteBucketKeysv2Accepted, error)

	DirectoryDeletev2(params *DirectoryDeletev2Params, authInfo runtime.ClientAuthInfoWriter) (*DirectoryDeletev2Accepted, error)

	DirectoryDeletev20(params *DirectoryDeletev20Params, authInfo runtime.ClientAuthInfoWriter) (*DirectoryDeletev20Accepted, error)

	DirectoryPostv2(params *DirectoryPostv2Params, authInfo runtime.ClientAuthInfoWriter) (*DirectoryPostv2Accepted, error)

	DirectoryPostv20(params *DirectoryPostv20Params, authInfo runtime.ClientAuthInfoWriter) (*DirectoryPostv20Accepted, error)

	DisksDiskNameGetv2(params *DisksDiskNameGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*DisksDiskNameGetv2OK, error)

	DisksGetv2(params *DisksGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*DisksGetv2OK, error)

	Download(params *DownloadParams, authInfo runtime.ClientAuthInfoWriter) (*DownloadAccepted, error)

	ElementGet(params *ElementGetParams, authInfo runtime.ClientAuthInfoWriter) (*ElementGetOK, error)

	ElementsGet(params *ElementsGetParams, authInfo runtime.ClientAuthInfoWriter) (*ElementsGetOK, error)

	EnableDisableFsAuditPutv2(params *EnableDisableFsAuditPutv2Params, authInfo runtime.ClientAuthInfoWriter) (*EnableDisableFsAuditPutv2Accepted, error)

	EnableDisableFsQuotaManagementPutv2(params *EnableDisableFsQuotaManagementPutv2Params, authInfo runtime.ClientAuthInfoWriter) (*EnableDisableFsQuotaManagementPutv2Accepted, error)

	EnableDisableFsWatchPutv2(params *EnableDisableFsWatchPutv2Params, authInfo runtime.ClientAuthInfoWriter) (*EnableDisableFsWatchPutv2Accepted, error)

	EnableDisableFsWatchPutv20(params *EnableDisableFsWatchPutv20Params, authInfo runtime.ClientAuthInfoWriter) (*EnableDisableFsWatchPutv20Accepted, error)

	EnableDisableQuotaDefaultsPutv2(params *EnableDisableQuotaDefaultsPutv2Params, authInfo runtime.ClientAuthInfoWriter) (*EnableDisableQuotaDefaultsPutv2Accepted, error)

	EnableDisableQuotaDefaultsPutv20(params *EnableDisableQuotaDefaultsPutv20Params, authInfo runtime.ClientAuthInfoWriter) (*EnableDisableQuotaDefaultsPutv20Accepted, error)

	EnqueueRefreshTask(params *EnqueueRefreshTaskParams, authInfo runtime.ClientAuthInfoWriter) error

	EventsGetv2(params *EventsGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*EventsGetv2OK, error)

	Evict(params *EvictParams, authInfo runtime.ClientAuthInfoWriter) (*EvictAccepted, error)

	FailbackPost(params *FailbackPostParams, authInfo runtime.ClientAuthInfoWriter) (*FailbackPostAccepted, error)

	FileCopyPutv2(params *FileCopyPutv2Params, authInfo runtime.ClientAuthInfoWriter) (*FileCopyPutv2Accepted, error)

	FileCopyPutv20(params *FileCopyPutv20Params, authInfo runtime.ClientAuthInfoWriter) (*FileCopyPutv20Accepted, error)

	FilesetAfmState(params *FilesetAfmStateParams, authInfo runtime.ClientAuthInfoWriter) (*FilesetAfmStateOK, error)

	FilesetsFilesetNameDeletev2(params *FilesetsFilesetNameDeletev2Params, authInfo runtime.ClientAuthInfoWriter) (*FilesetsFilesetNameDeletev2Accepted, error)

	FilesetsFilesetNameGetv2(params *FilesetsFilesetNameGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*FilesetsFilesetNameGetv2OK, error)

	FilesetsFilesetNamePutv2(params *FilesetsFilesetNamePutv2Params, authInfo runtime.ClientAuthInfoWriter) (*FilesetsFilesetNamePutv2Accepted, error)

	FilesetsGetv2(params *FilesetsGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*FilesetsGetv2OK, error)

	FilesetsLinkv2(params *FilesetsLinkv2Params, authInfo runtime.ClientAuthInfoWriter) (*FilesetsLinkv2Accepted, error)

	FilesetsPostv2(params *FilesetsPostv2Params, authInfo runtime.ClientAuthInfoWriter) (*FilesetsPostv2Accepted, error)

	FilesetsUnlinkv2(params *FilesetsUnlinkv2Params, authInfo runtime.ClientAuthInfoWriter) (*FilesetsUnlinkv2Accepted, error)

	FilesystemWatchGetv2(params *FilesystemWatchGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*FilesystemWatchGetv2OK, error)

	FilesystemsFilesystemNameGetv2(params *FilesystemsFilesystemNameGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*FilesystemsFilesystemNameGetv2OK, error)

	FilesystemsGetv2(params *FilesystemsGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*FilesystemsGetv2OK, error)

	InfoGetv2(params *InfoGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*InfoGetv2OK, error)

	JobsDeletev2(params *JobsDeletev2Params, authInfo runtime.ClientAuthInfoWriter) (*JobsDeletev2OK, error)

	JobsGetv2(params *JobsGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*JobsGetv2OK, error)

	JobsGetv20(params *JobsGetv20Params, authInfo runtime.ClientAuthInfoWriter) (*JobsGetv20OK, error)

	MountFsv2(params *MountFsv2Params, authInfo runtime.ClientAuthInfoWriter) (*MountFsv2Accepted, error)

	MountFsv20(params *MountFsv20Params, authInfo runtime.ClientAuthInfoWriter) (*MountFsv20Accepted, error)

	NfsExportPathDelete(params *NfsExportPathDeleteParams, authInfo runtime.ClientAuthInfoWriter) (*NfsExportPathDeleteAccepted, error)

	NfsExportPathGet(params *NfsExportPathGetParams, authInfo runtime.ClientAuthInfoWriter) (*NfsExportPathGetOK, error)

	NfsExportPathPut(params *NfsExportPathPutParams, authInfo runtime.ClientAuthInfoWriter) (*NfsExportPathPutAccepted, error)

	NfsExportPost(params *NfsExportPostParams, authInfo runtime.ClientAuthInfoWriter) (*NfsExportPostAccepted, error)

	NfsExportsGet(params *NfsExportsGetParams, authInfo runtime.ClientAuthInfoWriter) (*NfsExportsGetOK, error)

	NodeclassNameDeletev2(params *NodeclassNameDeletev2Params, authInfo runtime.ClientAuthInfoWriter) (*NodeclassNameDeletev2Accepted, error)

	NodeclassNameGetv2(params *NodeclassNameGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*NodeclassNameGetv2OK, error)

	NodeclassNamePutv2(params *NodeclassNamePutv2Params, authInfo runtime.ClientAuthInfoWriter) (*NodeclassNamePutv2Accepted, error)

	NodeclassPostv2(params *NodeclassPostv2Params, authInfo runtime.ClientAuthInfoWriter) (*NodeclassPostv2Accepted, error)

	NodeclassesGetv2(params *NodeclassesGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*NodeclassesGetv2OK, error)

	NodesChangeMappingv2(params *NodesChangeMappingv2Params, authInfo runtime.ClientAuthInfoWriter) (*NodesChangeMappingv2Accepted, error)

	NodesCreateMappingv2(params *NodesCreateMappingv2Params, authInfo runtime.ClientAuthInfoWriter) (*NodesCreateMappingv2Accepted, error)

	NodesDeleteMappingv2(params *NodesDeleteMappingv2Params, authInfo runtime.ClientAuthInfoWriter) (*NodesDeleteMappingv2Accepted, error)

	NodesDeletev2(params *NodesDeletev2Params, authInfo runtime.ClientAuthInfoWriter) (*NodesDeletev2Accepted, error)

	NodesGetv2(params *NodesGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*NodesGetv2OK, error)

	NodesListMappingv2(params *NodesListMappingv2Params, authInfo runtime.ClientAuthInfoWriter) (*NodesListMappingv2Accepted, error)

	NodesListMappingv20(params *NodesListMappingv20Params, authInfo runtime.ClientAuthInfoWriter) (*NodesListMappingv20Accepted, error)

	NodesNameGetv2(params *NodesNameGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*NodesNameGetv2OK, error)

	NodesPostv2(params *NodesPostv2Params, authInfo runtime.ClientAuthInfoWriter) (*NodesPostv2Accepted, error)

	NodesPutv2(params *NodesPutv2Params, authInfo runtime.ClientAuthInfoWriter) (*NodesPutv2Accepted, error)

	NodesServiceGetv2(params *NodesServiceGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*NodesServiceGetv2OK, error)

	NodesServicePutv2(params *NodesServicePutv2Params, authInfo runtime.ClientAuthInfoWriter) (*NodesServicePutv2Accepted, error)

	NodesServicesGetv2(params *NodesServicesGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*NodesServicesGetv2OK, error)

	NsdsGetv2(params *NsdsGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*NsdsGetv2OK, error)

	NsdsNameGetv2(params *NsdsNameGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*NsdsNameGetv2OK, error)

	OwnerGetv2(params *OwnerGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*OwnerGetv2OK, error)

	OwnerPostv2(params *OwnerPostv2Params, authInfo runtime.ClientAuthInfoWriter) (*OwnerPostv2Accepted, error)

	OwningClustersDeletev2(params *OwningClustersDeletev2Params, authInfo runtime.ClientAuthInfoWriter) (*OwningClustersDeletev2Accepted, error)

	OwningClustersGetv2(params *OwningClustersGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*OwningClustersGetv2OK, error)

	OwningClustersNameGetv2(params *OwningClustersNameGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*OwningClustersNameGetv2OK, error)

	OwningClustersPostv2(params *OwningClustersPostv2Params, authInfo runtime.ClientAuthInfoWriter) (*OwningClustersPostv2Accepted, error)

	OwningClustersPutv2(params *OwningClustersPutv2Params, authInfo runtime.ClientAuthInfoWriter) (*OwningClustersPutv2Accepted, error)

	PdisksGetv2(params *PdisksGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*PdisksGetv2OK, error)

	PdisksGetv20(params *PdisksGetv20Params, authInfo runtime.ClientAuthInfoWriter) (*PdisksGetv20OK, error)

	PerformanceDataGetv2(params *PerformanceDataGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*PerformanceDataGetv2OK, error)

	PerformanceDataStatsv2(params *PerformanceDataStatsv2Params, authInfo runtime.ClientAuthInfoWriter) (*PerformanceDataStatsv2OK, error)

	PoliciesGetv2(params *PoliciesGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*PoliciesGetv2OK, error)

	PoliciesPostv2(params *PoliciesPostv2Params, authInfo runtime.ClientAuthInfoWriter) (*PoliciesPostv2Accepted, error)

	PsnapsFilesetsPostv2(params *PsnapsFilesetsPostv2Params, authInfo runtime.ClientAuthInfoWriter) (*PsnapsFilesetsPostv2Accepted, error)

	PsnapsFilesetsSnapshotNameDeletev2(params *PsnapsFilesetsSnapshotNameDeletev2Params, authInfo runtime.ClientAuthInfoWriter) (*PsnapsFilesetsSnapshotNameDeletev2Accepted, error)

	QuotaDefaultsFilesetGetv2(params *QuotaDefaultsFilesetGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*QuotaDefaultsFilesetGetv2OK, error)

	QuotaDefaultsFsPostv2(params *QuotaDefaultsFsPostv2Params, authInfo runtime.ClientAuthInfoWriter) (*QuotaDefaultsFsPostv2Accepted, error)

	QuotaDefaultsFsetPostv2(params *QuotaDefaultsFsetPostv2Params, authInfo runtime.ClientAuthInfoWriter) (*QuotaDefaultsFsetPostv2Accepted, error)

	QuotaDefaultsGetv2(params *QuotaDefaultsGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*QuotaDefaultsGetv2OK, error)

	QuotaGraceDefaultsFsPostv2(params *QuotaGraceDefaultsFsPostv2Params, authInfo runtime.ClientAuthInfoWriter) (*QuotaGraceDefaultsFsPostv2Accepted, error)

	QuotaGraceDefaultsGetv2(params *QuotaGraceDefaultsGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*QuotaGraceDefaultsGetv2OK, error)

	QuotasGetv2(params *QuotasGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*QuotasGetv2OK, error)

	QuotasGetv20(params *QuotasGetv20Params, authInfo runtime.ClientAuthInfoWriter) (*QuotasGetv20OK, error)

	QuotasPostv2(params *QuotasPostv2Params, authInfo runtime.ClientAuthInfoWriter) (*QuotasPostv2Accepted, error)

	QuotasPostv20(params *QuotasPostv20Params, authInfo runtime.ClientAuthInfoWriter) (*QuotasPostv20Accepted, error)

	RecoveryGroupGetv2(params *RecoveryGroupGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*RecoveryGroupGetv2OK, error)

	RecoveryGroupGetv20(params *RecoveryGroupGetv20Params, authInfo runtime.ClientAuthInfoWriter) (*RecoveryGroupGetv20OK, error)

	RecoveryGroupNameGetv2(params *RecoveryGroupNameGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*RecoveryGroupNameGetv2OK, error)

	RecoveryGroupNameGetv20(params *RecoveryGroupNameGetv20Params, authInfo runtime.ClientAuthInfoWriter) (*RecoveryGroupNameGetv20OK, error)

	RemoteAccessGet(params *RemoteAccessGetParams, authInfo runtime.ClientAuthInfoWriter) (*RemoteAccessGetOK, error)

	RemoteAccessPost(params *RemoteAccessPostParams, authInfo runtime.ClientAuthInfoWriter) (*RemoteAccessPostOK, error)

	RemoteAccessStatusGet(params *RemoteAccessStatusGetParams, authInfo runtime.ClientAuthInfoWriter) (*RemoteAccessStatusGetOK, error)

	RemoteClustersChangeAccessv2(params *RemoteClustersChangeAccessv2Params, authInfo runtime.ClientAuthInfoWriter) (*RemoteClustersChangeAccessv2Accepted, error)

	RemoteClustersDeletev2(params *RemoteClustersDeletev2Params, authInfo runtime.ClientAuthInfoWriter) (*RemoteClustersDeletev2Accepted, error)

	RemoteClustersDenyAccessv2(params *RemoteClustersDenyAccessv2Params, authInfo runtime.ClientAuthInfoWriter) (*RemoteClustersDenyAccessv2Accepted, error)

	RemoteClustersGetv2(params *RemoteClustersGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*RemoteClustersGetv2OK, error)

	RemoteClustersGrantAccessv2(params *RemoteClustersGrantAccessv2Params, authInfo runtime.ClientAuthInfoWriter) (*RemoteClustersGrantAccessv2Accepted, error)

	RemoteClustersNameGetv2(params *RemoteClustersNameGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*RemoteClustersNameGetv2OK, error)

	RemoteClustersPostv2(params *RemoteClustersPostv2Params, authInfo runtime.ClientAuthInfoWriter) (*RemoteClustersPostv2Accepted, error)

	RemoteClustersPutv2(params *RemoteClustersPutv2Params, authInfo runtime.ClientAuthInfoWriter) (*RemoteClustersPutv2Accepted, error)

	RemoteFilesystemsDeletev2(params *RemoteFilesystemsDeletev2Params, authInfo runtime.ClientAuthInfoWriter) (*RemoteFilesystemsDeletev2Accepted, error)

	RemoteFilesystemsGetv2(params *RemoteFilesystemsGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*RemoteFilesystemsGetv2OK, error)

	RemoteFilesystemsNameGetv2(params *RemoteFilesystemsNameGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*RemoteFilesystemsNameGetv2OK, error)

	RemoteFilesystemsPostv2(params *RemoteFilesystemsPostv2Params, authInfo runtime.ClientAuthInfoWriter) (*RemoteFilesystemsPostv2Accepted, error)

	RemoteFilesystemsPutv2(params *RemoteFilesystemsPutv2Params, authInfo runtime.ClientAuthInfoWriter) (*RemoteFilesystemsPutv2Accepted, error)

	ResumeFsv2(params *ResumeFsv2Params, authInfo runtime.ClientAuthInfoWriter) (*ResumeFsv2Accepted, error)

	SensorConfigGetOnev2(params *SensorConfigGetOnev2Params, authInfo runtime.ClientAuthInfoWriter) (*SensorConfigGetOnev2OK, error)

	SensorConfigGetOnev20(params *SensorConfigGetOnev20Params, authInfo runtime.ClientAuthInfoWriter) (*SensorConfigGetOnev20OK, error)

	SensorConfigGetv2(params *SensorConfigGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*SensorConfigGetv2OK, error)

	SetBucketKeysv2(params *SetBucketKeysv2Params, authInfo runtime.ClientAuthInfoWriter) (*SetBucketKeysv2Accepted, error)

	SmbShareNameDelete(params *SmbShareNameDeleteParams, authInfo runtime.ClientAuthInfoWriter) (*SmbShareNameDeleteAccepted, error)

	SmbShareNameGet(params *SmbShareNameGetParams, authInfo runtime.ClientAuthInfoWriter) (*SmbShareNameGetOK, error)

	SmbSharePathPut(params *SmbSharePathPutParams, authInfo runtime.ClientAuthInfoWriter) (*SmbSharePathPutAccepted, error)

	SmbSharePost(params *SmbSharePostParams, authInfo runtime.ClientAuthInfoWriter) (*SmbSharePostAccepted, error)

	SmbSharesGet(params *SmbSharesGetParams, authInfo runtime.ClientAuthInfoWriter) (*SmbSharesGetOK, error)

	SnapshotCopyPathPutv2(params *SnapshotCopyPathPutv2Params, authInfo runtime.ClientAuthInfoWriter) (*SnapshotCopyPathPutv2Accepted, error)

	SnapshotCopyPathPutv20(params *SnapshotCopyPathPutv20Params, authInfo runtime.ClientAuthInfoWriter) (*SnapshotCopyPathPutv20Accepted, error)

	SnapshotCopyPutv2(params *SnapshotCopyPutv2Params, authInfo runtime.ClientAuthInfoWriter) (*SnapshotCopyPutv2Accepted, error)

	SnapshotCopyPutv20(params *SnapshotCopyPutv20Params, authInfo runtime.ClientAuthInfoWriter) (*SnapshotCopyPutv20Accepted, error)

	SnapshotsFilesetSnapshotNameGetv2(params *SnapshotsFilesetSnapshotNameGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*SnapshotsFilesetSnapshotNameGetv2OK, error)

	SnapshotsFilesetsGetv2(params *SnapshotsFilesetsGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*SnapshotsFilesetsGetv2OK, error)

	SnapshotsFilesetsPostv2(params *SnapshotsFilesetsPostv2Params, authInfo runtime.ClientAuthInfoWriter) (*SnapshotsFilesetsPostv2Accepted, error)

	SnapshotsFilesetsSnapshotNameDeletev2(params *SnapshotsFilesetsSnapshotNameDeletev2Params, authInfo runtime.ClientAuthInfoWriter) (*SnapshotsFilesetsSnapshotNameDeletev2Accepted, error)

	SnapshotsFilesystemPostv2(params *SnapshotsFilesystemPostv2Params, authInfo runtime.ClientAuthInfoWriter) (*SnapshotsFilesystemPostv2Accepted, error)

	SnapshotsFilesystemSnapshotNameDeletev2(params *SnapshotsFilesystemSnapshotNameDeletev2Params, authInfo runtime.ClientAuthInfoWriter) (*SnapshotsFilesystemSnapshotNameDeletev2Accepted, error)

	SnapshotsFilesystemSnapshotNameGetv2(params *SnapshotsFilesystemSnapshotNameGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*SnapshotsFilesystemSnapshotNameGetv2OK, error)

	SnapshotsFilesystemsGetv2(params *SnapshotsFilesystemsGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*SnapshotsFilesystemsGetv2OK, error)

	SpecificationsGet(params *SpecificationsGetParams, authInfo runtime.ClientAuthInfoWriter) (*SpecificationsGetOK, error)

	StatesGetv2(params *StatesGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*StatesGetv2OK, error)

	SymlinkDeletev2(params *SymlinkDeletev2Params, authInfo runtime.ClientAuthInfoWriter) (*SymlinkDeletev2Accepted, error)

	SymlinkDeletev20(params *SymlinkDeletev20Params, authInfo runtime.ClientAuthInfoWriter) (*SymlinkDeletev20Accepted, error)

	SymlinkPostv2(params *SymlinkPostv2Params, authInfo runtime.ClientAuthInfoWriter) (*SymlinkPostv2Accepted, error)

	SymlinkPostv20(params *SymlinkPostv20Params, authInfo runtime.ClientAuthInfoWriter) (*SymlinkPostv20Accepted, error)

	ThresholdDeletev2(params *ThresholdDeletev2Params, authInfo runtime.ClientAuthInfoWriter) (*ThresholdDeletev2Accepted, error)

	ThresholdGetv2(params *ThresholdGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*ThresholdGetv2OK, error)

	ThresholdPostv2(params *ThresholdPostv2Params, authInfo runtime.ClientAuthInfoWriter) (*ThresholdPostv2Accepted, error)

	ThresholdsGetv2(params *ThresholdsGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*ThresholdsGetv2OK, error)

	UnmountFsv2(params *UnmountFsv2Params, authInfo runtime.ClientAuthInfoWriter) (*UnmountFsv2Accepted, error)

	Upload(params *UploadParams, authInfo runtime.ClientAuthInfoWriter) (*UploadAccepted, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
  AcPutEntryv2 adds an entry to the access control list of a s m b share

  Adds an entry to the ACL of a SMB share. If an entry for the specified name already exists it will be replaced. Note that the share name and the user name are part of both the URL and the json payload. In the json both are optional, but if specified they must match those in the URL.
*/
func (a *Client) AcPutEntryv2(params *AcPutEntryv2Params, authInfo runtime.ClientAuthInfoWriter) (*AcPutEntryv2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAcPutEntryv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "acPutEntryv2",
		Method:             "PUT",
		PathPattern:        "/scalemgmt/v2/smb/shares/{shareName}/acl/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &AcPutEntryv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AcPutEntryv2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for acPutEntryv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ACLDeleteEntryv2 deletes an entry from the access control list of a s m b share

  Deletes an entry from the ACL of a SMB share.
*/
func (a *Client) ACLDeleteEntryv2(params *ACLDeleteEntryv2Params, authInfo runtime.ClientAuthInfoWriter) (*ACLDeleteEntryv2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewACLDeleteEntryv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "aclDeleteEntryv2",
		Method:             "DELETE",
		PathPattern:        "/scalemgmt/v2/smb/shares/{shareName}/acl/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ACLDeleteEntryv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ACLDeleteEntryv2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for aclDeleteEntryv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ACLDeletev2 deletes complete access control list of a s m b share

  Deletes the ACL of a SMB share. Note that the ACL will not be empty after this operation. Instead, this basically replaces the current ACL with one the grants Everyone full access.
*/
func (a *Client) ACLDeletev2(params *ACLDeletev2Params, authInfo runtime.ClientAuthInfoWriter) (*ACLDeletev2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewACLDeletev2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "aclDeletev2",
		Method:             "DELETE",
		PathPattern:        "/scalemgmt/v2/smb/shares/{shareName}/acl",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ACLDeletev2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ACLDeletev2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for aclDeletev2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ACLGetNamev2 gets access control list entry of a specific user group system of share

  Returns an access control list entry of a SMB share
*/
func (a *Client) ACLGetNamev2(params *ACLGetNamev2Params, authInfo runtime.ClientAuthInfoWriter) (*ACLGetNamev2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewACLGetNamev2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "aclGetNamev2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/smb/shares/{shareName}/acl/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ACLGetNamev2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ACLGetNamev2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for aclGetNamev2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ACLGetv2 gets access control list of file directory

  Returns the acl of a file or directory. Current implementation will always return NfsV4 ACLs even if native ACL is POSIX.
*/
func (a *Client) ACLGetv2(params *ACLGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*ACLGetv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewACLGetv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "aclGetv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/acl/{path}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ACLGetv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ACLGetv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for aclGetv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ACLGetv20 gets access control list of share

  Returns the acl of a SMB share
*/
func (a *Client) ACLGetv20(params *ACLGetv20Params, authInfo runtime.ClientAuthInfoWriter) (*ACLGetv20OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewACLGetv20Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "aclGetv2_0",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/smb/shares/{shareName}/acl",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ACLGetv20Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ACLGetv20OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for aclGetv2_0: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ACLPostv2 writes access control list of file directory

  Sets the acl of a file or directory. Current implementation supports just Nfsv4 ACLs, but no POSIX ACLs.
*/
func (a *Client) ACLPostv2(params *ACLPostv2Params, authInfo runtime.ClientAuthInfoWriter) (*ACLPostv2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewACLPostv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "aclPostv2",
		Method:             "PUT",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/acl/{path}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ACLPostv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ACLPostv2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for aclPostv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  AuditLogGetv2 retrieves a list of executed c l i commands

  Returns a list of executed CLI commands
*/
func (a *Client) AuditLogGetv2(params *AuditLogGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*AuditLogGetv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAuditLogGetv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "auditLogGetv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/cliauditlog",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &AuditLogGetv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AuditLogGetv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for auditLogGetv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  AuthenticationKeyGetv2 gets the public r s a authentication key that is used for remote mounting

  Get the public RSA authentication key of a cluster that is used for remote mounting. This API can be executed on both, the cluster that owns the filesystems and the cluster that remotely mounts filesystems. The public key can be used as input for POST & PUT /scalemgmt/v2/remotemount/owningclusters and for POST & PUT /scalemgmt/v2/remotemount/remoteclusters. Only users with role 'Administrator' or 'CNSS Operator' have permission to for this REST endpoint. Read also the documentation of CLI command 'mmauth show'.
*/
func (a *Client) AuthenticationKeyGetv2(params *AuthenticationKeyGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*AuthenticationKeyGetv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAuthenticationKeyGetv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "authenticationKeyGetv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/remotemount/authenticationkey",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &AuthenticationKeyGetv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AuthenticationKeyGetv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for authenticationKeyGetv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  AuthenticationKeyPostv2 generates a new r s a authentication key pair that is used for remote mounting

  Generate a new RSA authentication key pair (private and public) on a cluster that is used for remote mounting. This API can be executed on both, the cluster that owns the filesystems and the cluster that remotely mounts filesystems. Use GET /scalemgmt/v2/remotemount/authenticationkey to check if a new authenitaction key has already been generated. Only users with role 'Administrator' or 'CNSS Operator' have permission to for this REST endpoint. Read also the documentation of CLI command 'mmauth genkey new'.
*/
func (a *Client) AuthenticationKeyPostv2(params *AuthenticationKeyPostv2Params, authInfo runtime.ClientAuthInfoWriter) (*AuthenticationKeyPostv2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAuthenticationKeyPostv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "authenticationKeyPostv2",
		Method:             "POST",
		PathPattern:        "/scalemgmt/v2/remotemount/authenticationkey",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &AuthenticationKeyPostv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AuthenticationKeyPostv2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for authenticationKeyPostv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  AuthenticationKeyPutv2 commits or propagate a new r s a authentication key that is used for remote mounting

  Commit or propagate a new RSA authentication key on a cluster that is used for remote mounting. This API can be executed on both, the cluster that owns the filesystems and the cluster that remotely mounts filesystems. Use POST /scalemgmt/v2/remotemount/authenticationkey to generate a new RSA key pair (private and public key) for remote mounting. Use GET /scalemgmt/v2/remotemount/authenticationkey to check if a new authenitaction key has already been generated. Only users with role 'Administrator' or 'CNSS Operator' have permission to for this REST endpoint. Read also the documentation of CLI command 'mmauth genkey commit|propagate'.
*/
func (a *Client) AuthenticationKeyPutv2(params *AuthenticationKeyPutv2Params, authInfo runtime.ClientAuthInfoWriter) (*AuthenticationKeyPutv2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewAuthenticationKeyPutv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "authenticationKeyPutv2",
		Method:             "PUT",
		PathPattern:        "/scalemgmt/v2/remotemount/authenticationkey",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &AuthenticationKeyPutv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*AuthenticationKeyPutv2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for authenticationKeyPutv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  CallhomeGet gets call home configuration data

  Returns the call home configuration data
*/
func (a *Client) CallhomeGet(params *CallhomeGetParams, authInfo runtime.ClientAuthInfoWriter) (*CallhomeGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCallhomeGetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "callhomeGet",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/callhome",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CallhomeGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CallhomeGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for callhomeGet: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  CesServicesServiceGetv2 gets detailed information about a c e s service

  Returns detailed information for a CES Service
*/
func (a *Client) CesServicesServiceGetv2(params *CesServicesServiceGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*CesServicesServiceGetv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCesServicesServiceGetv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "cesServicesServiceGetv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/ces/services/{service}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CesServicesServiceGetv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CesServicesServiceGetv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for cesServicesServiceGetv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  CesaddressesCesAddressGetv2 gets detailed information about a c e s address

  Returns a CES Address information
*/
func (a *Client) CesaddressesCesAddressGetv2(params *CesaddressesCesAddressGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*CesaddressesCesAddressGetv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCesaddressesCesAddressGetv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "cesaddressesCesAddressGetv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/ces/addresses/{cesAddress}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CesaddressesCesAddressGetv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CesaddressesCesAddressGetv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for cesaddressesCesAddressGetv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  CesaddressesGetv2 gets listing of c e s addresses

  Returns the list of CES Addresses
*/
func (a *Client) CesaddressesGetv2(params *CesaddressesGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*CesaddressesGetv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCesaddressesGetv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "cesaddressesGetv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/ces/addresses",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CesaddressesGetv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CesaddressesGetv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for cesaddressesGetv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  CesservicesGetv2 gets listing of c e s services

  Returns the list of CES Services
*/
func (a *Client) CesservicesGetv2(params *CesservicesGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*CesservicesGetv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCesservicesGetv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "cesservicesGetv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/ces/services",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CesservicesGetv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CesservicesGetv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for cesservicesGetv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ClusterGetv2 gets current configuration information

  Get current configuration information
*/
func (a *Client) ClusterGetv2(params *ClusterGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*ClusterGetv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewClusterGetv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "clusterGetv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/cluster",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ClusterGetv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ClusterGetv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for clusterGetv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ClusterJobsDeletev2 cancels a job

  Cancels a job
*/
func (a *Client) ClusterJobsDeletev2(params *ClusterJobsDeletev2Params, authInfo runtime.ClientAuthInfoWriter) (*ClusterJobsDeletev2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewClusterJobsDeletev2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "clusterJobsDeletev2",
		Method:             "DELETE",
		PathPattern:        "/scalemgmt/v2/cluster/jobs/{jobId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ClusterJobsDeletev2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ClusterJobsDeletev2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for clusterJobsDeletev2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ClusterJobsGetv2 gets list of jobs

  Returns list of jobs
*/
func (a *Client) ClusterJobsGetv2(params *ClusterJobsGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*ClusterJobsGetv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewClusterJobsGetv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "clusterJobsGetv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/cluster/jobs",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ClusterJobsGetv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ClusterJobsGetv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for clusterJobsGetv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ClusterJobsGetv20 gets job details

  Returns the job details of a job
*/
func (a *Client) ClusterJobsGetv20(params *ClusterJobsGetv20Params, authInfo runtime.ClientAuthInfoWriter) (*ClusterJobsGetv20OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewClusterJobsGetv20Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "clusterJobsGetv2_0",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/cluster/jobs/{jobId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ClusterJobsGetv20Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ClusterJobsGetv20OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for clusterJobsGetv2_0: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  CoffeeGetv2 gets coffee

  Returns nice Italian style espresso
*/
func (a *Client) CoffeeGetv2(params *CoffeeGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*CoffeeGetv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCoffeeGetv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "coffeeGetv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/coffee",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CoffeeGetv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CoffeeGetv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for coffeeGetv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  CoffeePostv2 donates coffee

  Donate a nice cup of espresso to the developers
*/
func (a *Client) CoffeePostv2(params *CoffeePostv2Params, authInfo runtime.ClientAuthInfoWriter) (*CoffeePostv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCoffeePostv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "coffeePostv2",
		Method:             "POST",
		PathPattern:        "/scalemgmt/v2/coffee",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CoffeePostv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CoffeePostv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for coffeePostv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ConfigGetv2 gets cluster config

  Returns the cluster config - for list of individual config properties consult documentation on mmlsconfig
*/
func (a *Client) ConfigGetv2(params *ConfigGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*ConfigGetv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewConfigGetv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "configGetv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/config",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ConfigGetv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ConfigGetv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for configGetv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ConfigPut changes an attribute value of the g p f s config

  Changes an attribute value of the GPFS config.
*/
func (a *Client) ConfigPut(params *ConfigPutParams, authInfo runtime.ClientAuthInfoWriter) (*ConfigPutAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewConfigPutParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "configPut",
		Method:             "PUT",
		PathPattern:        "/scalemgmt/v2/config",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ConfigPutReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ConfigPutAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for configPut: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  CosDirPostv2 creates a new c o s related directory in a fileset

  Create a new directory related to a corresponding bucket.
*/
func (a *Client) CosDirPostv2(params *CosDirPostv2Params, authInfo runtime.ClientAuthInfoWriter) (*CosDirPostv2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCosDirPostv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "cosDirPostv2",
		Method:             "POST",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/filesets/{filesetName}/cos/directory",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CosDirPostv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CosDirPostv2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for cosDirPostv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  CosFilesetsPostv2 creates a new c o s related fileset

  Create a new fileset related to a corresponding bucket.
*/
func (a *Client) CosFilesetsPostv2(params *CosFilesetsPostv2Params, authInfo runtime.ClientAuthInfoWriter) (*CosFilesetsPostv2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewCosFilesetsPostv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "cosFilesetsPostv2",
		Method:             "POST",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/filesets/cos",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &CosFilesetsPostv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*CosFilesetsPostv2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for cosFilesetsPostv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  DeleteBucketKeysv2 deletes local bucket definition with keys

  Delete local bucket definition with keys.
*/
func (a *Client) DeleteBucketKeysv2(params *DeleteBucketKeysv2Params, authInfo runtime.ClientAuthInfoWriter) (*DeleteBucketKeysv2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDeleteBucketKeysv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "deleteBucketKeysv2",
		Method:             "DELETE",
		PathPattern:        "/scalemgmt/v2/bucket/keys/{bucketName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DeleteBucketKeysv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DeleteBucketKeysv2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for deleteBucketKeysv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  DirectoryDeletev2 removes a directory from a g p f s file system

  Remove a directory from a GPFS file system
*/
func (a *Client) DirectoryDeletev2(params *DirectoryDeletev2Params, authInfo runtime.ClientAuthInfoWriter) (*DirectoryDeletev2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDirectoryDeletev2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "directoryDeletev2",
		Method:             "DELETE",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/directory/{path}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DirectoryDeletev2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DirectoryDeletev2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for directoryDeletev2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  DirectoryDeletev20 removes a directory from a fileset

  Remove a directory from a fileset
*/
func (a *Client) DirectoryDeletev20(params *DirectoryDeletev20Params, authInfo runtime.ClientAuthInfoWriter) (*DirectoryDeletev20Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDirectoryDeletev20Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "directoryDeletev2_0",
		Method:             "DELETE",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/filesets/{filesetName}/directory/{path}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DirectoryDeletev20Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DirectoryDeletev20Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for directoryDeletev2_0: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  DirectoryPostv2 creates a new directory on a g p f s file system

  Creates a new directory on a GPFS file system and sets the owner of it. You can specify user or group or both. If both the id and the name are specified the id takes precedence over the name.
*/
func (a *Client) DirectoryPostv2(params *DirectoryPostv2Params, authInfo runtime.ClientAuthInfoWriter) (*DirectoryPostv2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDirectoryPostv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "directoryPostv2",
		Method:             "POST",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/directory/{path}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DirectoryPostv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DirectoryPostv2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for directoryPostv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  DirectoryPostv20 creates a new directory on a fileset

  Creates a new directory on a fileset and sets the owner of it. You can specify user or group or both. If both the id and the name are specified the id takes precedence over the name.
*/
func (a *Client) DirectoryPostv20(params *DirectoryPostv20Params, authInfo runtime.ClientAuthInfoWriter) (*DirectoryPostv20Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDirectoryPostv20Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "directoryPostv2_0",
		Method:             "POST",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/filesets/{filesetName}/directory/{path}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DirectoryPostv20Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DirectoryPostv20Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for directoryPostv2_0: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  DisksDiskNameGetv2 gets detailed information about a disk

  Returns detailed information about a disk in a filesystem
*/
func (a *Client) DisksDiskNameGetv2(params *DisksDiskNameGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*DisksDiskNameGetv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDisksDiskNameGetv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "disksDiskNameGetv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/disks/{diskName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DisksDiskNameGetv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DisksDiskNameGetv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for disksDiskNameGetv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  DisksGetv2 gets listing of disks

  Returns the list of disks in a filesystem
*/
func (a *Client) DisksGetv2(params *DisksGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*DisksGetv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDisksGetv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "disksGetv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/disks",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DisksGetv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DisksGetv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for disksGetv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  Download downloads files from object store

  Download files from Object Store
*/
func (a *Client) Download(params *DownloadParams, authInfo runtime.ClientAuthInfoWriter) (*DownloadAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDownloadParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "download",
		Method:             "POST",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/filesets/{filesetName}/cos/download",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &DownloadReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*DownloadAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for download: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ElementGet gets detailed information about a element

  Returns detailed information about a element
*/
func (a *Client) ElementGet(params *ElementGetParams, authInfo runtime.ClientAuthInfoWriter) (*ElementGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewElementGetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "elementGet",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/components/elements/{componentId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ElementGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ElementGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for elementGet: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ElementsGet gets listing of component elements

  Returns the list of component elements
*/
func (a *Client) ElementsGet(params *ElementsGetParams, authInfo runtime.ClientAuthInfoWriter) (*ElementsGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewElementsGetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "elementsGet",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/components/elements",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ElementsGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ElementsGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for elementsGet: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  EnableDisableFsAuditPutv2 enables disable update the file system auditing for a file system

  Enable/Disable/Update the file system auditing for a file system.
*/
func (a *Client) EnableDisableFsAuditPutv2(params *EnableDisableFsAuditPutv2Params, authInfo runtime.ClientAuthInfoWriter) (*EnableDisableFsAuditPutv2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewEnableDisableFsAuditPutv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "enableDisableFsAuditPutv2",
		Method:             "PUT",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/audit",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &EnableDisableFsAuditPutv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*EnableDisableFsAuditPutv2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for enableDisableFsAuditPutv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  EnableDisableFsQuotaManagementPutv2 enables disable the quota management for a file system

  Enable/Disable the quota management for a file system.
*/
func (a *Client) EnableDisableFsQuotaManagementPutv2(params *EnableDisableFsQuotaManagementPutv2Params, authInfo runtime.ClientAuthInfoWriter) (*EnableDisableFsQuotaManagementPutv2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewEnableDisableFsQuotaManagementPutv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "enableDisableFsQuotaManagementPutv2",
		Method:             "PUT",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/quotamanagement",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &EnableDisableFsQuotaManagementPutv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*EnableDisableFsQuotaManagementPutv2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for enableDisableFsQuotaManagementPutv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  EnableDisableFsWatchPutv2 enables disable the file system watch for a fileset

  Enable/Disable the file system watch for a fileset.
*/
func (a *Client) EnableDisableFsWatchPutv2(params *EnableDisableFsWatchPutv2Params, authInfo runtime.ClientAuthInfoWriter) (*EnableDisableFsWatchPutv2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewEnableDisableFsWatchPutv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "enableDisableFsWatchPutv2",
		Method:             "PUT",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/filesets/{filesetName}/watch",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &EnableDisableFsWatchPutv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*EnableDisableFsWatchPutv2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for enableDisableFsWatchPutv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  EnableDisableFsWatchPutv20 enables disable the file system watch for a file system

  Enable/Disable the file system watch for a file system.
*/
func (a *Client) EnableDisableFsWatchPutv20(params *EnableDisableFsWatchPutv20Params, authInfo runtime.ClientAuthInfoWriter) (*EnableDisableFsWatchPutv20Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewEnableDisableFsWatchPutv20Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "enableDisableFsWatchPutv2_0",
		Method:             "PUT",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/watch",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &EnableDisableFsWatchPutv20Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*EnableDisableFsWatchPutv20Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for enableDisableFsWatchPutv2_0: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  EnableDisableQuotaDefaultsPutv2 enables disable the quota defaults for a file system

  Enable/Disable the quota defaults for a file system.
*/
func (a *Client) EnableDisableQuotaDefaultsPutv2(params *EnableDisableQuotaDefaultsPutv2Params, authInfo runtime.ClientAuthInfoWriter) (*EnableDisableQuotaDefaultsPutv2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewEnableDisableQuotaDefaultsPutv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "enableDisableQuotaDefaultsPutv2",
		Method:             "PUT",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/quotadefaults",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &EnableDisableQuotaDefaultsPutv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*EnableDisableQuotaDefaultsPutv2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for enableDisableQuotaDefaultsPutv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  EnableDisableQuotaDefaultsPutv20 enables disable the quota defaults for a fileset

  Enable/Disable the quota defaults for a fileset.
*/
func (a *Client) EnableDisableQuotaDefaultsPutv20(params *EnableDisableQuotaDefaultsPutv20Params, authInfo runtime.ClientAuthInfoWriter) (*EnableDisableQuotaDefaultsPutv20Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewEnableDisableQuotaDefaultsPutv20Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "enableDisableQuotaDefaultsPutv2_0",
		Method:             "PUT",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/filesets/{filesetName}/quotadefaults",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &EnableDisableQuotaDefaultsPutv20Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*EnableDisableQuotaDefaultsPutv20Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for enableDisableQuotaDefaultsPutv2_0: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  EnqueueRefreshTask enqueues a background refresh task
*/
func (a *Client) EnqueueRefreshTask(params *EnqueueRefreshTaskParams, authInfo runtime.ClientAuthInfoWriter) error {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewEnqueueRefreshTaskParams()
	}

	_, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "enqueueRefreshTask",
		Method:             "POST",
		PathPattern:        "/scalemgmt/v2/refreshTask/enqueue",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &EnqueueRefreshTaskReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return err
	}
	return nil
}

/*
  EventsGetv2 gets system health events

  Returns a list of currently active System Health events for the given node or nodeclass
*/
func (a *Client) EventsGetv2(params *EventsGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*EventsGetv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewEventsGetv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "eventsGetv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/nodes/{name}/health/events",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &EventsGetv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*EventsGetv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for eventsGetv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  Evict evicts files from object store

  Evict files from Object Store
*/
func (a *Client) Evict(params *EvictParams, authInfo runtime.ClientAuthInfoWriter) (*EvictAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewEvictParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "evict",
		Method:             "POST",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/filesets/{filesetName}/cos/evict",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &EvictReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*EvictAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for evict: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  FailbackPost thes a f m control functions

  The AFM control functions
*/
func (a *Client) FailbackPost(params *FailbackPostParams, authInfo runtime.ClientAuthInfoWriter) (*FailbackPostAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFailbackPostParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "failbackPost",
		Method:             "POST",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/filesets/{filesetName}/afmctl",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FailbackPostReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FailbackPostAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for failbackPost: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  FileCopyPutv2 copies a directory on a g p f s file system

  Copy a directory from a source path to a target path on a GPFS file system
*/
func (a *Client) FileCopyPutv2(params *FileCopyPutv2Params, authInfo runtime.ClientAuthInfoWriter) (*FileCopyPutv2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFileCopyPutv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "fileCopyPutv2",
		Method:             "PUT",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/filesets/{filesetName}/directoryCopy/{sourcePath}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FileCopyPutv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FileCopyPutv2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for fileCopyPutv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  FileCopyPutv20 copies a directory on a g p f s file system

  Copy a directory from a source path to a target path on a GPFS file system
*/
func (a *Client) FileCopyPutv20(params *FileCopyPutv20Params, authInfo runtime.ClientAuthInfoWriter) (*FileCopyPutv20Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFileCopyPutv20Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "fileCopyPutv2_0",
		Method:             "PUT",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/directoryCopy/{sourcePath}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FileCopyPutv20Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FileCopyPutv20Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for fileCopyPutv2_0: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  FilesetAfmState lists afm state in a file system

  List afm state in a filesystem
*/
func (a *Client) FilesetAfmState(params *FilesetAfmStateParams, authInfo runtime.ClientAuthInfoWriter) (*FilesetAfmStateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFilesetAfmStateParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "filesetAfmState",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/afm/state",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FilesetAfmStateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FilesetAfmStateOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for filesetAfmState: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  FilesetsFilesetNameDeletev2 deletes a fileset

  Delete a fileset (all files / folders under this fileset will be deteled)
*/
func (a *Client) FilesetsFilesetNameDeletev2(params *FilesetsFilesetNameDeletev2Params, authInfo runtime.ClientAuthInfoWriter) (*FilesetsFilesetNameDeletev2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFilesetsFilesetNameDeletev2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "filesetsFilesetNameDeletev2",
		Method:             "DELETE",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/filesets/{filesetName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FilesetsFilesetNameDeletev2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FilesetsFilesetNameDeletev2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for filesetsFilesetNameDeletev2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  FilesetsFilesetNameGetv2 gets detailed information about a fileset

  Returns detailed information about a fileset
*/
func (a *Client) FilesetsFilesetNameGetv2(params *FilesetsFilesetNameGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*FilesetsFilesetNameGetv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFilesetsFilesetNameGetv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "filesetsFilesetNameGetv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/filesets/{filesetName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FilesetsFilesetNameGetv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FilesetsFilesetNameGetv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for filesetsFilesetNameGetv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  FilesetsFilesetNamePutv2 changes an existing fileset

  Change the properties of an existing fileset.
*/
func (a *Client) FilesetsFilesetNamePutv2(params *FilesetsFilesetNamePutv2Params, authInfo runtime.ClientAuthInfoWriter) (*FilesetsFilesetNamePutv2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFilesetsFilesetNamePutv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "filesetsFilesetNamePutv2",
		Method:             "PUT",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/filesets/{filesetName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FilesetsFilesetNamePutv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FilesetsFilesetNamePutv2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for filesetsFilesetNamePutv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  FilesetsGetv2 gets listing of filesets

  Returns the list of filesets in a filesystem
*/
func (a *Client) FilesetsGetv2(params *FilesetsGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*FilesetsGetv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFilesetsGetv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "filesetsGetv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/filesets",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FilesetsGetv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FilesetsGetv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for filesetsGetv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  FilesetsLinkv2 links an existing fileset
*/
func (a *Client) FilesetsLinkv2(params *FilesetsLinkv2Params, authInfo runtime.ClientAuthInfoWriter) (*FilesetsLinkv2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFilesetsLinkv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "filesetsLinkv2",
		Method:             "POST",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/filesets/{filesetName}/link",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FilesetsLinkv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FilesetsLinkv2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for filesetsLinkv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  FilesetsPostv2 creates a new fileset

  Create a new fileset. Linking the fileset is optional. To link, provide: path, owner and permissions.
*/
func (a *Client) FilesetsPostv2(params *FilesetsPostv2Params, authInfo runtime.ClientAuthInfoWriter) (*FilesetsPostv2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFilesetsPostv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "filesetsPostv2",
		Method:             "POST",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/filesets",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FilesetsPostv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FilesetsPostv2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for filesetsPostv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  FilesetsUnlinkv2 unlinks an existing fileset
*/
func (a *Client) FilesetsUnlinkv2(params *FilesetsUnlinkv2Params, authInfo runtime.ClientAuthInfoWriter) (*FilesetsUnlinkv2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFilesetsUnlinkv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "filesetsUnlinkv2",
		Method:             "DELETE",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/filesets/{filesetName}/link",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FilesetsUnlinkv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FilesetsUnlinkv2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for filesetsUnlinkv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  FilesystemWatchGetv2 lists of clustered watches enabled on the filesystem

  The watch endpoint returns a list of clustered watches in the filesystem
*/
func (a *Client) FilesystemWatchGetv2(params *FilesystemWatchGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*FilesystemWatchGetv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFilesystemWatchGetv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "filesystemWatchGetv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/watches",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FilesystemWatchGetv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FilesystemWatchGetv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for filesystemWatchGetv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  FilesystemsFilesystemNameGetv2 gets detailed information about a filesystem

  Returns detailed information about the filesystem
*/
func (a *Client) FilesystemsFilesystemNameGetv2(params *FilesystemsFilesystemNameGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*FilesystemsFilesystemNameGetv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFilesystemsFilesystemNameGetv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "filesystemsFilesystemNameGetv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FilesystemsFilesystemNameGetv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FilesystemsFilesystemNameGetv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for filesystemsFilesystemNameGetv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  FilesystemsGetv2 lists of filesystems in the cluster

  The filesystems endpoint returns a list of filesystems in the cluster
*/
func (a *Client) FilesystemsGetv2(params *FilesystemsGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*FilesystemsGetv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewFilesystemsGetv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "filesystemsGetv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/filesystems",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &FilesystemsGetv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*FilesystemsGetv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for filesystemsGetv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  InfoGetv2 gets r e s t API info

  Returns the REST API status
*/
func (a *Client) InfoGetv2(params *InfoGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*InfoGetv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewInfoGetv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "infoGetv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/info",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &InfoGetv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*InfoGetv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for infoGetv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  JobsDeletev2 cancels a job

  Cancels a REST API job
*/
func (a *Client) JobsDeletev2(params *JobsDeletev2Params, authInfo runtime.ClientAuthInfoWriter) (*JobsDeletev2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewJobsDeletev2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "jobsDeletev2",
		Method:             "DELETE",
		PathPattern:        "/scalemgmt/v2/jobs/{jobId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &JobsDeletev2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*JobsDeletev2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for jobsDeletev2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  JobsGetv2 gets list of asynchronous r e s t API jobs

  Returns list of asynchronous REST API jobs
*/
func (a *Client) JobsGetv2(params *JobsGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*JobsGetv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewJobsGetv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "jobsGetv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/jobs",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &JobsGetv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*JobsGetv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for jobsGetv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  JobsGetv20 gets job details

  Returns the job details of a REST API job
*/
func (a *Client) JobsGetv20(params *JobsGetv20Params, authInfo runtime.ClientAuthInfoWriter) (*JobsGetv20OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewJobsGetv20Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "jobsGetv2_0",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/jobs/{jobId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &JobsGetv20Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*JobsGetv20OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for jobsGetv2_0: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  MountFsv2 mounts a specific file system

  "Mount a specific file system.
*/
func (a *Client) MountFsv2(params *MountFsv2Params, authInfo runtime.ClientAuthInfoWriter) (*MountFsv2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewMountFsv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "mountFsv2",
		Method:             "PUT",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/mount",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &MountFsv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*MountFsv2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for mountFsv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  MountFsv20 suspends a specific file system

  "Mount a specific file system.
*/
func (a *Client) MountFsv20(params *MountFsv20Params, authInfo runtime.ClientAuthInfoWriter) (*MountFsv20Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewMountFsv20Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "mountFsv2_0",
		Method:             "PUT",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/suspend",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &MountFsv20Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*MountFsv20Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for mountFsv2_0: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  NfsExportPathDelete deletes a n f s export

  Delete a NFS export
*/
func (a *Client) NfsExportPathDelete(params *NfsExportPathDeleteParams, authInfo runtime.ClientAuthInfoWriter) (*NfsExportPathDeleteAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNfsExportPathDeleteParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "nfsExportPathDelete",
		Method:             "DELETE",
		PathPattern:        "/scalemgmt/v2/nfs/exports/{exportPath}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &NfsExportPathDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NfsExportPathDeleteAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for nfsExportPathDelete: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  NfsExportPathGet gets detailed information about a export

  Returns detailed information about the export
*/
func (a *Client) NfsExportPathGet(params *NfsExportPathGetParams, authInfo runtime.ClientAuthInfoWriter) (*NfsExportPathGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNfsExportPathGetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "nfsExportPathGet",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/nfs/exports/{exportPath}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &NfsExportPathGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NfsExportPathGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for nfsExportPathGet: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  NfsExportPathPut changes an existing nfs export

  Change the properties of an existing nfs export.
*/
func (a *Client) NfsExportPathPut(params *NfsExportPathPutParams, authInfo runtime.ClientAuthInfoWriter) (*NfsExportPathPutAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNfsExportPathPutParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "nfsExportPathPut",
		Method:             "PUT",
		PathPattern:        "/scalemgmt/v2/nfs/exports/{exportPath}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &NfsExportPathPutReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NfsExportPathPutAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for nfsExportPathPut: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  NfsExportPost creates a new nfs export

  Create a new nfs export.
*/
func (a *Client) NfsExportPost(params *NfsExportPostParams, authInfo runtime.ClientAuthInfoWriter) (*NfsExportPostAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNfsExportPostParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "nfsExportPost",
		Method:             "POST",
		PathPattern:        "/scalemgmt/v2/nfs/exports",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &NfsExportPostReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NfsExportPostAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for nfsExportPost: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  NfsExportsGet lists of export in the cluster

  The nfs exports endpoint returns a list of nfs exports in the cluster
*/
func (a *Client) NfsExportsGet(params *NfsExportsGetParams, authInfo runtime.ClientAuthInfoWriter) (*NfsExportsGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNfsExportsGetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "nfsExportsGet",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/nfs/exports",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &NfsExportsGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NfsExportsGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for nfsExportsGet: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  NodeclassNameDeletev2 deletes an existing user defined g p f s nodeclass

  Delete an existing user-defined GPFS nodeclass
*/
func (a *Client) NodeclassNameDeletev2(params *NodeclassNameDeletev2Params, authInfo runtime.ClientAuthInfoWriter) (*NodeclassNameDeletev2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNodeclassNameDeletev2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "nodeclassNameDeletev2",
		Method:             "DELETE",
		PathPattern:        "/scalemgmt/v2/nodeclasses/{nodeclassName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &NodeclassNameDeletev2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NodeclassNameDeletev2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for nodeclassNameDeletev2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  NodeclassNameGetv2 gets detailed information about a nodeclass

  Returns detailed information about the Nodeclass
*/
func (a *Client) NodeclassNameGetv2(params *NodeclassNameGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*NodeclassNameGetv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNodeclassNameGetv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "nodeclassNameGetv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/nodeclasses/{nodeclassName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &NodeclassNameGetv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NodeclassNameGetv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for nodeclassNameGetv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  NodeclassNamePutv2 changes an existing user defined g p f s nodeclass

  Change the member nodes of an existing nodeclass.
*/
func (a *Client) NodeclassNamePutv2(params *NodeclassNamePutv2Params, authInfo runtime.ClientAuthInfoWriter) (*NodeclassNamePutv2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNodeclassNamePutv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "nodeclassNamePutv2",
		Method:             "PUT",
		PathPattern:        "/scalemgmt/v2/nodeclasses/{nodeclassName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &NodeclassNamePutv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NodeclassNamePutv2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for nodeclassNamePutv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  NodeclassPostv2 creates a new user defined g p f s nodeclass

  Create a new user-defined GPFS nodeclass.
*/
func (a *Client) NodeclassPostv2(params *NodeclassPostv2Params, authInfo runtime.ClientAuthInfoWriter) (*NodeclassPostv2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNodeclassPostv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "nodeclassPostv2",
		Method:             "POST",
		PathPattern:        "/scalemgmt/v2/nodeclasses",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &NodeclassPostv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NodeclassPostv2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for nodeclassPostv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  NodeclassesGetv2 gets listing of nodeclasses

  Returns the list of Nodeclasses
*/
func (a *Client) NodeclassesGetv2(params *NodeclassesGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*NodeclassesGetv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNodeclassesGetv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "nodeclassesGetv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/nodeclasses",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &NodeclassesGetv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NodeclassesGetv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for nodeclassesGetv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  NodesChangeMappingv2 changes an existing a f m node mapping

  Change an existing node mapping for AFM and COS.
*/
func (a *Client) NodesChangeMappingv2(params *NodesChangeMappingv2Params, authInfo runtime.ClientAuthInfoWriter) (*NodesChangeMappingv2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNodesChangeMappingv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "nodesChangeMappingv2",
		Method:             "PUT",
		PathPattern:        "/scalemgmt/v2/nodes/afm/mapping/{mappingName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &NodesChangeMappingv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NodesChangeMappingv2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for nodesChangeMappingv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  NodesCreateMappingv2 creates a f m node mapping

  Create node mapping for AFM and COS.
*/
func (a *Client) NodesCreateMappingv2(params *NodesCreateMappingv2Params, authInfo runtime.ClientAuthInfoWriter) (*NodesCreateMappingv2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNodesCreateMappingv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "nodesCreateMappingv2",
		Method:             "POST",
		PathPattern:        "/scalemgmt/v2/nodes/afm/mapping",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &NodesCreateMappingv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NodesCreateMappingv2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for nodesCreateMappingv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  NodesDeleteMappingv2 deletes an existing a f m node mapping

  Delete an existing node mapping for AFM and COS.
*/
func (a *Client) NodesDeleteMappingv2(params *NodesDeleteMappingv2Params, authInfo runtime.ClientAuthInfoWriter) (*NodesDeleteMappingv2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNodesDeleteMappingv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "nodesDeleteMappingv2",
		Method:             "DELETE",
		PathPattern:        "/scalemgmt/v2/nodes/afm/mapping/{mappingName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &NodesDeleteMappingv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NodesDeleteMappingv2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for nodesDeleteMappingv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  NodesDeletev2 deletes one or more existing nodes from the g p f s cluster

  Delete one or more existing nodes from the GPFS cluster
*/
func (a *Client) NodesDeletev2(params *NodesDeletev2Params, authInfo runtime.ClientAuthInfoWriter) (*NodesDeletev2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNodesDeletev2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "nodesDeletev2",
		Method:             "DELETE",
		PathPattern:        "/scalemgmt/v2/nodes/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &NodesDeletev2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NodesDeletev2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for nodesDeletev2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  NodesGetv2 gets listing of nodes

  Returns the list of Nodes
*/
func (a *Client) NodesGetv2(params *NodesGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*NodesGetv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNodesGetv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "nodesGetv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/nodes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &NodesGetv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NodesGetv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for nodesGetv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  NodesListMappingv2 lists all a f m node mapping

  List all node mapping for AFM and COS.
*/
func (a *Client) NodesListMappingv2(params *NodesListMappingv2Params, authInfo runtime.ClientAuthInfoWriter) (*NodesListMappingv2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNodesListMappingv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "nodesListMappingv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/nodes/afm/mapping",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &NodesListMappingv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NodesListMappingv2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for nodesListMappingv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  NodesListMappingv20 lists a specific a f m node mapping

  List all node mapping for AFM and COS.
*/
func (a *Client) NodesListMappingv20(params *NodesListMappingv20Params, authInfo runtime.ClientAuthInfoWriter) (*NodesListMappingv20Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNodesListMappingv20Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "nodesListMappingv2_0",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/nodes/afm/mapping/{mappingName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &NodesListMappingv20Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NodesListMappingv20Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for nodesListMappingv2_0: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  NodesNameGetv2 gets listing for a node

  Returns summary for a Node
*/
func (a *Client) NodesNameGetv2(params *NodesNameGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*NodesNameGetv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNodesNameGetv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "nodesNameGetv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/nodes/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &NodesNameGetv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NodesNameGetv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for nodesNameGetv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  NodesPostv2 adds one or more nodes to the g p f s cluster

  Add one or more nodes to the GPFS cluster.
*/
func (a *Client) NodesPostv2(params *NodesPostv2Params, authInfo runtime.ClientAuthInfoWriter) (*NodesPostv2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNodesPostv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "nodesPostv2",
		Method:             "POST",
		PathPattern:        "/scalemgmt/v2/nodes",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &NodesPostv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NodesPostv2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for nodesPostv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  NodesPutv2 changes node designation for a node or nodeclass

  Enable or disable quorum and/or gateway for a node or nodeclass.
*/
func (a *Client) NodesPutv2(params *NodesPutv2Params, authInfo runtime.ClientAuthInfoWriter) (*NodesPutv2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNodesPutv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "nodesPutv2",
		Method:             "PUT",
		PathPattern:        "/scalemgmt/v2/nodes/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &NodesPutv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NodesPutv2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for nodesPutv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  NodesServiceGetv2 gets status for a c e s service on a node or nodeclass in the g p f s cluster

  Get status for a CES service on a node or nodeclass in the GPFS cluster
*/
func (a *Client) NodesServiceGetv2(params *NodesServiceGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*NodesServiceGetv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNodesServiceGetv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "nodesServiceGetv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/nodes/{name}/services/{serviceName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &NodesServiceGetv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NodesServiceGetv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for nodesServiceGetv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  NodesServicePutv2 starts stop a service on a node or nodeclass in the g p f s cluster

  Start, Stop a service on a node or nodeclass in the GPFS cluster.
*/
func (a *Client) NodesServicePutv2(params *NodesServicePutv2Params, authInfo runtime.ClientAuthInfoWriter) (*NodesServicePutv2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNodesServicePutv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "nodesServicePutv2",
		Method:             "PUT",
		PathPattern:        "/scalemgmt/v2/nodes/{name}/services/{serviceName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &NodesServicePutv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NodesServicePutv2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for nodesServicePutv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  NodesServicesGetv2 gets status for all c e s services on a node or nodeclass in the g p f s cluster

  Get status for all CES services on a node or nodeclass in the GPFS cluster
*/
func (a *Client) NodesServicesGetv2(params *NodesServicesGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*NodesServicesGetv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNodesServicesGetv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "nodesServicesGetv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/nodes/{name}/services",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &NodesServicesGetv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NodesServicesGetv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for nodesServicesGetv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  NsdsGetv2 gets listing of nsds

  Returns the list of nsds
*/
func (a *Client) NsdsGetv2(params *NsdsGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*NsdsGetv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNsdsGetv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "nsdsGetv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/nsds",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &NsdsGetv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NsdsGetv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for nsdsGetv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  NsdsNameGetv2 gets detailed information about a nsd

  Returns detailed information about a nsd
*/
func (a *Client) NsdsNameGetv2(params *NsdsNameGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*NsdsNameGetv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewNsdsNameGetv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "nsdsNameGetv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/nsds/{nsdName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &NsdsNameGetv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*NsdsNameGetv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for nsdsNameGetv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  OwnerGetv2 gets file directory owner

  Returns the owner of a file or directory
*/
func (a *Client) OwnerGetv2(params *OwnerGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*OwnerGetv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewOwnerGetv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ownerGetv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/owner/{path}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &OwnerGetv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*OwnerGetv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ownerGetv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  OwnerPostv2 sets file directory owner

  Sets the owner of a file or directory. You can specify user or group or both. If both the id and the name are specified the id takes precedence over the name.
*/
func (a *Client) OwnerPostv2(params *OwnerPostv2Params, authInfo runtime.ClientAuthInfoWriter) (*OwnerPostv2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewOwnerPostv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "ownerPostv2",
		Method:             "PUT",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/owner/{path}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &OwnerPostv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*OwnerPostv2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for ownerPostv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  OwningClustersDeletev2 unregisters a cluster that own filesystems that can be mounted remotely

  Unregister a cluster that own filesystems that can be mounted remotely. This API must be executed on the cluster that mounts filesystems remotely. Only users with role 'Administrator' or 'CNSS Operator' have permission to for this REST endpoint. Read also the documentation of CLI command 'mmremotecluster delete'.
*/
func (a *Client) OwningClustersDeletev2(params *OwningClustersDeletev2Params, authInfo runtime.ClientAuthInfoWriter) (*OwningClustersDeletev2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewOwningClustersDeletev2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "owningClustersDeletev2",
		Method:             "DELETE",
		PathPattern:        "/scalemgmt/v2/remotemount/owningclusters/{owningCluster}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &OwningClustersDeletev2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*OwningClustersDeletev2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for owningClustersDeletev2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  OwningClustersGetv2 lists clusters that own filesystems that can be mounted remotely

  List the clusters that own filesystems that can be mounted remotely. This API must be executed on a cluster that mounts filesystems remotely. Read also the documentation of CLI command 'mmremotecluster show all'.
*/
func (a *Client) OwningClustersGetv2(params *OwningClustersGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*OwningClustersGetv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewOwningClustersGetv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "owningClustersGetv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/remotemount/owningclusters",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &OwningClustersGetv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*OwningClustersGetv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for owningClustersGetv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  OwningClustersNameGetv2 gets detailed information about a cluster that own filesystems that can be mounted remotely

  Get detailed information about a cluster that own filesystems that can be mounted remotely. This API must be executed on a cluster that mounts filesystems remotely. Read also the documentation of CLI command 'mmremotecluster show owningCluster'.
*/
func (a *Client) OwningClustersNameGetv2(params *OwningClustersNameGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*OwningClustersNameGetv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewOwningClustersNameGetv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "owningClustersNameGetv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/remotemount/owningclusters/{owningCluster}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &OwningClustersNameGetv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*OwningClustersNameGetv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for owningClustersNameGetv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  OwningClustersPostv2 registers a cluster that owns filesystems that can be mounted remotely

  Register a cluster that own filesystems that can be mounted remotely. This API must be executed on the cluster that mounts filesystems remotely. The node names specified in contactNodes must be known host names. If these node names cannot be resolved via DNS, then they must be added to /etc/hosts on all nodes of the cluster that mounts the filesystem remotely. Only users with role 'Administrator' or 'CNSS Operator' have permission to for this REST endpoint. Read also the documentation of CLI command 'mmremotecluster add'.
*/
func (a *Client) OwningClustersPostv2(params *OwningClustersPostv2Params, authInfo runtime.ClientAuthInfoWriter) (*OwningClustersPostv2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewOwningClustersPostv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "owningClustersPostv2",
		Method:             "POST",
		PathPattern:        "/scalemgmt/v2/remotemount/owningclusters",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &OwningClustersPostv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*OwningClustersPostv2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for owningClustersPostv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  OwningClustersPutv2 updates registration of a cluster that own filesystems that can be mounted remotely

  Update registration of a cluster that own filesystems that can be mounted remotely. This API must be executed on the cluster that mounts filesystems remotely. Only users with role 'Administrator' or 'CNSS Operator' have permission to for this REST endpoint. Read also the documentation of CLI command 'mmremotecluster update'.
*/
func (a *Client) OwningClustersPutv2(params *OwningClustersPutv2Params, authInfo runtime.ClientAuthInfoWriter) (*OwningClustersPutv2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewOwningClustersPutv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "owningClustersPutv2",
		Method:             "PUT",
		PathPattern:        "/scalemgmt/v2/remotemount/owningclusters/{owningCluster}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &OwningClustersPutv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*OwningClustersPutv2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for owningClustersPutv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  PdisksGetv2 gets listing of pdisks

  Returns the list of pdisks
*/
func (a *Client) PdisksGetv2(params *PdisksGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*PdisksGetv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPdisksGetv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "pdisksGetv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/gnr/recoverygroups/{recoveryGroupName}/pdisks",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PdisksGetv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PdisksGetv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for pdisksGetv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  PdisksGetv20 gets detailed information about a pdisk

  Returns detailed information about a pdisk
*/
func (a *Client) PdisksGetv20(params *PdisksGetv20Params, authInfo runtime.ClientAuthInfoWriter) (*PdisksGetv20OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPdisksGetv20Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "pdisksGetv2_0",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/gnr/recoverygroups/{recoveryGroupName}/pdisks/{pdiskName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PdisksGetv20Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PdisksGetv20OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for pdisksGetv2_0: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  PerformanceDataGetv2 gets performance data

  Get performance data
*/
func (a *Client) PerformanceDataGetv2(params *PerformanceDataGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*PerformanceDataGetv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPerformanceDataGetv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "performanceDataGetv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/perfmon/data",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PerformanceDataGetv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PerformanceDataGetv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for performanceDataGetv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  PerformanceDataStatsv2 gets performance data stat information

  Get performance data stat information
*/
func (a *Client) PerformanceDataStatsv2(params *PerformanceDataStatsv2Params, authInfo runtime.ClientAuthInfoWriter) (*PerformanceDataStatsv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPerformanceDataStatsv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "performanceDataStatsv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/perfmon/stats",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PerformanceDataStatsv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PerformanceDataStatsv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for performanceDataStatsv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  PoliciesGetv2 lists policies in the cluster

  Returns a list of policies in the cluster.
*/
func (a *Client) PoliciesGetv2(params *PoliciesGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*PoliciesGetv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPoliciesGetv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "policiesGetv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/policies",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PoliciesGetv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PoliciesGetv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for policiesGetv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  PoliciesPostv2 sets a policy for a file system

  Set a policy for a file system
*/
func (a *Client) PoliciesPostv2(params *PoliciesPostv2Params, authInfo runtime.ClientAuthInfoWriter) (*PoliciesPostv2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPoliciesPostv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "policiesPostv2",
		Method:             "PUT",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/policies",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PoliciesPostv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PoliciesPostv2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for policiesPostv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  PsnapsFilesetsPostv2 creates a new a f m peer snapshot

  Create a new AFM peer snapshot
*/
func (a *Client) PsnapsFilesetsPostv2(params *PsnapsFilesetsPostv2Params, authInfo runtime.ClientAuthInfoWriter) (*PsnapsFilesetsPostv2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPsnapsFilesetsPostv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "psnapsFilesetsPostv2",
		Method:             "POST",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/filesets/{filesetName}/psnaps",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PsnapsFilesetsPostv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PsnapsFilesetsPostv2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for psnapsFilesetsPostv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  PsnapsFilesetsSnapshotNameDeletev2 deletes an existing a f m peer snapshot

  Delete an existing AFM peer snapshot
*/
func (a *Client) PsnapsFilesetsSnapshotNameDeletev2(params *PsnapsFilesetsSnapshotNameDeletev2Params, authInfo runtime.ClientAuthInfoWriter) (*PsnapsFilesetsSnapshotNameDeletev2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPsnapsFilesetsSnapshotNameDeletev2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "psnapsFilesetsSnapshotNameDeletev2",
		Method:             "DELETE",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/filesets/{filesetName}/psnaps/{snapshotName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &PsnapsFilesetsSnapshotNameDeletev2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PsnapsFilesetsSnapshotNameDeletev2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for psnapsFilesetsSnapshotNameDeletev2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  QuotaDefaultsFilesetGetv2 lists quota defaults in the cluster

  Returns a list of quota defaults in the cluster. With no parameters, all quota defaults will be returned. For all numbers returned, the unit in which the number of blocks is displayed is 1K.
*/
func (a *Client) QuotaDefaultsFilesetGetv2(params *QuotaDefaultsFilesetGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*QuotaDefaultsFilesetGetv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewQuotaDefaultsFilesetGetv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "quotaDefaultsFilesetGetv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/filesets/{filesetName}/quotadefaults",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &QuotaDefaultsFilesetGetv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*QuotaDefaultsFilesetGetv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for quotaDefaultsFilesetGetv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  QuotaDefaultsFsPostv2 sets the quota defaults u s r g r p or f i l e s e t for a file system

  Set the quota defaults USR, GRP or FILESET for a file system.
*/
func (a *Client) QuotaDefaultsFsPostv2(params *QuotaDefaultsFsPostv2Params, authInfo runtime.ClientAuthInfoWriter) (*QuotaDefaultsFsPostv2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewQuotaDefaultsFsPostv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "quotaDefaultsFsPostv2",
		Method:             "POST",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/quotadefaults",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &QuotaDefaultsFsPostv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*QuotaDefaultsFsPostv2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for quotaDefaultsFsPostv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  QuotaDefaultsFsetPostv2 sets the quota defaults u s r g r p or f i l e s e t for a file system

  Set the quota defaults USR, GRP or FILESET for a file system.
*/
func (a *Client) QuotaDefaultsFsetPostv2(params *QuotaDefaultsFsetPostv2Params, authInfo runtime.ClientAuthInfoWriter) (*QuotaDefaultsFsetPostv2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewQuotaDefaultsFsetPostv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "quotaDefaultsFsetPostv2",
		Method:             "POST",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/filesets/{filesetName}/quotadefaults",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &QuotaDefaultsFsetPostv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*QuotaDefaultsFsetPostv2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for quotaDefaultsFsetPostv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  QuotaDefaultsGetv2 lists quota defaults in the cluster

  Returns a list of quota defaults in the cluster. With no parameters, all quota defaults will be returned. For all numbers returned, the unit in which the number of blocks is displayed is 1K.
*/
func (a *Client) QuotaDefaultsGetv2(params *QuotaDefaultsGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*QuotaDefaultsGetv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewQuotaDefaultsGetv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "quotaDefaultsGetv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/quotadefaults",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &QuotaDefaultsGetv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*QuotaDefaultsGetv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for quotaDefaultsGetv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  QuotaGraceDefaultsFsPostv2 sets the quota defaults u s r g r p or f i l e s e t for a file system

  Set the quota defaults USR, GRP or FILESET for a file system.
*/
func (a *Client) QuotaGraceDefaultsFsPostv2(params *QuotaGraceDefaultsFsPostv2Params, authInfo runtime.ClientAuthInfoWriter) (*QuotaGraceDefaultsFsPostv2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewQuotaGraceDefaultsFsPostv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "quotaGraceDefaultsFsPostv2",
		Method:             "POST",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/quotagracedefaults",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &QuotaGraceDefaultsFsPostv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*QuotaGraceDefaultsFsPostv2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for quotaGraceDefaultsFsPostv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  QuotaGraceDefaultsGetv2 lists quota defaults in the cluster

  Returns a list of quota defaults in the cluster. With no parameters, all quota defaults will be returned. For all numbers returned, the unit in which the number of blocks is displayed is 1K.
*/
func (a *Client) QuotaGraceDefaultsGetv2(params *QuotaGraceDefaultsGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*QuotaGraceDefaultsGetv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewQuotaGraceDefaultsGetv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "quotaGraceDefaultsGetv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/quotagracedefaults",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &QuotaGraceDefaultsGetv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*QuotaGraceDefaultsGetv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for quotaGraceDefaultsGetv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  QuotasGetv2 lists quotas in the cluster

  Returns a list of quotas in the cluster. With no parameters, all limits quotas will be returned. For all quota numbers returned, the unit in which the number of blocks is displayed is 1K.
*/
func (a *Client) QuotasGetv2(params *QuotasGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*QuotasGetv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewQuotasGetv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "quotasGetv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/quotas",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &QuotasGetv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*QuotasGetv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for quotasGetv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  QuotasGetv20 lists quotas in the cluster

  Returns a list of quotas in the cluster. With no parameters, all limits quotas will be returned. For all quota numbers returned, the unit in which the number of blocks is displayed is 1K.
*/
func (a *Client) QuotasGetv20(params *QuotasGetv20Params, authInfo runtime.ClientAuthInfoWriter) (*QuotasGetv20OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewQuotasGetv20Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "quotasGetv2_0",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/filesets/{filesetName}/quotas",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &QuotasGetv20Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*QuotasGetv20OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for quotasGetv2_0: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  QuotasPostv2 sets quota limits default quota limits quota grace settings

  Set quota limits / default quota limits
*/
func (a *Client) QuotasPostv2(params *QuotasPostv2Params, authInfo runtime.ClientAuthInfoWriter) (*QuotasPostv2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewQuotasPostv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "quotasPostv2",
		Method:             "POST",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/quotas",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &QuotasPostv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*QuotasPostv2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for quotasPostv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  QuotasPostv20 sets quota limits default quota limits quota grace settings

  Set quota limits / default quota limits
*/
func (a *Client) QuotasPostv20(params *QuotasPostv20Params, authInfo runtime.ClientAuthInfoWriter) (*QuotasPostv20Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewQuotasPostv20Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "quotasPostv2_0",
		Method:             "POST",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/filesets/{filesetName}/quotas",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &QuotasPostv20Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*QuotasPostv20Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for quotasPostv2_0: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  RecoveryGroupGetv2 gets listing of recovery groups

  Returns a list of recovery groups
*/
func (a *Client) RecoveryGroupGetv2(params *RecoveryGroupGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*RecoveryGroupGetv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRecoveryGroupGetv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "recoveryGroupGetv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/gnr/recoverygroups",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &RecoveryGroupGetv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RecoveryGroupGetv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for recoveryGroupGetv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  RecoveryGroupGetv20 gets listing of vdisk

  Returns the list of vdisk
*/
func (a *Client) RecoveryGroupGetv20(params *RecoveryGroupGetv20Params, authInfo runtime.ClientAuthInfoWriter) (*RecoveryGroupGetv20OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRecoveryGroupGetv20Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "recoveryGroupGetv2_0",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/gnr/recoverygroups/{recoveryGroupName}/vdisks",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &RecoveryGroupGetv20Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RecoveryGroupGetv20OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for recoveryGroupGetv2_0: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  RecoveryGroupNameGetv2 gets detailed information about a recovery group

  Returns detailed information about a recovery group
*/
func (a *Client) RecoveryGroupNameGetv2(params *RecoveryGroupNameGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*RecoveryGroupNameGetv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRecoveryGroupNameGetv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "recoveryGroupNameGetv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/gnr/recoverygroups/{recoveryGroupName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &RecoveryGroupNameGetv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RecoveryGroupNameGetv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for recoveryGroupNameGetv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  RecoveryGroupNameGetv20 gets detailed information about a vdisk

  Returns detailed information about a vdisk
*/
func (a *Client) RecoveryGroupNameGetv20(params *RecoveryGroupNameGetv20Params, authInfo runtime.ClientAuthInfoWriter) (*RecoveryGroupNameGetv20OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRecoveryGroupNameGetv20Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "recoveryGroupNameGetv2_0",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/gnr/recoverygroups/{recoveryGroupName}/vdisks/{vdiskName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &RecoveryGroupNameGetv20Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RecoveryGroupNameGetv20OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for recoveryGroupNameGetv2_0: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  RemoteAccessGet gets details about your access token if you are a security administrator a list of all access tokens is returned

  Returns detailed information about your access to this API. If you are a security administrator a list of all access tokens is returned
*/
func (a *Client) RemoteAccessGet(params *RemoteAccessGetParams, authInfo runtime.ClientAuthInfoWriter) (*RemoteAccessGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRemoteAccessGetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "remoteAccessGet",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/access",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &RemoteAccessGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RemoteAccessGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for remoteAccessGet: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  RemoteAccessPost requests access to this API

  The access request has to be granted by a security admin.
*/
func (a *Client) RemoteAccessPost(params *RemoteAccessPostParams, authInfo runtime.ClientAuthInfoWriter) (*RemoteAccessPostOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRemoteAccessPostParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "remoteAccessPost",
		Method:             "POST",
		PathPattern:        "/scalemgmt/v2/access",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &RemoteAccessPostReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RemoteAccessPostOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for remoteAccessPost: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  RemoteAccessStatusGet gets status about your access token

  Returns the status of your access to this API.
*/
func (a *Client) RemoteAccessStatusGet(params *RemoteAccessStatusGetParams, authInfo runtime.ClientAuthInfoWriter) (*RemoteAccessStatusGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRemoteAccessStatusGetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "remoteAccessStatusGet",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/access/status",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &RemoteAccessStatusGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RemoteAccessStatusGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for remoteAccessStatusGet: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  RemoteClustersChangeAccessv2 changes permission of a cluster for mounting a filesystem remotely

  Change the permission of a cluster for mounting a filesystem remotely. Specify 'all' as filesystem name to allow the cluster to remotely mount any filesystem of the owning cluster. This API must be executed on a cluster that owns the filesystems that should be mounted remotely. Only users with role 'Administrator' or 'CNSS Operator' have permission to for this REST endpoint. Read also the documentation of CLI command 'mmauth grant'.
*/
func (a *Client) RemoteClustersChangeAccessv2(params *RemoteClustersChangeAccessv2Params, authInfo runtime.ClientAuthInfoWriter) (*RemoteClustersChangeAccessv2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRemoteClustersChangeAccessv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "remoteClustersChangeAccessv2",
		Method:             "PUT",
		PathPattern:        "/scalemgmt/v2/remotemount/remoteclusters/{remoteCluster}/access/{owningClusterFilesystem}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &RemoteClustersChangeAccessv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RemoteClustersChangeAccessv2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for remoteClustersChangeAccessv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  RemoteClustersDeletev2 unregisters a cluster that can mount filesystems remotely

  Unregister a cluster that can mount one or more filesystems remotely. This API must be executed on a cluster that owns the filesystems that should no longer be mounted remotely. Only users with role 'Administrator' or 'CNSS Operator' have permission to for this REST endpoint. Read also the documentation of CLI command 'mmauth delete'.
*/
func (a *Client) RemoteClustersDeletev2(params *RemoteClustersDeletev2Params, authInfo runtime.ClientAuthInfoWriter) (*RemoteClustersDeletev2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRemoteClustersDeletev2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "remoteClustersDeletev2",
		Method:             "DELETE",
		PathPattern:        "/scalemgmt/v2/remotemount/remoteclusters/{remoteCluster}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &RemoteClustersDeletev2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RemoteClustersDeletev2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for remoteClustersDeletev2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  RemoteClustersDenyAccessv2 removes permission of a cluster to mount a filesystem remotely

  Remove permission of a cluster to mount a filesystem of the owning cluster. Specify 'all' as filesystem name to remove permission for mounting any filesystem of the owning cluster. This API must be executed on a cluster that owns the filesystems that should no longer be mounted remotely. Only users with role 'Administrator' or 'CNSS Operator' have permission to for this REST endpoint. Read also the documentation of CLI command 'mmauth deny'.
*/
func (a *Client) RemoteClustersDenyAccessv2(params *RemoteClustersDenyAccessv2Params, authInfo runtime.ClientAuthInfoWriter) (*RemoteClustersDenyAccessv2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRemoteClustersDenyAccessv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "remoteClustersDenyAccessv2",
		Method:             "DELETE",
		PathPattern:        "/scalemgmt/v2/remotemount/remoteclusters/{remoteCluster}/deny/{owningClusterFilesystem}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &RemoteClustersDenyAccessv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RemoteClustersDenyAccessv2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for remoteClustersDenyAccessv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  RemoteClustersGetv2 lists clusters that mount filesystems remotely

  List the clusters that mount filesystems of an owning cluster remotely. This API must be executed on the cluster that owns the filesystems that should be mounted remotely. Read also the documentation of CLI command 'mmauth show all'.
*/
func (a *Client) RemoteClustersGetv2(params *RemoteClustersGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*RemoteClustersGetv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRemoteClustersGetv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "remoteClustersGetv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/remotemount/remoteclusters",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &RemoteClustersGetv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RemoteClustersGetv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for remoteClustersGetv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  RemoteClustersGrantAccessv2 authorizes a cluster to mount a filesystem remotely

  Authorize a cluster to mount a filesystem remotely. Specify 'all' as filesystem name to authorize the cluster to mount any filesystem of the owning cluster. This API must be executed on a cluster that owns the filesystems that should be mounted remotely. Only users with role 'Administrator' or 'CNSS Operator' have permission to for this REST endpoint. Read also the documentation of CLI command 'mmauth grant'.
*/
func (a *Client) RemoteClustersGrantAccessv2(params *RemoteClustersGrantAccessv2Params, authInfo runtime.ClientAuthInfoWriter) (*RemoteClustersGrantAccessv2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRemoteClustersGrantAccessv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "remoteClustersGrantAccessv2",
		Method:             "POST",
		PathPattern:        "/scalemgmt/v2/remotemount/remoteclusters/{remoteCluster}/access/{owningClusterFilesystem}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &RemoteClustersGrantAccessv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RemoteClustersGrantAccessv2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for remoteClustersGrantAccessv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  RemoteClustersNameGetv2 gets detailed information about a cluster that mounts filesystems remotely

  Get detailed information about a cluster that mounts filesystems remotely. This API must be executed on the cluster that owns filesystems that should be mounted remotely. Read also the documentation of CLI command 'mmauth show remoteCluster'.
*/
func (a *Client) RemoteClustersNameGetv2(params *RemoteClustersNameGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*RemoteClustersNameGetv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRemoteClustersNameGetv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "remoteClustersNameGetv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/remotemount/remoteclusters/{remoteCluster}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &RemoteClustersNameGetv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RemoteClustersNameGetv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for remoteClustersNameGetv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  RemoteClustersPostv2 registers a cluster that can mount filesystems remotely

  Register a cluster that should can one or more filesystems of a owning cluster. This API must be executed on a cluster that owns filesystems that should be mounted remotely. Only users with role 'Administrator' or 'CNSS Operator' have permission to for this REST endpoint. Read also the documentation of CLI command 'mmauth add'.
*/
func (a *Client) RemoteClustersPostv2(params *RemoteClustersPostv2Params, authInfo runtime.ClientAuthInfoWriter) (*RemoteClustersPostv2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRemoteClustersPostv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "remoteClustersPostv2",
		Method:             "POST",
		PathPattern:        "/scalemgmt/v2/remotemount/remoteclusters",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &RemoteClustersPostv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RemoteClustersPostv2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for remoteClustersPostv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  RemoteClustersPutv2 updates registration of a cluster that can mount filesystems remotely

  Update registration of a cluster that can mount one or more filesystems of a owning cluster. This API must be executed on a cluster that owns filesystems that should be mounted remotely. Only users with role 'Administrator' or 'CNSS Operator' have permission to for this REST endpoint. Read also the documentation of CLI command 'mmauth update'.
*/
func (a *Client) RemoteClustersPutv2(params *RemoteClustersPutv2Params, authInfo runtime.ClientAuthInfoWriter) (*RemoteClustersPutv2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRemoteClustersPutv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "remoteClustersPutv2",
		Method:             "PUT",
		PathPattern:        "/scalemgmt/v2/remotemount/remoteclusters/{remoteCluster}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &RemoteClustersPutv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RemoteClustersPutv2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for remoteClustersPutv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  RemoteFilesystemsDeletev2 deletes a remote filesystem

  Delete a remote filesystem. This API must be executed on the cluster that mounts the filesystem remotely. This will NOT delete the filesystem on the owning cluster. Only users with role 'Administrator' or 'CNSS Operator' have permission to for this REST endpoint. Read also the documentation of CLI command 'mmremotefs delete'.
*/
func (a *Client) RemoteFilesystemsDeletev2(params *RemoteFilesystemsDeletev2Params, authInfo runtime.ClientAuthInfoWriter) (*RemoteFilesystemsDeletev2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRemoteFilesystemsDeletev2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "remoteFilesystemsDeletev2",
		Method:             "DELETE",
		PathPattern:        "/scalemgmt/v2/remotemount/remotefilesystems/{remoteFilesystem}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &RemoteFilesystemsDeletev2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RemoteFilesystemsDeletev2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for remoteFilesystemsDeletev2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  RemoteFilesystemsGetv2 lists remote filesystems

  List the remote filesystems. This API must be executed on a cluster that mounts filesystems remotely. Read also the documentation of CLI command 'mmremotefs show {all | -C owningCluster}'.
*/
func (a *Client) RemoteFilesystemsGetv2(params *RemoteFilesystemsGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*RemoteFilesystemsGetv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRemoteFilesystemsGetv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "remoteFilesystemsGetv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/remotemount/remotefilesystems",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &RemoteFilesystemsGetv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RemoteFilesystemsGetv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for remoteFilesystemsGetv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  RemoteFilesystemsNameGetv2 gets detailed information about a remote filesystem

  Get detailed information about a remote filesystem. This API must be executed on the cluster that mounts filesystems remotely. Read also the documentation of CLI command 'mmremotefs show remoteFilesystem'.
*/
func (a *Client) RemoteFilesystemsNameGetv2(params *RemoteFilesystemsNameGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*RemoteFilesystemsNameGetv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRemoteFilesystemsNameGetv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "remoteFilesystemsNameGetv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/remotemount/remotefilesystems/{remoteFilesystem}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &RemoteFilesystemsNameGetv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RemoteFilesystemsNameGetv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for remoteFilesystemsNameGetv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  RemoteFilesystemsPostv2 creates a new remote filesystem

  Create a new remote filesystem. A remote filesystem is mounting a filesystem from a cluster that owns the filesystem. This API must be executed on the cluster that should mount a filesystem remotely. When specifying the mountOnNodes parameter, the remote filesystem will also be mounted on the specified cluster nodes. Only users with role 'Administrator' or 'CNSS Operator' have permission to for this REST endpoint. Read also the documentation of CLI command 'mmremotefs add'.
*/
func (a *Client) RemoteFilesystemsPostv2(params *RemoteFilesystemsPostv2Params, authInfo runtime.ClientAuthInfoWriter) (*RemoteFilesystemsPostv2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRemoteFilesystemsPostv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "remoteFilesystemsPostv2",
		Method:             "POST",
		PathPattern:        "/scalemgmt/v2/remotemount/remotefilesystems",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &RemoteFilesystemsPostv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RemoteFilesystemsPostv2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for remoteFilesystemsPostv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  RemoteFilesystemsPutv2 updates an existing remote filesystem

  Update an existing remote filesystem. A remote filesystem is mounting a filesystem from a cluster that owns the filesystem. This API must be executed on the cluster that mounts the filesystem remotely. Only users with role 'Administrator' or 'CNSS Operator' have permission to for this REST endpoint. Read also the documentation of CLI command 'mmremotefs update'.
*/
func (a *Client) RemoteFilesystemsPutv2(params *RemoteFilesystemsPutv2Params, authInfo runtime.ClientAuthInfoWriter) (*RemoteFilesystemsPutv2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRemoteFilesystemsPutv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "remoteFilesystemsPutv2",
		Method:             "PUT",
		PathPattern:        "/scalemgmt/v2/remotemount/remotefilesystems/{remoteFilesystem}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &RemoteFilesystemsPutv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*RemoteFilesystemsPutv2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for remoteFilesystemsPutv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ResumeFsv2 resumes a specific file system

  "Mount a specific file system.
*/
func (a *Client) ResumeFsv2(params *ResumeFsv2Params, authInfo runtime.ClientAuthInfoWriter) (*ResumeFsv2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewResumeFsv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "resumeFsv2",
		Method:             "PUT",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/resume",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ResumeFsv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ResumeFsv2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for resumeFsv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  SensorConfigGetOnev2 gets the sensor configuration

  Get the sensor configuration
*/
func (a *Client) SensorConfigGetOnev2(params *SensorConfigGetOnev2Params, authInfo runtime.ClientAuthInfoWriter) (*SensorConfigGetOnev2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSensorConfigGetOnev2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "sensorConfigGetOnev2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/perfmon/sensors/{sensorName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &SensorConfigGetOnev2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SensorConfigGetOnev2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for sensorConfigGetOnev2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  SensorConfigGetOnev20 gets the sensor configuration

  Get the sensor configuration
*/
func (a *Client) SensorConfigGetOnev20(params *SensorConfigGetOnev20Params, authInfo runtime.ClientAuthInfoWriter) (*SensorConfigGetOnev20OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSensorConfigGetOnev20Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "sensorConfigGetOnev2_0",
		Method:             "PUT",
		PathPattern:        "/scalemgmt/v2/perfmon/sensors/{sensorName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &SensorConfigGetOnev20Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SensorConfigGetOnev20OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for sensorConfigGetOnev2_0: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  SensorConfigGetv2 gets the sensor configuration

  Get the sensor configuration
*/
func (a *Client) SensorConfigGetv2(params *SensorConfigGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*SensorConfigGetv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSensorConfigGetv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "sensorConfigGetv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/perfmon/sensors",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &SensorConfigGetv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SensorConfigGetv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for sensorConfigGetv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  SetBucketKeysv2 sets or change keys for a bucket

  Set or change keys for a bucket.
*/
func (a *Client) SetBucketKeysv2(params *SetBucketKeysv2Params, authInfo runtime.ClientAuthInfoWriter) (*SetBucketKeysv2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSetBucketKeysv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "setBucketKeysv2",
		Method:             "PUT",
		PathPattern:        "/scalemgmt/v2/bucket/keys",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &SetBucketKeysv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SetBucketKeysv2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for setBucketKeysv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  SmbShareNameDelete deletes a s m b share

  Delete a SMB share
*/
func (a *Client) SmbShareNameDelete(params *SmbShareNameDeleteParams, authInfo runtime.ClientAuthInfoWriter) (*SmbShareNameDeleteAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSmbShareNameDeleteParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "smbShareNameDelete",
		Method:             "DELETE",
		PathPattern:        "/scalemgmt/v2/smb/shares/{shareName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &SmbShareNameDeleteReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SmbShareNameDeleteAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for smbShareNameDelete: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  SmbShareNameGet gets detailed information about a smb shares

  Returns detailed information about the smb shares
*/
func (a *Client) SmbShareNameGet(params *SmbShareNameGetParams, authInfo runtime.ClientAuthInfoWriter) (*SmbShareNameGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSmbShareNameGetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "smbShareNameGet",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/smb/shares/{shareName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &SmbShareNameGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SmbShareNameGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for smbShareNameGet: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  SmbSharePathPut changes an existing smb share

  Change the properties of an existing smb share.
*/
func (a *Client) SmbSharePathPut(params *SmbSharePathPutParams, authInfo runtime.ClientAuthInfoWriter) (*SmbSharePathPutAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSmbSharePathPutParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "smbSharePathPut",
		Method:             "PUT",
		PathPattern:        "/scalemgmt/v2/smb/shares/{shareName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &SmbSharePathPutReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SmbSharePathPutAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for smbSharePathPut: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  SmbSharePost creates a new smb share

  Create a new smb share.
*/
func (a *Client) SmbSharePost(params *SmbSharePostParams, authInfo runtime.ClientAuthInfoWriter) (*SmbSharePostAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSmbSharePostParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "smbSharePost",
		Method:             "POST",
		PathPattern:        "/scalemgmt/v2/smb/shares",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &SmbSharePostReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SmbSharePostAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for smbSharePost: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  SmbSharesGet lists of smb shares in the cluster

  The smb shares endpoint returns a list of smb shares in the cluster
*/
func (a *Client) SmbSharesGet(params *SmbSharesGetParams, authInfo runtime.ClientAuthInfoWriter) (*SmbSharesGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSmbSharesGetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "smbSharesGet",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/smb/shares",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &SmbSharesGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SmbSharesGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for smbSharesGet: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  SnapshotCopyPathPutv2 copies a directory from a path relative to a snapshot on a g p f s file system

  Copy a directory from a source path relative to a snapshot to a target path on a GPFS file system
*/
func (a *Client) SnapshotCopyPathPutv2(params *SnapshotCopyPathPutv2Params, authInfo runtime.ClientAuthInfoWriter) (*SnapshotCopyPathPutv2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSnapshotCopyPathPutv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "snapshotCopyPathPutv2",
		Method:             "PUT",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/filesets/{filesetName}/snapshotCopy/{snapshotName}/path/{sourcePath}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &SnapshotCopyPathPutv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SnapshotCopyPathPutv2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for snapshotCopyPathPutv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  SnapshotCopyPathPutv20 copies a directory from a path relative to a snapshot on a g p f s file system

  Copy a directory from a source path relative to a snapshot to a target path on a GPFS file system
*/
func (a *Client) SnapshotCopyPathPutv20(params *SnapshotCopyPathPutv20Params, authInfo runtime.ClientAuthInfoWriter) (*SnapshotCopyPathPutv20Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSnapshotCopyPathPutv20Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "snapshotCopyPathPutv2_0",
		Method:             "PUT",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/snapshotCopy/{snapshotName}/path/{sourcePath}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &SnapshotCopyPathPutv20Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SnapshotCopyPathPutv20Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for snapshotCopyPathPutv2_0: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  SnapshotCopyPutv2 copies a snapshot on a g p f s file system

  Copy files from a source snapshot to a target path on a GPFS file system
*/
func (a *Client) SnapshotCopyPutv2(params *SnapshotCopyPutv2Params, authInfo runtime.ClientAuthInfoWriter) (*SnapshotCopyPutv2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSnapshotCopyPutv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "snapshotCopyPutv2",
		Method:             "PUT",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/filesets/{filesetName}/snapshotCopy/{snapshotName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &SnapshotCopyPutv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SnapshotCopyPutv2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for snapshotCopyPutv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  SnapshotCopyPutv20 copies a snapshot on a g p f s file system

  Copy files from a source snapshot to a target path on a GPFS file system
*/
func (a *Client) SnapshotCopyPutv20(params *SnapshotCopyPutv20Params, authInfo runtime.ClientAuthInfoWriter) (*SnapshotCopyPutv20Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSnapshotCopyPutv20Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "snapshotCopyPutv2_0",
		Method:             "PUT",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/snapshotCopy/{snapshotName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &SnapshotCopyPutv20Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SnapshotCopyPutv20Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for snapshotCopyPutv2_0: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  SnapshotsFilesetSnapshotNameGetv2 reads a snapshot for a fileset

  Read a snapshot for a fileset
*/
func (a *Client) SnapshotsFilesetSnapshotNameGetv2(params *SnapshotsFilesetSnapshotNameGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*SnapshotsFilesetSnapshotNameGetv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSnapshotsFilesetSnapshotNameGetv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "snapshotsFilesetSnapshotNameGetv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/filesets/{filesetName}/snapshots/{snapshotName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &SnapshotsFilesetSnapshotNameGetv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SnapshotsFilesetSnapshotNameGetv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for snapshotsFilesetSnapshotNameGetv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  SnapshotsFilesetsGetv2 lists snapshots for the specified fileset

  List snapshots for the specified fileset
*/
func (a *Client) SnapshotsFilesetsGetv2(params *SnapshotsFilesetsGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*SnapshotsFilesetsGetv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSnapshotsFilesetsGetv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "snapshotsFilesetsGetv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/filesets/{filesetName}/snapshots",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &SnapshotsFilesetsGetv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SnapshotsFilesetsGetv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for snapshotsFilesetsGetv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  SnapshotsFilesetsPostv2 creates a new snapshot

  Create a new snapshot
*/
func (a *Client) SnapshotsFilesetsPostv2(params *SnapshotsFilesetsPostv2Params, authInfo runtime.ClientAuthInfoWriter) (*SnapshotsFilesetsPostv2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSnapshotsFilesetsPostv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "snapshotsFilesetsPostv2",
		Method:             "POST",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/filesets/{filesetName}/snapshots",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &SnapshotsFilesetsPostv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SnapshotsFilesetsPostv2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for snapshotsFilesetsPostv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  SnapshotsFilesetsSnapshotNameDeletev2 deletes a snapshot

  Delete a snapshot
*/
func (a *Client) SnapshotsFilesetsSnapshotNameDeletev2(params *SnapshotsFilesetsSnapshotNameDeletev2Params, authInfo runtime.ClientAuthInfoWriter) (*SnapshotsFilesetsSnapshotNameDeletev2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSnapshotsFilesetsSnapshotNameDeletev2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "snapshotsFilesetsSnapshotNameDeletev2",
		Method:             "DELETE",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/filesets/{filesetName}/snapshots/{snapshotName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &SnapshotsFilesetsSnapshotNameDeletev2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SnapshotsFilesetsSnapshotNameDeletev2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for snapshotsFilesetsSnapshotNameDeletev2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  SnapshotsFilesystemPostv2 creates a new snapshot

  Create a new snapshot
*/
func (a *Client) SnapshotsFilesystemPostv2(params *SnapshotsFilesystemPostv2Params, authInfo runtime.ClientAuthInfoWriter) (*SnapshotsFilesystemPostv2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSnapshotsFilesystemPostv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "snapshotsFilesystemPostv2",
		Method:             "POST",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/snapshots",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &SnapshotsFilesystemPostv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SnapshotsFilesystemPostv2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for snapshotsFilesystemPostv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  SnapshotsFilesystemSnapshotNameDeletev2 deletes a snapshot

  Delete a snapshot
*/
func (a *Client) SnapshotsFilesystemSnapshotNameDeletev2(params *SnapshotsFilesystemSnapshotNameDeletev2Params, authInfo runtime.ClientAuthInfoWriter) (*SnapshotsFilesystemSnapshotNameDeletev2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSnapshotsFilesystemSnapshotNameDeletev2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "snapshotsFilesystemSnapshotNameDeletev2",
		Method:             "DELETE",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/snapshots/{snapshotName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &SnapshotsFilesystemSnapshotNameDeletev2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SnapshotsFilesystemSnapshotNameDeletev2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for snapshotsFilesystemSnapshotNameDeletev2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  SnapshotsFilesystemSnapshotNameGetv2 reads a snapshot for a fileset

  Read a snapshot for a fileset
*/
func (a *Client) SnapshotsFilesystemSnapshotNameGetv2(params *SnapshotsFilesystemSnapshotNameGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*SnapshotsFilesystemSnapshotNameGetv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSnapshotsFilesystemSnapshotNameGetv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "snapshotsFilesystemSnapshotNameGetv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/snapshots/{snapshotName}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &SnapshotsFilesystemSnapshotNameGetv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SnapshotsFilesystemSnapshotNameGetv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for snapshotsFilesystemSnapshotNameGetv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  SnapshotsFilesystemsGetv2 lists snapshots in a file system

  List snapshots in a filesystem
*/
func (a *Client) SnapshotsFilesystemsGetv2(params *SnapshotsFilesystemsGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*SnapshotsFilesystemsGetv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSnapshotsFilesystemsGetv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "snapshotsFilesystemsGetv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/snapshots",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &SnapshotsFilesystemsGetv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SnapshotsFilesystemsGetv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for snapshotsFilesystemsGetv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  SpecificationsGet gets listing of component specification

  Returns the list of component specification
*/
func (a *Client) SpecificationsGet(params *SpecificationsGetParams, authInfo runtime.ClientAuthInfoWriter) (*SpecificationsGetOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSpecificationsGetParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "specificationsGet",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/components/specifications",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &SpecificationsGetReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SpecificationsGetOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for specificationsGet: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  StatesGetv2 gets system health states

  Returns a list of currently active System Health states for the given node or nodeclass
*/
func (a *Client) StatesGetv2(params *StatesGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*StatesGetv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewStatesGetv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "statesGetv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/nodes/{name}/health/states",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &StatesGetv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*StatesGetv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for statesGetv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  SymlinkDeletev2 removes a symlink from a g p f s file system

  Remove a symlink from a GPFS file system
*/
func (a *Client) SymlinkDeletev2(params *SymlinkDeletev2Params, authInfo runtime.ClientAuthInfoWriter) (*SymlinkDeletev2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSymlinkDeletev2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "symlinkDeletev2",
		Method:             "DELETE",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/symlink/{path}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &SymlinkDeletev2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SymlinkDeletev2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for symlinkDeletev2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  SymlinkDeletev20 removes a symlink from a fileset

  Remove a symlink from a fileset
*/
func (a *Client) SymlinkDeletev20(params *SymlinkDeletev20Params, authInfo runtime.ClientAuthInfoWriter) (*SymlinkDeletev20Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSymlinkDeletev20Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "symlinkDeletev2_0",
		Method:             "DELETE",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/filesets/{filesetName}/symlink/{path}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &SymlinkDeletev20Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SymlinkDeletev20Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for symlinkDeletev2_0: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  SymlinkPostv2 creates a symlink for a path from a g p f s file system

  Create a symlink for a path from a GPFS file system
*/
func (a *Client) SymlinkPostv2(params *SymlinkPostv2Params, authInfo runtime.ClientAuthInfoWriter) (*SymlinkPostv2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSymlinkPostv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "symlinkPostv2",
		Method:             "POST",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/symlink/{linkPath}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &SymlinkPostv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SymlinkPostv2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for symlinkPostv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  SymlinkPostv20 creates a symlink for a path from a fileset

  Create a symlink for a path from a fileset
*/
func (a *Client) SymlinkPostv20(params *SymlinkPostv20Params, authInfo runtime.ClientAuthInfoWriter) (*SymlinkPostv20Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSymlinkPostv20Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "symlinkPostv2_0",
		Method:             "POST",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/filesets/{filesetName}/symlink/{linkPath}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &SymlinkPostv20Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*SymlinkPostv20Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for symlinkPostv2_0: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ThresholdDeletev2 deletes an existing threshold rule from the g p f s cluster

  Delete an existing threshold rule from the GPFS cluster.
*/
func (a *Client) ThresholdDeletev2(params *ThresholdDeletev2Params, authInfo runtime.ClientAuthInfoWriter) (*ThresholdDeletev2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewThresholdDeletev2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "thresholdDeletev2",
		Method:             "DELETE",
		PathPattern:        "/scalemgmt/v2/thresholds/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ThresholdDeletev2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ThresholdDeletev2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for thresholdDeletev2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ThresholdGetv2 gets listing for a threshold rule

  Returns summary for a threshold rule.
*/
func (a *Client) ThresholdGetv2(params *ThresholdGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*ThresholdGetv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewThresholdGetv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "thresholdGetv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/thresholds/{name}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ThresholdGetv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ThresholdGetv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for thresholdGetv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ThresholdPostv2 adds a threshold rule to the g p f s cluster

  Add a threshold rule to the GPFS cluster.
*/
func (a *Client) ThresholdPostv2(params *ThresholdPostv2Params, authInfo runtime.ClientAuthInfoWriter) (*ThresholdPostv2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewThresholdPostv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "thresholdPostv2",
		Method:             "POST",
		PathPattern:        "/scalemgmt/v2/thresholds",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ThresholdPostv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ThresholdPostv2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for thresholdPostv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  ThresholdsGetv2 gets list of all threshold rules

  Get list of all threshold rules
*/
func (a *Client) ThresholdsGetv2(params *ThresholdsGetv2Params, authInfo runtime.ClientAuthInfoWriter) (*ThresholdsGetv2OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewThresholdsGetv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "thresholdsGetv2",
		Method:             "GET",
		PathPattern:        "/scalemgmt/v2/thresholds",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &ThresholdsGetv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*ThresholdsGetv2OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for thresholdsGetv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  UnmountFsv2 unmounts a specific file system

  "Unmount a specific file system.
*/
func (a *Client) UnmountFsv2(params *UnmountFsv2Params, authInfo runtime.ClientAuthInfoWriter) (*UnmountFsv2Accepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUnmountFsv2Params()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "unmountFsv2",
		Method:             "PUT",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/unmount",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UnmountFsv2Reader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UnmountFsv2Accepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for unmountFsv2: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  Upload uploads files to object store

  Upload files from Object Store
*/
func (a *Client) Upload(params *UploadParams, authInfo runtime.ClientAuthInfoWriter) (*UploadAccepted, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewUploadParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "upload",
		Method:             "POST",
		PathPattern:        "/scalemgmt/v2/filesystems/{filesystemName}/filesets/{filesetName}/cos/upload",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"http"},
		Params:             params,
		Reader:             &UploadReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	success, ok := result.(*UploadAccepted)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for upload: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
