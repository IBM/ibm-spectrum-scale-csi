// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// SmbOptions smb options
//
// swagger:model SmbOptions
type SmbOptions struct {

	// Using this option, administrative users can be defined in the format of admin users=user1;user2;..;usern. The users must be domain users.
	AdminUsers string `json:"adminUsers,omitempty"`

	// If the value is set as yes, the export is shown in the Windows Explorer browser when browsing the file server.
	// Enum: [yes no]
	Browseable string `json:"browseable,omitempty"`

	// A free text description of the export.
	Comment string `json:"comment,omitempty"`

	// csc policy stands for client-side caching policy, and specifies how clients capable of offline caching will cache the files in the share.
	// Enum: [manual disable documents programs]
	CscPolicy string `json:"cscPolicy,omitempty"`

	// This option allows to control the level of enforced data integrity. If the data integrity is ensured on the application level, it can be beneficial in cluster environments to reduce the level of enforced integrity for performance reasons.
	// Enum: [fsname hostname fsnamenodirs fsnamenorootdir]
	FileIDAlgorithm string `json:"fileIdAlgorithm,omitempty"`

	// gpfs:leases are cross protocol opLocks (opportunistic locks), that means an SMB client can lock a file that provides the user improved performance while reading or writing to the file because no other user read or write to this file. If the value is set as yes, clients accessing the file over the other protocols can break the lock of a SMB client and the user gets informed when another user is accessing the same file at the same time.
	// Enum: [yes no]
	GpfsLeases string `json:"gpfsLeases,omitempty"`

	// If the value is set as yes files that have been migrated from disk will be recalled on access. If recalls = no files will not be recalled on access and the client will receive
	// Enum: [yes no]
	GpfsRecalls string `json:"gpfsRecalls,omitempty"`

	// An application can set share modes. If you set gpfs:sharemodes = yes, the sharemodes specified by the application will be respected by all protocols and not only by the SMB protocol. If you set gpfs:sharemodes = no the sharemodes specified by the application will only be respected by the SMB protocol.
	// Enum: [yes no]
	GpfsShareModes string `json:"gpfsShareModes,omitempty"`

	// If the value is set as yes, it specifies the files in an export, for which the setting is enabled, are opened with the OSYNC flag. Accessing a file is faster if gpfs:syncio is set to yes. Performance for certain workloads can be improved when SMB accesses the file with the OSYNC flag set. For example, updating only small blocks in a large file as observed with database applications. The underlying GPFS behavior is then changed to not read a complete block if there is only a small update to it.
	// Enum: [yes no]
	GpfsSyncIo string `json:"gpfsSyncIo,omitempty"`

	// If the value is set to yes, files starting with "." are hidden.
	// Enum: [yes no]
	HideDotFiles string `json:"hideDotFiles,omitempty"`

	// If the value is set as yes, all files and directories that the user has no permission to read is hidden from directory listings in the export. The hideUnreadable=yes option is also known as access−based enumeration because when a user is listing (enumerating) the directories and files within the export, they only see the files and directories that they have read access to.
	// Enum: [yes no]
	HideUnreadable string `json:"hideUnreadable,omitempty"`

	// If the value is set as yes, a client may request an opportunistic lock (oplock) from an SMB server when it opens a file. If the server grants the request, the client can cache large chunks of the file without informing the server what it is doing with the cached chunks until the task is completed. Caching large chunks of a file saves a lot of network I/O round−trip time and enhances performance.
	// Enum: [yes no]
	OpLocks string `json:"opLocks,omitempty"`

	// If the value is set as yes, it will be tested if a byte−range (fcntl) lock is already present on the requested portion of the file before granting a byte−range lock to an SMB client. For improved performance on SMB−only shares this option can be disabled. Disabling locking on cross−protocol shares can result in data integrity issues when clients concurrently set locks on a file via multiple protocols, for example, SMB and NFS.
	// Enum: [yes no]
	PosixLocking string `json:"posixLocking,omitempty"`

	// If the value is set as yes, files cannot be modified or created on this export independent of the ACLs.
	// Enum: [yes no]
	ReadOnly string `json:"readOnly,omitempty"`

	// This option controls whether the remote client is allowed or required to use SMB encryption. Possible values are auto (or default), mandatory, disabled and desired. Clients may chose to encrypt the entire session, not just traffic to a specific export.
	// Enum: [auto default mandatory disabled desired]
	SmbEncrypt string `json:"smbEncrypt,omitempty"`

	// This option ensures that the file system synchronizes data to the disk each time a file is closed after writing. The written data is flushed to the disk.
	// Enum: [yes no]
	SyncOpsOnClose string `json:"syncOpsOnClose,omitempty"`
}

// Validate validates this smb options
func (m *SmbOptions) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBrowseable(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCscPolicy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFileIDAlgorithm(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGpfsLeases(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGpfsRecalls(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGpfsShareModes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGpfsSyncIo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHideDotFiles(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHideUnreadable(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOpLocks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePosixLocking(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateReadOnly(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSmbEncrypt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSyncOpsOnClose(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var smbOptionsTypeBrowseablePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["yes","no"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		smbOptionsTypeBrowseablePropEnum = append(smbOptionsTypeBrowseablePropEnum, v)
	}
}

const (

	// SmbOptionsBrowseableYes captures enum value "yes"
	SmbOptionsBrowseableYes string = "yes"

	// SmbOptionsBrowseableNo captures enum value "no"
	SmbOptionsBrowseableNo string = "no"
)

// prop value enum
func (m *SmbOptions) validateBrowseableEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, smbOptionsTypeBrowseablePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *SmbOptions) validateBrowseable(formats strfmt.Registry) error {

	if swag.IsZero(m.Browseable) { // not required
		return nil
	}

	// value enum
	if err := m.validateBrowseableEnum("browseable", "body", m.Browseable); err != nil {
		return err
	}

	return nil
}

var smbOptionsTypeCscPolicyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["manual","disable","documents","programs"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		smbOptionsTypeCscPolicyPropEnum = append(smbOptionsTypeCscPolicyPropEnum, v)
	}
}

const (

	// SmbOptionsCscPolicyManual captures enum value "manual"
	SmbOptionsCscPolicyManual string = "manual"

	// SmbOptionsCscPolicyDisable captures enum value "disable"
	SmbOptionsCscPolicyDisable string = "disable"

	// SmbOptionsCscPolicyDocuments captures enum value "documents"
	SmbOptionsCscPolicyDocuments string = "documents"

	// SmbOptionsCscPolicyPrograms captures enum value "programs"
	SmbOptionsCscPolicyPrograms string = "programs"
)

// prop value enum
func (m *SmbOptions) validateCscPolicyEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, smbOptionsTypeCscPolicyPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *SmbOptions) validateCscPolicy(formats strfmt.Registry) error {

	if swag.IsZero(m.CscPolicy) { // not required
		return nil
	}

	// value enum
	if err := m.validateCscPolicyEnum("cscPolicy", "body", m.CscPolicy); err != nil {
		return err
	}

	return nil
}

var smbOptionsTypeFileIDAlgorithmPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["fsname","hostname","fsnamenodirs","fsnamenorootdir"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		smbOptionsTypeFileIDAlgorithmPropEnum = append(smbOptionsTypeFileIDAlgorithmPropEnum, v)
	}
}

const (

	// SmbOptionsFileIDAlgorithmFsname captures enum value "fsname"
	SmbOptionsFileIDAlgorithmFsname string = "fsname"

	// SmbOptionsFileIDAlgorithmHostname captures enum value "hostname"
	SmbOptionsFileIDAlgorithmHostname string = "hostname"

	// SmbOptionsFileIDAlgorithmFsnamenodirs captures enum value "fsnamenodirs"
	SmbOptionsFileIDAlgorithmFsnamenodirs string = "fsnamenodirs"

	// SmbOptionsFileIDAlgorithmFsnamenorootdir captures enum value "fsnamenorootdir"
	SmbOptionsFileIDAlgorithmFsnamenorootdir string = "fsnamenorootdir"
)

// prop value enum
func (m *SmbOptions) validateFileIDAlgorithmEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, smbOptionsTypeFileIDAlgorithmPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *SmbOptions) validateFileIDAlgorithm(formats strfmt.Registry) error {

	if swag.IsZero(m.FileIDAlgorithm) { // not required
		return nil
	}

	// value enum
	if err := m.validateFileIDAlgorithmEnum("fileIdAlgorithm", "body", m.FileIDAlgorithm); err != nil {
		return err
	}

	return nil
}

var smbOptionsTypeGpfsLeasesPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["yes","no"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		smbOptionsTypeGpfsLeasesPropEnum = append(smbOptionsTypeGpfsLeasesPropEnum, v)
	}
}

const (

	// SmbOptionsGpfsLeasesYes captures enum value "yes"
	SmbOptionsGpfsLeasesYes string = "yes"

	// SmbOptionsGpfsLeasesNo captures enum value "no"
	SmbOptionsGpfsLeasesNo string = "no"
)

// prop value enum
func (m *SmbOptions) validateGpfsLeasesEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, smbOptionsTypeGpfsLeasesPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *SmbOptions) validateGpfsLeases(formats strfmt.Registry) error {

	if swag.IsZero(m.GpfsLeases) { // not required
		return nil
	}

	// value enum
	if err := m.validateGpfsLeasesEnum("gpfsLeases", "body", m.GpfsLeases); err != nil {
		return err
	}

	return nil
}

var smbOptionsTypeGpfsRecallsPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["yes","no"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		smbOptionsTypeGpfsRecallsPropEnum = append(smbOptionsTypeGpfsRecallsPropEnum, v)
	}
}

const (

	// SmbOptionsGpfsRecallsYes captures enum value "yes"
	SmbOptionsGpfsRecallsYes string = "yes"

	// SmbOptionsGpfsRecallsNo captures enum value "no"
	SmbOptionsGpfsRecallsNo string = "no"
)

// prop value enum
func (m *SmbOptions) validateGpfsRecallsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, smbOptionsTypeGpfsRecallsPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *SmbOptions) validateGpfsRecalls(formats strfmt.Registry) error {

	if swag.IsZero(m.GpfsRecalls) { // not required
		return nil
	}

	// value enum
	if err := m.validateGpfsRecallsEnum("gpfsRecalls", "body", m.GpfsRecalls); err != nil {
		return err
	}

	return nil
}

var smbOptionsTypeGpfsShareModesPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["yes","no"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		smbOptionsTypeGpfsShareModesPropEnum = append(smbOptionsTypeGpfsShareModesPropEnum, v)
	}
}

const (

	// SmbOptionsGpfsShareModesYes captures enum value "yes"
	SmbOptionsGpfsShareModesYes string = "yes"

	// SmbOptionsGpfsShareModesNo captures enum value "no"
	SmbOptionsGpfsShareModesNo string = "no"
)

// prop value enum
func (m *SmbOptions) validateGpfsShareModesEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, smbOptionsTypeGpfsShareModesPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *SmbOptions) validateGpfsShareModes(formats strfmt.Registry) error {

	if swag.IsZero(m.GpfsShareModes) { // not required
		return nil
	}

	// value enum
	if err := m.validateGpfsShareModesEnum("gpfsShareModes", "body", m.GpfsShareModes); err != nil {
		return err
	}

	return nil
}

var smbOptionsTypeGpfsSyncIoPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["yes","no"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		smbOptionsTypeGpfsSyncIoPropEnum = append(smbOptionsTypeGpfsSyncIoPropEnum, v)
	}
}

const (

	// SmbOptionsGpfsSyncIoYes captures enum value "yes"
	SmbOptionsGpfsSyncIoYes string = "yes"

	// SmbOptionsGpfsSyncIoNo captures enum value "no"
	SmbOptionsGpfsSyncIoNo string = "no"
)

// prop value enum
func (m *SmbOptions) validateGpfsSyncIoEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, smbOptionsTypeGpfsSyncIoPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *SmbOptions) validateGpfsSyncIo(formats strfmt.Registry) error {

	if swag.IsZero(m.GpfsSyncIo) { // not required
		return nil
	}

	// value enum
	if err := m.validateGpfsSyncIoEnum("gpfsSyncIo", "body", m.GpfsSyncIo); err != nil {
		return err
	}

	return nil
}

var smbOptionsTypeHideDotFilesPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["yes","no"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		smbOptionsTypeHideDotFilesPropEnum = append(smbOptionsTypeHideDotFilesPropEnum, v)
	}
}

const (

	// SmbOptionsHideDotFilesYes captures enum value "yes"
	SmbOptionsHideDotFilesYes string = "yes"

	// SmbOptionsHideDotFilesNo captures enum value "no"
	SmbOptionsHideDotFilesNo string = "no"
)

// prop value enum
func (m *SmbOptions) validateHideDotFilesEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, smbOptionsTypeHideDotFilesPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *SmbOptions) validateHideDotFiles(formats strfmt.Registry) error {

	if swag.IsZero(m.HideDotFiles) { // not required
		return nil
	}

	// value enum
	if err := m.validateHideDotFilesEnum("hideDotFiles", "body", m.HideDotFiles); err != nil {
		return err
	}

	return nil
}

var smbOptionsTypeHideUnreadablePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["yes","no"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		smbOptionsTypeHideUnreadablePropEnum = append(smbOptionsTypeHideUnreadablePropEnum, v)
	}
}

const (

	// SmbOptionsHideUnreadableYes captures enum value "yes"
	SmbOptionsHideUnreadableYes string = "yes"

	// SmbOptionsHideUnreadableNo captures enum value "no"
	SmbOptionsHideUnreadableNo string = "no"
)

// prop value enum
func (m *SmbOptions) validateHideUnreadableEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, smbOptionsTypeHideUnreadablePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *SmbOptions) validateHideUnreadable(formats strfmt.Registry) error {

	if swag.IsZero(m.HideUnreadable) { // not required
		return nil
	}

	// value enum
	if err := m.validateHideUnreadableEnum("hideUnreadable", "body", m.HideUnreadable); err != nil {
		return err
	}

	return nil
}

var smbOptionsTypeOpLocksPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["yes","no"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		smbOptionsTypeOpLocksPropEnum = append(smbOptionsTypeOpLocksPropEnum, v)
	}
}

const (

	// SmbOptionsOpLocksYes captures enum value "yes"
	SmbOptionsOpLocksYes string = "yes"

	// SmbOptionsOpLocksNo captures enum value "no"
	SmbOptionsOpLocksNo string = "no"
)

// prop value enum
func (m *SmbOptions) validateOpLocksEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, smbOptionsTypeOpLocksPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *SmbOptions) validateOpLocks(formats strfmt.Registry) error {

	if swag.IsZero(m.OpLocks) { // not required
		return nil
	}

	// value enum
	if err := m.validateOpLocksEnum("opLocks", "body", m.OpLocks); err != nil {
		return err
	}

	return nil
}

var smbOptionsTypePosixLockingPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["yes","no"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		smbOptionsTypePosixLockingPropEnum = append(smbOptionsTypePosixLockingPropEnum, v)
	}
}

const (

	// SmbOptionsPosixLockingYes captures enum value "yes"
	SmbOptionsPosixLockingYes string = "yes"

	// SmbOptionsPosixLockingNo captures enum value "no"
	SmbOptionsPosixLockingNo string = "no"
)

// prop value enum
func (m *SmbOptions) validatePosixLockingEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, smbOptionsTypePosixLockingPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *SmbOptions) validatePosixLocking(formats strfmt.Registry) error {

	if swag.IsZero(m.PosixLocking) { // not required
		return nil
	}

	// value enum
	if err := m.validatePosixLockingEnum("posixLocking", "body", m.PosixLocking); err != nil {
		return err
	}

	return nil
}

var smbOptionsTypeReadOnlyPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["yes","no"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		smbOptionsTypeReadOnlyPropEnum = append(smbOptionsTypeReadOnlyPropEnum, v)
	}
}

const (

	// SmbOptionsReadOnlyYes captures enum value "yes"
	SmbOptionsReadOnlyYes string = "yes"

	// SmbOptionsReadOnlyNo captures enum value "no"
	SmbOptionsReadOnlyNo string = "no"
)

// prop value enum
func (m *SmbOptions) validateReadOnlyEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, smbOptionsTypeReadOnlyPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *SmbOptions) validateReadOnly(formats strfmt.Registry) error {

	if swag.IsZero(m.ReadOnly) { // not required
		return nil
	}

	// value enum
	if err := m.validateReadOnlyEnum("readOnly", "body", m.ReadOnly); err != nil {
		return err
	}

	return nil
}

var smbOptionsTypeSmbEncryptPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["auto","default","mandatory","disabled","desired"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		smbOptionsTypeSmbEncryptPropEnum = append(smbOptionsTypeSmbEncryptPropEnum, v)
	}
}

const (

	// SmbOptionsSmbEncryptAuto captures enum value "auto"
	SmbOptionsSmbEncryptAuto string = "auto"

	// SmbOptionsSmbEncryptDefault captures enum value "default"
	SmbOptionsSmbEncryptDefault string = "default"

	// SmbOptionsSmbEncryptMandatory captures enum value "mandatory"
	SmbOptionsSmbEncryptMandatory string = "mandatory"

	// SmbOptionsSmbEncryptDisabled captures enum value "disabled"
	SmbOptionsSmbEncryptDisabled string = "disabled"

	// SmbOptionsSmbEncryptDesired captures enum value "desired"
	SmbOptionsSmbEncryptDesired string = "desired"
)

// prop value enum
func (m *SmbOptions) validateSmbEncryptEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, smbOptionsTypeSmbEncryptPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *SmbOptions) validateSmbEncrypt(formats strfmt.Registry) error {

	if swag.IsZero(m.SmbEncrypt) { // not required
		return nil
	}

	// value enum
	if err := m.validateSmbEncryptEnum("smbEncrypt", "body", m.SmbEncrypt); err != nil {
		return err
	}

	return nil
}

var smbOptionsTypeSyncOpsOnClosePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["yes","no"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		smbOptionsTypeSyncOpsOnClosePropEnum = append(smbOptionsTypeSyncOpsOnClosePropEnum, v)
	}
}

const (

	// SmbOptionsSyncOpsOnCloseYes captures enum value "yes"
	SmbOptionsSyncOpsOnCloseYes string = "yes"

	// SmbOptionsSyncOpsOnCloseNo captures enum value "no"
	SmbOptionsSyncOpsOnCloseNo string = "no"
)

// prop value enum
func (m *SmbOptions) validateSyncOpsOnCloseEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, smbOptionsTypeSyncOpsOnClosePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *SmbOptions) validateSyncOpsOnClose(formats strfmt.Registry) error {

	if swag.IsZero(m.SyncOpsOnClose) { // not required
		return nil
	}

	// value enum
	if err := m.validateSyncOpsOnCloseEnum("syncOpsOnClose", "body", m.SyncOpsOnClose); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SmbOptions) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SmbOptions) UnmarshalBinary(b []byte) error {
	var res SmbOptions
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
