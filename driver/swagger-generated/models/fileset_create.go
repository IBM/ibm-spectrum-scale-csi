// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// FilesetCreate Object that can be used to create a new fileset
//
// swagger:model FilesetCreate
type FilesetCreate struct {

	// Specifies (in seconds) the amount of time by which write operations are delayed
	AfmAsyncDelay int32 `json:"afmAsyncDelay,omitempty"`

	// Controls the frequency of data revalidations that are triggered by such lookup operations as ls or stat (specified in seconds)
	AfmDirLookupRefreshInterval int32 `json:"afmDirLookupRefreshInterval,omitempty"`

	// Controls the frequency of data revalidations that are triggered by such I/O operations as read or write (specified in seconds)
	AfmDirOpenRefreshInterval int32 `json:"afmDirOpenRefreshInterval,omitempty"`

	// Specifies if eviction is enabled
	AfmEnableAutoEviction bool `json:"afmEnableAutoEviction,omitempty"`

	// Is used with afmDisconnectTimeout (which can be set only through mmchconfig) to control how long a network outage between the cache and home clusters can continue before the data in the cache is considered out of sync with home.
	AfmExpirationTimeout int32 `json:"afmExpirationTimeout,omitempty"`

	// Controls the frequency of data revalidations that are triggered by such lookup operations as ls or stat (specified in seconds)
	AfmFileLookupRefreshInterval int32 `json:"afmFileLookupRefreshInterval,omitempty"`

	// Specifies the mode in which the cache operates
	// Enum: [single-writer read-only local-updates independent-writer Primary Secondary]
	AfmMode string `json:"afmMode,omitempty"`

	// Defines the number of threads used on each gateway to synchronize updates to the home cluster
	AfmNumFlushThreads int32 `json:"afmNumFlushThreads,omitempty"`

	// Defines the minimum chunk size of the read that needs to be distributed among the gateway nodes during parallel reads
	AfmParallelReadChunkSize int32 `json:"afmParallelReadChunkSize,omitempty"`

	// Defines the threshold beyond which parallel reads become effective
	AfmParallelReadThreshold int32 `json:"afmParallelReadThreshold,omitempty"`

	// Defines the minimum chunk size of the write that needs to be distributed among the gateway nodes during parallel writes
	AfmParallelWriteChunkSize int32 `json:"afmParallelWriteChunkSize,omitempty"`

	// Defines the threshold beyond which parallel writes become effective
	AfmParallelWriteThreshold int32 `json:"afmParallelWriteThreshold,omitempty"`

	// Controls partial file caching and prefetching
	AfmPrefetchThreshold int32 `json:"afmPrefetchThreshold,omitempty"`

	// Specifies the unique primary ID of the primary fileset for asynchronous data replication
	AfmPrimaryID string `json:"afmPrimaryID,omitempty"`

	// Specifies the recovery point objective (RPO) interval in minutes for a primary fileset
	AfmRPO int32 `json:"afmRPO,omitempty"`

	// Controls the visibility of the home snapshot directory in cache
	AfmShowHomeSnapshots bool `json:"afmShowHomeSnapshots,omitempty"`

	// Identifies the home that is associated with the cache
	AfmTarget string `json:"afmTarget,omitempty"`

	// Specifies the new number of pre-allocated inodes for this fileset
	AllocInodes string `json:"allocInodes,omitempty"`

	// The comment that belongs to this fileset
	Comment string `json:"comment,omitempty"`

	// Specifies that the directories specified with the junction path will be created if they do not exist.
	CreateDirectory bool `json:"createDirectory,omitempty"`

	// The name of the fileset
	// Required: true
	FilesetName *string `json:"filesetName"`

	// Specifies the integrated archive manager (IAM) mode for the fileset.
	// Enum: [compliant noncompliant advisory]
	IamMode string `json:"iamMode,omitempty"`

	// The name of the parent fileset
	InodeSpace string `json:"inodeSpace,omitempty"`

	// Specifies the new maximum number of inodes allowed for this fileset
	MaxNumInodes string `json:"maxNumInodes,omitempty"`

	// The owner of the filest
	Owner string `json:"owner,omitempty"`

	// The path the fileset will be linked to. If not specified the fileset will be linked to the default path, e.g. /mnt/gpfs0/fset1
	Path string `json:"path,omitempty"`

	// Specifies the permission change mode.
	// Enum: [chmodOnly setAclOnly chmodAndSetAcl chmodAndUpdateAcl]
	PermissionChangeMode string `json:"permissionChangeMode,omitempty"`

	// The permissions that will be set using chmod. If not specified a default ACL will be applied.
	Permissions int32 `json:"permissions,omitempty"`
}

// Validate validates this fileset create
func (m *FilesetCreate) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAfmMode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFilesetName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIamMode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePermissionChangeMode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var filesetCreateTypeAfmModePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["single-writer","read-only","local-updates","independent-writer","Primary","Secondary"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		filesetCreateTypeAfmModePropEnum = append(filesetCreateTypeAfmModePropEnum, v)
	}
}

const (

	// FilesetCreateAfmModeSingleWriter captures enum value "single-writer"
	FilesetCreateAfmModeSingleWriter string = "single-writer"

	// FilesetCreateAfmModeReadOnly captures enum value "read-only"
	FilesetCreateAfmModeReadOnly string = "read-only"

	// FilesetCreateAfmModeLocalUpdates captures enum value "local-updates"
	FilesetCreateAfmModeLocalUpdates string = "local-updates"

	// FilesetCreateAfmModeIndependentWriter captures enum value "independent-writer"
	FilesetCreateAfmModeIndependentWriter string = "independent-writer"

	// FilesetCreateAfmModePrimary captures enum value "Primary"
	FilesetCreateAfmModePrimary string = "Primary"

	// FilesetCreateAfmModeSecondary captures enum value "Secondary"
	FilesetCreateAfmModeSecondary string = "Secondary"
)

// prop value enum
func (m *FilesetCreate) validateAfmModeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, filesetCreateTypeAfmModePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *FilesetCreate) validateAfmMode(formats strfmt.Registry) error {

	if swag.IsZero(m.AfmMode) { // not required
		return nil
	}

	// value enum
	if err := m.validateAfmModeEnum("afmMode", "body", m.AfmMode); err != nil {
		return err
	}

	return nil
}

func (m *FilesetCreate) validateFilesetName(formats strfmt.Registry) error {

	if err := validate.Required("filesetName", "body", m.FilesetName); err != nil {
		return err
	}

	return nil
}

var filesetCreateTypeIamModePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["compliant","noncompliant","advisory"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		filesetCreateTypeIamModePropEnum = append(filesetCreateTypeIamModePropEnum, v)
	}
}

const (

	// FilesetCreateIamModeCompliant captures enum value "compliant"
	FilesetCreateIamModeCompliant string = "compliant"

	// FilesetCreateIamModeNoncompliant captures enum value "noncompliant"
	FilesetCreateIamModeNoncompliant string = "noncompliant"

	// FilesetCreateIamModeAdvisory captures enum value "advisory"
	FilesetCreateIamModeAdvisory string = "advisory"
)

// prop value enum
func (m *FilesetCreate) validateIamModeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, filesetCreateTypeIamModePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *FilesetCreate) validateIamMode(formats strfmt.Registry) error {

	if swag.IsZero(m.IamMode) { // not required
		return nil
	}

	// value enum
	if err := m.validateIamModeEnum("iamMode", "body", m.IamMode); err != nil {
		return err
	}

	return nil
}

var filesetCreateTypePermissionChangeModePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["chmodOnly","setAclOnly","chmodAndSetAcl","chmodAndUpdateAcl"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		filesetCreateTypePermissionChangeModePropEnum = append(filesetCreateTypePermissionChangeModePropEnum, v)
	}
}

const (

	// FilesetCreatePermissionChangeModeChmodOnly captures enum value "chmodOnly"
	FilesetCreatePermissionChangeModeChmodOnly string = "chmodOnly"

	// FilesetCreatePermissionChangeModeSetACLOnly captures enum value "setAclOnly"
	FilesetCreatePermissionChangeModeSetACLOnly string = "setAclOnly"

	// FilesetCreatePermissionChangeModeChmodAndSetACL captures enum value "chmodAndSetAcl"
	FilesetCreatePermissionChangeModeChmodAndSetACL string = "chmodAndSetAcl"

	// FilesetCreatePermissionChangeModeChmodAndUpdateACL captures enum value "chmodAndUpdateAcl"
	FilesetCreatePermissionChangeModeChmodAndUpdateACL string = "chmodAndUpdateAcl"
)

// prop value enum
func (m *FilesetCreate) validatePermissionChangeModeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, filesetCreateTypePermissionChangeModePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *FilesetCreate) validatePermissionChangeMode(formats strfmt.Registry) error {

	if swag.IsZero(m.PermissionChangeMode) { // not required
		return nil
	}

	// value enum
	if err := m.validatePermissionChangeModeEnum("permissionChangeMode", "body", m.PermissionChangeMode); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FilesetCreate) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FilesetCreate) UnmarshalBinary(b []byte) error {
	var res FilesetCreate
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
