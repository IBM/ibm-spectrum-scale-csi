// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// PlanPackage plan package
//
// swagger:model PlanPackage
type PlanPackage struct {

	// affected plans
	AffectedPlans map[string][]PlanIdentifierTuple `json:"affectedPlans,omitempty"`

	// api description
	APIDescription string `json:"apiDescription,omitempty"`

	// api endpoint
	APIEndpoint string `json:"apiEndpoint,omitempty"`

	// api Id
	APIID string `json:"apiId,omitempty"`

	// api name
	APIName string `json:"apiName,omitempty"`

	// api version
	APIVersion string `json:"apiVersion,omitempty"`

	// created at
	// Format: date-time
	CreatedAt strfmt.DateTime `json:"createdAt,omitempty"`

	// created by
	CreatedBy string `json:"createdBy,omitempty"`

	// dependents
	Dependents map[string][]PlanPackage `json:"dependents,omitempty"`

	// deployment package Id
	DeploymentPackageID string `json:"deploymentPackageId,omitempty"`

	// deployment state
	// Enum: [TRANSIENT_REMOVED STOPPED RUNNING SUSPENDED ARCHIVED RETIRED DEPRECATED PUBLISHED DEPLOYED PENDING]
	DeploymentState string `json:"deploymentState,omitempty"`

	// deployment visibility
	DeploymentVisibility *DeploymentVisibility `json:"deploymentVisibility,omitempty"`

	// document
	Document *ConfigDataObject `json:"document,omitempty"`

	// document Id
	DocumentID string `json:"documentId,omitempty"`

	// document type
	// Enum: [POLICYTYPE PRODUCTVERSION PLANVERSION APIRESOURCE APIVERSION]
	DocumentType string `json:"documentType,omitempty"`

	// document version
	DocumentVersion int32 `json:"documentVersion,omitempty"`

	// env Id
	EnvID string `json:"envId,omitempty"`

	// id
	ID string `json:"id,omitempty"`

	// operation status summary
	OperationStatusSummary *OperationStatusSummary `json:"operationStatusSummary,omitempty"`

	// org Id
	OrgID string `json:"orgId,omitempty"`

	// pending deployment state
	// Enum: [REMOVE ARCHIVE RETIRE DEPRECATE SUPERSEDE REPLACE UPDATE PUBLISH RESTAGE STAGE_FROM_DRAFT]
	PendingDeploymentState string `json:"pendingDeploymentState,omitempty"`

	// plan description
	PlanDescription string `json:"planDescription,omitempty"`

	// plan display name
	PlanDisplayName string `json:"planDisplayName,omitempty"`

	// plan Id
	PlanID string `json:"planId,omitempty"`

	// plan name
	PlanName string `json:"planName,omitempty"`

	// plan registrations
	PlanRegistrations int64 `json:"planRegistrations,omitempty"`

	// plan requires approval
	PlanRequiresApproval bool `json:"planRequiresApproval,omitempty"`

	// plan version
	PlanVersion int32 `json:"planVersion,omitempty"`

	// product name
	ProductName string `json:"productName,omitempty"`

	// product version
	ProductVersion string `json:"productVersion,omitempty"`

	// product visibility metadata
	ProductVisibilityMetadata *ProductPackageUpdateJSONBody `json:"productVisibilityMetadata,omitempty"`

	// superseded by
	SupersededBy *PlanIdentifierTuple `json:"supersededBy,omitempty"`

	// supersedes
	Supersedes *PlanIdentifierTuple `json:"supersedes,omitempty"`

	// task
	Task *TaskListGetResponse `json:"task,omitempty"`

	// task Id
	TaskID string `json:"taskId,omitempty"`

	// updated at
	// Format: date-time
	UpdatedAt strfmt.DateTime `json:"updatedAt,omitempty"`

	// updated by
	UpdatedBy string `json:"updatedBy,omitempty"`

	// url
	URL string `json:"url,omitempty"`

	// vendor extensions
	VendorExtensions map[string]interface{} `json:"vendorExtensions,omitempty"`
}

// Validate validates this plan package
func (m *PlanPackage) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAffectedPlans(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreatedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDependents(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDeploymentState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDeploymentVisibility(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDocument(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDocumentType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOperationStatusSummary(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePendingDeploymentState(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProductVisibilityMetadata(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSupersededBy(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSupersedes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTask(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpdatedAt(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *PlanPackage) validateAffectedPlans(formats strfmt.Registry) error {

	if swag.IsZero(m.AffectedPlans) { // not required
		return nil
	}

	for k := range m.AffectedPlans {

		if err := validate.Required("affectedPlans"+"."+k, "body", m.AffectedPlans[k]); err != nil {
			return err
		}

		for i := 0; i < len(m.AffectedPlans[k]); i++ {

			if err := m.AffectedPlans[k][i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("affectedPlans" + "." + k + "." + strconv.Itoa(i))
				}
				return err
			}

		}

	}

	return nil
}

func (m *PlanPackage) validateCreatedAt(formats strfmt.Registry) error {

	if swag.IsZero(m.CreatedAt) { // not required
		return nil
	}

	if err := validate.FormatOf("createdAt", "body", "date-time", m.CreatedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *PlanPackage) validateDependents(formats strfmt.Registry) error {

	if swag.IsZero(m.Dependents) { // not required
		return nil
	}

	for k := range m.Dependents {

		if err := validate.Required("dependents"+"."+k, "body", m.Dependents[k]); err != nil {
			return err
		}

		for i := 0; i < len(m.Dependents[k]); i++ {

			if err := m.Dependents[k][i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("dependents" + "." + k + "." + strconv.Itoa(i))
				}
				return err
			}

		}

	}

	return nil
}

var planPackageTypeDeploymentStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["TRANSIENT_REMOVED","STOPPED","RUNNING","SUSPENDED","ARCHIVED","RETIRED","DEPRECATED","PUBLISHED","DEPLOYED","PENDING"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		planPackageTypeDeploymentStatePropEnum = append(planPackageTypeDeploymentStatePropEnum, v)
	}
}

const (

	// PlanPackageDeploymentStateTRANSIENTREMOVED captures enum value "TRANSIENT_REMOVED"
	PlanPackageDeploymentStateTRANSIENTREMOVED string = "TRANSIENT_REMOVED"

	// PlanPackageDeploymentStateSTOPPED captures enum value "STOPPED"
	PlanPackageDeploymentStateSTOPPED string = "STOPPED"

	// PlanPackageDeploymentStateRUNNING captures enum value "RUNNING"
	PlanPackageDeploymentStateRUNNING string = "RUNNING"

	// PlanPackageDeploymentStateSUSPENDED captures enum value "SUSPENDED"
	PlanPackageDeploymentStateSUSPENDED string = "SUSPENDED"

	// PlanPackageDeploymentStateARCHIVED captures enum value "ARCHIVED"
	PlanPackageDeploymentStateARCHIVED string = "ARCHIVED"

	// PlanPackageDeploymentStateRETIRED captures enum value "RETIRED"
	PlanPackageDeploymentStateRETIRED string = "RETIRED"

	// PlanPackageDeploymentStateDEPRECATED captures enum value "DEPRECATED"
	PlanPackageDeploymentStateDEPRECATED string = "DEPRECATED"

	// PlanPackageDeploymentStatePUBLISHED captures enum value "PUBLISHED"
	PlanPackageDeploymentStatePUBLISHED string = "PUBLISHED"

	// PlanPackageDeploymentStateDEPLOYED captures enum value "DEPLOYED"
	PlanPackageDeploymentStateDEPLOYED string = "DEPLOYED"

	// PlanPackageDeploymentStatePENDING captures enum value "PENDING"
	PlanPackageDeploymentStatePENDING string = "PENDING"
)

// prop value enum
func (m *PlanPackage) validateDeploymentStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, planPackageTypeDeploymentStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *PlanPackage) validateDeploymentState(formats strfmt.Registry) error {

	if swag.IsZero(m.DeploymentState) { // not required
		return nil
	}

	// value enum
	if err := m.validateDeploymentStateEnum("deploymentState", "body", m.DeploymentState); err != nil {
		return err
	}

	return nil
}

func (m *PlanPackage) validateDeploymentVisibility(formats strfmt.Registry) error {

	if swag.IsZero(m.DeploymentVisibility) { // not required
		return nil
	}

	if m.DeploymentVisibility != nil {
		if err := m.DeploymentVisibility.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("deploymentVisibility")
			}
			return err
		}
	}

	return nil
}

func (m *PlanPackage) validateDocument(formats strfmt.Registry) error {

	if swag.IsZero(m.Document) { // not required
		return nil
	}

	if m.Document != nil {
		if err := m.Document.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("document")
			}
			return err
		}
	}

	return nil
}

var planPackageTypeDocumentTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["POLICYTYPE","PRODUCTVERSION","PLANVERSION","APIRESOURCE","APIVERSION"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		planPackageTypeDocumentTypePropEnum = append(planPackageTypeDocumentTypePropEnum, v)
	}
}

const (

	// PlanPackageDocumentTypePOLICYTYPE captures enum value "POLICYTYPE"
	PlanPackageDocumentTypePOLICYTYPE string = "POLICYTYPE"

	// PlanPackageDocumentTypePRODUCTVERSION captures enum value "PRODUCTVERSION"
	PlanPackageDocumentTypePRODUCTVERSION string = "PRODUCTVERSION"

	// PlanPackageDocumentTypePLANVERSION captures enum value "PLANVERSION"
	PlanPackageDocumentTypePLANVERSION string = "PLANVERSION"

	// PlanPackageDocumentTypeAPIRESOURCE captures enum value "APIRESOURCE"
	PlanPackageDocumentTypeAPIRESOURCE string = "APIRESOURCE"

	// PlanPackageDocumentTypeAPIVERSION captures enum value "APIVERSION"
	PlanPackageDocumentTypeAPIVERSION string = "APIVERSION"
)

// prop value enum
func (m *PlanPackage) validateDocumentTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, planPackageTypeDocumentTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *PlanPackage) validateDocumentType(formats strfmt.Registry) error {

	if swag.IsZero(m.DocumentType) { // not required
		return nil
	}

	// value enum
	if err := m.validateDocumentTypeEnum("documentType", "body", m.DocumentType); err != nil {
		return err
	}

	return nil
}

func (m *PlanPackage) validateOperationStatusSummary(formats strfmt.Registry) error {

	if swag.IsZero(m.OperationStatusSummary) { // not required
		return nil
	}

	if m.OperationStatusSummary != nil {
		if err := m.OperationStatusSummary.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("operationStatusSummary")
			}
			return err
		}
	}

	return nil
}

var planPackageTypePendingDeploymentStatePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["REMOVE","ARCHIVE","RETIRE","DEPRECATE","SUPERSEDE","REPLACE","UPDATE","PUBLISH","RESTAGE","STAGE_FROM_DRAFT"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		planPackageTypePendingDeploymentStatePropEnum = append(planPackageTypePendingDeploymentStatePropEnum, v)
	}
}

const (

	// PlanPackagePendingDeploymentStateREMOVE captures enum value "REMOVE"
	PlanPackagePendingDeploymentStateREMOVE string = "REMOVE"

	// PlanPackagePendingDeploymentStateARCHIVE captures enum value "ARCHIVE"
	PlanPackagePendingDeploymentStateARCHIVE string = "ARCHIVE"

	// PlanPackagePendingDeploymentStateRETIRE captures enum value "RETIRE"
	PlanPackagePendingDeploymentStateRETIRE string = "RETIRE"

	// PlanPackagePendingDeploymentStateDEPRECATE captures enum value "DEPRECATE"
	PlanPackagePendingDeploymentStateDEPRECATE string = "DEPRECATE"

	// PlanPackagePendingDeploymentStateSUPERSEDE captures enum value "SUPERSEDE"
	PlanPackagePendingDeploymentStateSUPERSEDE string = "SUPERSEDE"

	// PlanPackagePendingDeploymentStateREPLACE captures enum value "REPLACE"
	PlanPackagePendingDeploymentStateREPLACE string = "REPLACE"

	// PlanPackagePendingDeploymentStateUPDATE captures enum value "UPDATE"
	PlanPackagePendingDeploymentStateUPDATE string = "UPDATE"

	// PlanPackagePendingDeploymentStatePUBLISH captures enum value "PUBLISH"
	PlanPackagePendingDeploymentStatePUBLISH string = "PUBLISH"

	// PlanPackagePendingDeploymentStateRESTAGE captures enum value "RESTAGE"
	PlanPackagePendingDeploymentStateRESTAGE string = "RESTAGE"

	// PlanPackagePendingDeploymentStateSTAGEFROMDRAFT captures enum value "STAGE_FROM_DRAFT"
	PlanPackagePendingDeploymentStateSTAGEFROMDRAFT string = "STAGE_FROM_DRAFT"
)

// prop value enum
func (m *PlanPackage) validatePendingDeploymentStateEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, planPackageTypePendingDeploymentStatePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *PlanPackage) validatePendingDeploymentState(formats strfmt.Registry) error {

	if swag.IsZero(m.PendingDeploymentState) { // not required
		return nil
	}

	// value enum
	if err := m.validatePendingDeploymentStateEnum("pendingDeploymentState", "body", m.PendingDeploymentState); err != nil {
		return err
	}

	return nil
}

func (m *PlanPackage) validateProductVisibilityMetadata(formats strfmt.Registry) error {

	if swag.IsZero(m.ProductVisibilityMetadata) { // not required
		return nil
	}

	if m.ProductVisibilityMetadata != nil {
		if err := m.ProductVisibilityMetadata.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("productVisibilityMetadata")
			}
			return err
		}
	}

	return nil
}

func (m *PlanPackage) validateSupersededBy(formats strfmt.Registry) error {

	if swag.IsZero(m.SupersededBy) { // not required
		return nil
	}

	if m.SupersededBy != nil {
		if err := m.SupersededBy.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("supersededBy")
			}
			return err
		}
	}

	return nil
}

func (m *PlanPackage) validateSupersedes(formats strfmt.Registry) error {

	if swag.IsZero(m.Supersedes) { // not required
		return nil
	}

	if m.Supersedes != nil {
		if err := m.Supersedes.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("supersedes")
			}
			return err
		}
	}

	return nil
}

func (m *PlanPackage) validateTask(formats strfmt.Registry) error {

	if swag.IsZero(m.Task) { // not required
		return nil
	}

	if m.Task != nil {
		if err := m.Task.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("task")
			}
			return err
		}
	}

	return nil
}

func (m *PlanPackage) validateUpdatedAt(formats strfmt.Registry) error {

	if swag.IsZero(m.UpdatedAt) { // not required
		return nil
	}

	if err := validate.FormatOf("updatedAt", "body", "date-time", m.UpdatedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *PlanPackage) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *PlanPackage) UnmarshalBinary(b []byte) error {
	var res PlanPackage
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
