// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// NfsClient Summary information about a NfsClient
//
// swagger:model NfsClient
type NfsClient struct {

	// Specifies the type of the access for the client.
	// Enum: [none RO RW MDONLY MDONLY_RO]
	AccessType string `json:"access_type,omitempty"`

	// This option explicitly set the gid of the anonymous account.
	AnonGid string `json:"anonGid,omitempty"`

	// This option explicitly set the uid of the anonymous account.
	AnonUID string `json:"anonUid,omitempty"`

	// The hostname or IP address of the nfs server to be accessed.
	ClientName string `json:"clientName,omitempty"`

	// This option specifies what delegate file operations to the accessing to the client.
	// Enum: [none read write readwrite]
	Delegations string `json:"delegations,omitempty"`

	// The internal unique id of the export.
	Exportid string `json:"exportid,omitempty"`

	// This option specifies this nfs client allow to manage gids or not.
	ManageGids bool `json:"manageGids,omitempty"`

	// A free text description of the export.
	NfsCommit bool `json:"nfsCommit,omitempty"`

	// This option to specify is a client using an ephemeral port should be rejecting or not.
	PrivilegedPort bool `json:"privilegedPort,omitempty"`

	// This option tells the NFSv4 server what protocol version to support.
	// Enum: [3 4 NFS3 NFS4 V3 V4 NFSv3 NFSv4]
	Protocols string `json:"protocols,omitempty"`

	// The supported authentication flavors for this client.
	// Enum: [sys krb5 krb5i krb5p None]
	Sectype string `json:"sectype,omitempty"`

	// Specifies the squashing mechanism that will by applied to the connecting client.
	// Enum: [Root Root_Squash RootSquash All All_Squash AllSquash No_Root_Squash NoIdSquash None]
	Squash string `json:"squash,omitempty"`

	// This option specifies the transport layer.
	// Enum: [TCP UDP]
	TransportProtocol string `json:"transportProtocol,omitempty"`
}

// Validate validates this nfs client
func (m *NfsClient) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAccessType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDelegations(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateProtocols(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSectype(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSquash(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTransportProtocol(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var nfsClientTypeAccessTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["none","RO","RW","MDONLY","MDONLY_RO"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nfsClientTypeAccessTypePropEnum = append(nfsClientTypeAccessTypePropEnum, v)
	}
}

const (

	// NfsClientAccessTypeNone captures enum value "none"
	NfsClientAccessTypeNone string = "none"

	// NfsClientAccessTypeRO captures enum value "RO"
	NfsClientAccessTypeRO string = "RO"

	// NfsClientAccessTypeRW captures enum value "RW"
	NfsClientAccessTypeRW string = "RW"

	// NfsClientAccessTypeMDONLY captures enum value "MDONLY"
	NfsClientAccessTypeMDONLY string = "MDONLY"

	// NfsClientAccessTypeMDONLYRO captures enum value "MDONLY_RO"
	NfsClientAccessTypeMDONLYRO string = "MDONLY_RO"
)

// prop value enum
func (m *NfsClient) validateAccessTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nfsClientTypeAccessTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NfsClient) validateAccessType(formats strfmt.Registry) error {

	if swag.IsZero(m.AccessType) { // not required
		return nil
	}

	// value enum
	if err := m.validateAccessTypeEnum("access_type", "body", m.AccessType); err != nil {
		return err
	}

	return nil
}

var nfsClientTypeDelegationsPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["none","read","write","readwrite"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nfsClientTypeDelegationsPropEnum = append(nfsClientTypeDelegationsPropEnum, v)
	}
}

const (

	// NfsClientDelegationsNone captures enum value "none"
	NfsClientDelegationsNone string = "none"

	// NfsClientDelegationsRead captures enum value "read"
	NfsClientDelegationsRead string = "read"

	// NfsClientDelegationsWrite captures enum value "write"
	NfsClientDelegationsWrite string = "write"

	// NfsClientDelegationsReadwrite captures enum value "readwrite"
	NfsClientDelegationsReadwrite string = "readwrite"
)

// prop value enum
func (m *NfsClient) validateDelegationsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nfsClientTypeDelegationsPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NfsClient) validateDelegations(formats strfmt.Registry) error {

	if swag.IsZero(m.Delegations) { // not required
		return nil
	}

	// value enum
	if err := m.validateDelegationsEnum("delegations", "body", m.Delegations); err != nil {
		return err
	}

	return nil
}

var nfsClientTypeProtocolsPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["3","4","NFS3","NFS4","V3","V4","NFSv3","NFSv4"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nfsClientTypeProtocolsPropEnum = append(nfsClientTypeProtocolsPropEnum, v)
	}
}

const (

	// NfsClientProtocolsNr3 captures enum value "3"
	NfsClientProtocolsNr3 string = "3"

	// NfsClientProtocolsNr4 captures enum value "4"
	NfsClientProtocolsNr4 string = "4"

	// NfsClientProtocolsNFS3 captures enum value "NFS3"
	NfsClientProtocolsNFS3 string = "NFS3"

	// NfsClientProtocolsNFS4 captures enum value "NFS4"
	NfsClientProtocolsNFS4 string = "NFS4"

	// NfsClientProtocolsV3 captures enum value "V3"
	NfsClientProtocolsV3 string = "V3"

	// NfsClientProtocolsV4 captures enum value "V4"
	NfsClientProtocolsV4 string = "V4"

	// NfsClientProtocolsNFSv3 captures enum value "NFSv3"
	NfsClientProtocolsNFSv3 string = "NFSv3"

	// NfsClientProtocolsNFSv4 captures enum value "NFSv4"
	NfsClientProtocolsNFSv4 string = "NFSv4"
)

// prop value enum
func (m *NfsClient) validateProtocolsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nfsClientTypeProtocolsPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NfsClient) validateProtocols(formats strfmt.Registry) error {

	if swag.IsZero(m.Protocols) { // not required
		return nil
	}

	// value enum
	if err := m.validateProtocolsEnum("protocols", "body", m.Protocols); err != nil {
		return err
	}

	return nil
}

var nfsClientTypeSectypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["sys","krb5","krb5i","krb5p","None"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nfsClientTypeSectypePropEnum = append(nfsClientTypeSectypePropEnum, v)
	}
}

const (

	// NfsClientSectypeSys captures enum value "sys"
	NfsClientSectypeSys string = "sys"

	// NfsClientSectypeKrb5 captures enum value "krb5"
	NfsClientSectypeKrb5 string = "krb5"

	// NfsClientSectypeKrb5i captures enum value "krb5i"
	NfsClientSectypeKrb5i string = "krb5i"

	// NfsClientSectypeKrb5p captures enum value "krb5p"
	NfsClientSectypeKrb5p string = "krb5p"

	// NfsClientSectypeNone captures enum value "None"
	NfsClientSectypeNone string = "None"
)

// prop value enum
func (m *NfsClient) validateSectypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nfsClientTypeSectypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NfsClient) validateSectype(formats strfmt.Registry) error {

	if swag.IsZero(m.Sectype) { // not required
		return nil
	}

	// value enum
	if err := m.validateSectypeEnum("sectype", "body", m.Sectype); err != nil {
		return err
	}

	return nil
}

var nfsClientTypeSquashPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["Root","Root_Squash","RootSquash","All","All_Squash","AllSquash","No_Root_Squash","NoIdSquash","None"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nfsClientTypeSquashPropEnum = append(nfsClientTypeSquashPropEnum, v)
	}
}

const (

	// NfsClientSquashRoot captures enum value "Root"
	NfsClientSquashRoot string = "Root"

	// NfsClientSquashRootSquash captures enum value "Root_Squash"
	NfsClientSquashRootSquash string = "Root_Squash"

	// NfsClientSquashRootSquash captures enum value "RootSquash"
	NfsClientSquashRootSquash string = "RootSquash"

	// NfsClientSquashAll captures enum value "All"
	NfsClientSquashAll string = "All"

	// NfsClientSquashAllSquash captures enum value "All_Squash"
	NfsClientSquashAllSquash string = "All_Squash"

	// NfsClientSquashAllSquash captures enum value "AllSquash"
	NfsClientSquashAllSquash string = "AllSquash"

	// NfsClientSquashNoRootSquash captures enum value "No_Root_Squash"
	NfsClientSquashNoRootSquash string = "No_Root_Squash"

	// NfsClientSquashNoIDSquash captures enum value "NoIdSquash"
	NfsClientSquashNoIDSquash string = "NoIdSquash"

	// NfsClientSquashNone captures enum value "None"
	NfsClientSquashNone string = "None"
)

// prop value enum
func (m *NfsClient) validateSquashEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nfsClientTypeSquashPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NfsClient) validateSquash(formats strfmt.Registry) error {

	if swag.IsZero(m.Squash) { // not required
		return nil
	}

	// value enum
	if err := m.validateSquashEnum("squash", "body", m.Squash); err != nil {
		return err
	}

	return nil
}

var nfsClientTypeTransportProtocolPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["TCP","UDP"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		nfsClientTypeTransportProtocolPropEnum = append(nfsClientTypeTransportProtocolPropEnum, v)
	}
}

const (

	// NfsClientTransportProtocolTCP captures enum value "TCP"
	NfsClientTransportProtocolTCP string = "TCP"

	// NfsClientTransportProtocolUDP captures enum value "UDP"
	NfsClientTransportProtocolUDP string = "UDP"
)

// prop value enum
func (m *NfsClient) validateTransportProtocolEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, nfsClientTypeTransportProtocolPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *NfsClient) validateTransportProtocol(formats strfmt.Registry) error {

	if swag.IsZero(m.TransportProtocol) { // not required
		return nil
	}

	// value enum
	if err := m.validateTransportProtocolEnum("transportProtocol", "body", m.TransportProtocol); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *NfsClient) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NfsClient) UnmarshalBinary(b []byte) error {
	var res NfsClient
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
