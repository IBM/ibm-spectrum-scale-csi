// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// FilesetChange Object that can be used to update an existing fileset
//
// swagger:model FilesetChange
type FilesetChange struct {

	// Specifies (in seconds) the amount of time by which write operations are delayed
	AfmAsyncDelay int32 `json:"afmAsyncDelay,omitempty"`

	// Controls the frequency of data revalidations that are triggered by such lookup operations as ls or stat (specified in seconds)
	AfmDirLookupRefreshInterval int32 `json:"afmDirLookupRefreshInterval,omitempty"`

	// Controls the frequency of data revalidations that are triggered by such I/O operations as read or write (specified in seconds)
	AfmDirOpenRefreshInterval int32 `json:"afmDirOpenRefreshInterval,omitempty"`

	// Specifies if eviction is enabled
	AfmEnableAutoEviction bool `json:"afmEnableAutoEviction,omitempty"`

	// Is used with afmDisconnectTimeout (which can be set only through mmchconfig) to control how long a network outage between the cache and home clusters can continue before the data in the cache is considered out of sync with home.
	AfmExpirationTimeout int32 `json:"afmExpirationTimeout,omitempty"`

	// Controls the frequency of data revalidations that are triggered by such lookup operations as ls or stat (specified in seconds)
	AfmFileLookupRefreshInterval int32 `json:"afmFileLookupRefreshInterval,omitempty"`

	// Specifies the mode in which the cache operates
	// Enum: [single-writer read-only local-updates independent-writer Primary Secondary]
	AfmMode string `json:"afmMode,omitempty"`

	// Defines the number of threads used on each gateway to synchronize updates to the home cluster
	AfmNumFlushThreads int32 `json:"afmNumFlushThreads,omitempty"`

	// Use Google Cloud Services, for Google GCS
	AfmObjectGCS bool `json:"afmObjectGCS,omitempty"`

	// Enable SSL certificate verification, valid only with https from object store
	AfmObjectSSL bool `json:"afmObjectSSL,omitempty"`

	// Create sub-directory if '/' in object name
	AfmObjectSubdir bool `json:"afmObjectSubdir,omitempty"`

	// Use user keys on requests from object store
	AfmObjectUserKeys bool `json:"afmObjectUserKeys,omitempty"`

	// Use Virtual Hosted Bucket, for Alibaba OSS
	AfmObjectVHB bool `json:"afmObjectVHB,omitempty"`

	// Get/set user extended attributes in object store
	AfmObjectXattr bool `json:"afmObjectXattr,omitempty"`

	// Defines the minimum chunk size of the read that needs to be distributed among the gateway nodes during parallel reads
	AfmParallelReadChunkSize int32 `json:"afmParallelReadChunkSize,omitempty"`

	// Defines the threshold beyond which parallel reads become effective
	AfmParallelReadThreshold int32 `json:"afmParallelReadThreshold,omitempty"`

	// Defines the minimum chunk size of the write that needs to be distributed among the gateway nodes during parallel writes
	AfmParallelWriteChunkSize int32 `json:"afmParallelWriteChunkSize,omitempty"`

	// Defines the threshold beyond which parallel writes become effective
	AfmParallelWriteThreshold int32 `json:"afmParallelWriteThreshold,omitempty"`

	// Controls partial file caching and prefetching
	AfmPrefetchThreshold int32 `json:"afmPrefetchThreshold,omitempty"`

	// Specifies the unique primary ID of the primary fileset for asynchronous data replication
	AfmPrimaryID string `json:"afmPrimaryID,omitempty"`

	// Specifies the recovery point objective (RPO) interval in minutes for a primary fileset
	AfmRPO int32 `json:"afmRPO,omitempty"`

	// Controls the visibility of the home snapshot directory in cache
	AfmShowHomeSnapshots bool `json:"afmShowHomeSnapshots,omitempty"`

	// Identifies the home that is associated with the cache
	AfmTarget string `json:"afmTarget,omitempty"`

	// Specifies the new number of pre-allocated inodes for this fileset
	AllocInodes string `json:"allocInodes,omitempty"`

	// The new comment for this fileset
	Comment string `json:"comment,omitempty"`

	// Specifies the integrated archive manager (IAM) mode for the fileset.
	// Enum: [compliant noncompliant advisory]
	IamMode string `json:"iamMode,omitempty"`

	// Specifies the new maximum number of inodes allowed for this fileset
	MaxNumInodes string `json:"maxNumInodes,omitempty"`

	// The new name of the fileset that is changed
	NewFilesetName string `json:"newFilesetName,omitempty"`

	// Specifies the permission change mode.
	// Enum: [chmodOnly setAclOnly chmodAndSetAcl chmodAndUpdateAcl]
	PermissionChangeMode string `json:"permissionChangeMode,omitempty"`
}

// Validate validates this fileset change
func (m *FilesetChange) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAfmMode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIamMode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePermissionChangeMode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var filesetChangeTypeAfmModePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["single-writer","read-only","local-updates","independent-writer","Primary","Secondary"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		filesetChangeTypeAfmModePropEnum = append(filesetChangeTypeAfmModePropEnum, v)
	}
}

const (

	// FilesetChangeAfmModeSingleWriter captures enum value "single-writer"
	FilesetChangeAfmModeSingleWriter string = "single-writer"

	// FilesetChangeAfmModeReadOnly captures enum value "read-only"
	FilesetChangeAfmModeReadOnly string = "read-only"

	// FilesetChangeAfmModeLocalUpdates captures enum value "local-updates"
	FilesetChangeAfmModeLocalUpdates string = "local-updates"

	// FilesetChangeAfmModeIndependentWriter captures enum value "independent-writer"
	FilesetChangeAfmModeIndependentWriter string = "independent-writer"

	// FilesetChangeAfmModePrimary captures enum value "Primary"
	FilesetChangeAfmModePrimary string = "Primary"

	// FilesetChangeAfmModeSecondary captures enum value "Secondary"
	FilesetChangeAfmModeSecondary string = "Secondary"
)

// prop value enum
func (m *FilesetChange) validateAfmModeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, filesetChangeTypeAfmModePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *FilesetChange) validateAfmMode(formats strfmt.Registry) error {

	if swag.IsZero(m.AfmMode) { // not required
		return nil
	}

	// value enum
	if err := m.validateAfmModeEnum("afmMode", "body", m.AfmMode); err != nil {
		return err
	}

	return nil
}

var filesetChangeTypeIamModePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["compliant","noncompliant","advisory"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		filesetChangeTypeIamModePropEnum = append(filesetChangeTypeIamModePropEnum, v)
	}
}

const (

	// FilesetChangeIamModeCompliant captures enum value "compliant"
	FilesetChangeIamModeCompliant string = "compliant"

	// FilesetChangeIamModeNoncompliant captures enum value "noncompliant"
	FilesetChangeIamModeNoncompliant string = "noncompliant"

	// FilesetChangeIamModeAdvisory captures enum value "advisory"
	FilesetChangeIamModeAdvisory string = "advisory"
)

// prop value enum
func (m *FilesetChange) validateIamModeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, filesetChangeTypeIamModePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *FilesetChange) validateIamMode(formats strfmt.Registry) error {

	if swag.IsZero(m.IamMode) { // not required
		return nil
	}

	// value enum
	if err := m.validateIamModeEnum("iamMode", "body", m.IamMode); err != nil {
		return err
	}

	return nil
}

var filesetChangeTypePermissionChangeModePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["chmodOnly","setAclOnly","chmodAndSetAcl","chmodAndUpdateAcl"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		filesetChangeTypePermissionChangeModePropEnum = append(filesetChangeTypePermissionChangeModePropEnum, v)
	}
}

const (

	// FilesetChangePermissionChangeModeChmodOnly captures enum value "chmodOnly"
	FilesetChangePermissionChangeModeChmodOnly string = "chmodOnly"

	// FilesetChangePermissionChangeModeSetACLOnly captures enum value "setAclOnly"
	FilesetChangePermissionChangeModeSetACLOnly string = "setAclOnly"

	// FilesetChangePermissionChangeModeChmodAndSetACL captures enum value "chmodAndSetAcl"
	FilesetChangePermissionChangeModeChmodAndSetACL string = "chmodAndSetAcl"

	// FilesetChangePermissionChangeModeChmodAndUpdateACL captures enum value "chmodAndUpdateAcl"
	FilesetChangePermissionChangeModeChmodAndUpdateACL string = "chmodAndUpdateAcl"
)

// prop value enum
func (m *FilesetChange) validatePermissionChangeModeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, filesetChangeTypePermissionChangeModePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *FilesetChange) validatePermissionChangeMode(formats strfmt.Registry) error {

	if swag.IsZero(m.PermissionChangeMode) { // not required
		return nil
	}

	// value enum
	if err := m.validatePermissionChangeModeEnum("permissionChangeMode", "body", m.PermissionChangeMode); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FilesetChange) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FilesetChange) UnmarshalBinary(b []byte) error {
	var res FilesetChange
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
