// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// FilesetAfm Fileset AFM details
//
// swagger:model FilesetAfm
type FilesetAfm struct {

	// afm associated primary Id
	AfmAssociatedPrimaryID string `json:"afmAssociatedPrimaryId,omitempty"`

	// Specifies (in seconds) the amount of time by which write operations are delayed
	AfmAsyncDelay int32 `json:"afmAsyncDelay,omitempty"`

	// afm d i o
	AfmDIO int32 `json:"afmDIO,omitempty"`

	// afm d r state
	AfmDRState string `json:"afmDRState,omitempty"`

	// Controls the frequency of data revalidations that are triggered by such lookup operations as ls or stat (specified in seconds)
	AfmDirLookupRefreshInterval int32 `json:"afmDirLookupRefreshInterval,omitempty"`

	// Controls the frequency of data revalidations that are triggered by such I/O operations as read or write (specified in seconds)
	AfmDirOpenRefreshInterval int32 `json:"afmDirOpenRefreshInterval,omitempty"`

	// Specifies if eviction is enabled
	AfmEnableAutoEviction bool `json:"afmEnableAutoEviction,omitempty"`

	// Is used with afmDisconnectTimeout (which can be set only through mmchconfig) to control how long a network outage between the cache and home clusters can continue before the data in the cache is considered out of sync with home.
	AfmExpirationTimeout int32 `json:"afmExpirationTimeout,omitempty"`

	// afm fast create
	AfmFastCreate bool `json:"afmFastCreate,omitempty"`

	// Controls the frequency of data revalidations that are triggered by such lookup operations as ls or stat (specified in seconds)
	AfmFileLookupRefreshInterval int32 `json:"afmFileLookupRefreshInterval,omitempty"`

	// afm file open refresh interval
	AfmFileOpenRefreshInterval int32 `json:"afmFileOpenRefreshInterval,omitempty"`

	// afm force ctime change
	AfmForceCtimeChange bool `json:"afmForceCtimeChange,omitempty"`

	// Gateway node
	AfmGatewayNode string `json:"afmGatewayNode,omitempty"`

	// The name of the AFM host map this fileset belongs to
	AfmHostMapName string `json:"afmHostMapName,omitempty"`

	// afm host mapping
	AfmHostMapping []*FilesetAfmHostMapping `json:"afmHostMapping"`

	// afm host maps
	AfmHostMaps []*FilesetAfmHostMapping `json:"afmHostMaps"`

	// AFM IO flags
	AfmIOFlags string `json:"afmIOFlags,omitempty"`

	// afm last p snap Id
	AfmLastPSnapID int32 `json:"afmLastPSnapId,omitempty"`

	// Specifies the mode in which the cache operates
	// Enum: [single-writer read-only local-updates independent-writer Primary Secondary]
	AfmMode string `json:"afmMode,omitempty"`

	// afm needs recovery
	AfmNeedsRecovery bool `json:"afmNeedsRecovery,omitempty"`

	// afm needs resync
	AfmNeedsResync bool `json:"afmNeedsResync,omitempty"`

	// Defines the number of threads used on each gateway to synchronize updates to the home cluster
	AfmNumFlushThreads int32 `json:"afmNumFlushThreads,omitempty"`

	// afm num read threads
	AfmNumReadThreads int32 `json:"afmNumReadThreads,omitempty"`

	// Defines the number of threads used on each participating gateway node during a parallel write
	AfmNumWriteThreads int32 `json:"afmNumWriteThreads,omitempty"`

	// afm object blk i o
	AfmObjectBlkIO bool `json:"afmObjectBlkIO,omitempty"`

	// Use Google Cloud Services, for Google GCS
	AfmObjectGCS bool `json:"afmObjectGCS,omitempty"`

	// Enable SSL certificate verification, valid only with https from object store
	AfmObjectSSL bool `json:"afmObjectSSL,omitempty"`

	// Create sub-directory if '/' in object name
	AfmObjectSubdir bool `json:"afmObjectSubdir,omitempty"`

	// Use user keys on requests from object store
	AfmObjectUserKeys bool `json:"afmObjectUserKeys,omitempty"`

	// Use Virtual Hosted Bucket, for Alibaba OSS
	AfmObjectVHB bool `json:"afmObjectVHB,omitempty"`

	// Get/set user extended attributes in object store
	AfmObjectXattr bool `json:"afmObjectXattr,omitempty"`

	// afm parallel mounts
	AfmParallelMounts bool `json:"afmParallelMounts,omitempty"`

	// Defines the minimum chunk size of the read that needs to be distributed among the gateway nodes during parallel reads
	AfmParallelReadChunkSize int32 `json:"afmParallelReadChunkSize,omitempty"`

	// Defines the threshold beyond which parallel reads become effective
	AfmParallelReadThreshold int32 `json:"afmParallelReadThreshold,omitempty"`

	// Defines the minimum chunk size of the write that needs to be distributed among the gateway nodes during parallel writes
	AfmParallelWriteChunkSize int32 `json:"afmParallelWriteChunkSize,omitempty"`

	// Defines the threshold beyond which parallel writes become effective
	AfmParallelWriteThreshold int32 `json:"afmParallelWriteThreshold,omitempty"`

	// Controls partial file caching and prefetching
	AfmPrefetchThreshold int32 `json:"afmPrefetchThreshold,omitempty"`

	// Specifies the unique primary ID of the primary fileset for asynchronous data replication
	AfmPrimaryID string `json:"afmPrimaryID,omitempty"`

	// Specifies the recovery point objective (RPO) interval in minutes for a primary fileset
	AfmRPO int32 `json:"afmRPO,omitempty"`

	// afm read buffer size
	AfmReadBufferSize int32 `json:"afmReadBufferSize,omitempty"`

	// afm read sparse threshold
	AfmReadSparseThreshold int32 `json:"afmReadSparseThreshold,omitempty"`

	// afm readdir once
	AfmReaddirOnce bool `json:"afmReaddirOnce,omitempty"`

	// afm refresh async
	AfmRefreshAsync bool `json:"afmRefreshAsync,omitempty"`

	// afm refresh once
	AfmRefreshOnce bool `json:"afmRefreshOnce,omitempty"`

	// afm resync ver2
	AfmResyncVer2 bool `json:"afmResyncVer2,omitempty"`

	// Controls the visibility of the home snapshot directory in cache
	AfmShowHomeSnapshots bool `json:"afmShowHomeSnapshots,omitempty"`

	// afm skip conflict q drop
	AfmSkipConflictQDrop bool `json:"afmSkipConflictQDrop,omitempty"`

	// afm skip home ACL
	AfmSkipHomeACL bool `json:"afmSkipHomeACL,omitempty"`

	// afm skip home ctime nsec
	AfmSkipHomeCtimeNsec bool `json:"afmSkipHomeCtimeNsec,omitempty"`

	// afm skip home mtime nsec
	AfmSkipHomeMtimeNsec bool `json:"afmSkipHomeMtimeNsec,omitempty"`

	// afm skip home refresh
	AfmSkipHomeRefresh bool `json:"afmSkipHomeRefresh,omitempty"`

	// afm skip resync recovery
	AfmSkipResyncRecovery bool `json:"afmSkipResyncRecovery,omitempty"`

	// afm snap uncached read
	AfmSnapUncachedRead bool `json:"afmSnapUncachedRead,omitempty"`

	// AFM state
	AfmState string `json:"afmState,omitempty"`

	// Identifies the home that is associated with the cache
	AfmTarget string `json:"afmTarget,omitempty"`

	// afm verify dmapi
	AfmVerifyDmapi bool `json:"afmVerifyDmapi,omitempty"`

	// afm write buffer size
	AfmWriteBufferSize int32 `json:"afmWriteBufferSize,omitempty"`

	// afm write on close
	AfmWriteOnClose bool `json:"afmWriteOnClose,omitempty"`

	// Current cache state
	CacheState string `json:"cacheState,omitempty"`

	// Current length of the queue on the primary gateway
	QueueLength int64 `json:"queueLength,omitempty"`

	// Number of operations played at home since the fileset is last Active
	QueueNumExec int64 `json:"queueNumExec,omitempty"`
}

// Validate validates this fileset afm
func (m *FilesetAfm) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAfmHostMapping(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAfmHostMaps(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAfmMode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *FilesetAfm) validateAfmHostMapping(formats strfmt.Registry) error {

	if swag.IsZero(m.AfmHostMapping) { // not required
		return nil
	}

	for i := 0; i < len(m.AfmHostMapping); i++ {
		if swag.IsZero(m.AfmHostMapping[i]) { // not required
			continue
		}

		if m.AfmHostMapping[i] != nil {
			if err := m.AfmHostMapping[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("afmHostMapping" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *FilesetAfm) validateAfmHostMaps(formats strfmt.Registry) error {

	if swag.IsZero(m.AfmHostMaps) { // not required
		return nil
	}

	for i := 0; i < len(m.AfmHostMaps); i++ {
		if swag.IsZero(m.AfmHostMaps[i]) { // not required
			continue
		}

		if m.AfmHostMaps[i] != nil {
			if err := m.AfmHostMaps[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("afmHostMaps" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var filesetAfmTypeAfmModePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["single-writer","read-only","local-updates","independent-writer","Primary","Secondary"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		filesetAfmTypeAfmModePropEnum = append(filesetAfmTypeAfmModePropEnum, v)
	}
}

const (

	// FilesetAfmAfmModeSingleWriter captures enum value "single-writer"
	FilesetAfmAfmModeSingleWriter string = "single-writer"

	// FilesetAfmAfmModeReadOnly captures enum value "read-only"
	FilesetAfmAfmModeReadOnly string = "read-only"

	// FilesetAfmAfmModeLocalUpdates captures enum value "local-updates"
	FilesetAfmAfmModeLocalUpdates string = "local-updates"

	// FilesetAfmAfmModeIndependentWriter captures enum value "independent-writer"
	FilesetAfmAfmModeIndependentWriter string = "independent-writer"

	// FilesetAfmAfmModePrimary captures enum value "Primary"
	FilesetAfmAfmModePrimary string = "Primary"

	// FilesetAfmAfmModeSecondary captures enum value "Secondary"
	FilesetAfmAfmModeSecondary string = "Secondary"
)

// prop value enum
func (m *FilesetAfm) validateAfmModeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, filesetAfmTypeAfmModePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *FilesetAfm) validateAfmMode(formats strfmt.Registry) error {

	if swag.IsZero(m.AfmMode) { // not required
		return nil
	}

	// value enum
	if err := m.validateAfmModeEnum("afmMode", "body", m.AfmMode); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *FilesetAfm) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *FilesetAfm) UnmarshalBinary(b []byte) error {
	var res FilesetAfm
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
