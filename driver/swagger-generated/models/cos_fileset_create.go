// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// CosFilesetCreate Object with parameters for creating filesets to COS
//
// swagger:model CosFilesetCreate
type CosFilesetCreate struct {

	// Access key for your bucket. Use together with Secret key
	AccessKey string `json:"accessKey,omitempty"`

	// Bucket name related to your fileset. You can skip this parameter if your fileset has the same name as your bucket
	Bucket string `json:"bucket,omitempty"`

	// Chunk size [in numeric] to control number of upload multiple parts
	ChunkSize int32 `json:"chunkSize,omitempty"`

	// Directory name or full path (inside a filesystem) where to link the fileset. If you skip this parameter, the fileset name will be used
	Dir string `json:"dir,omitempty"`

	// URL to your object store. Use server's hostname/IP or mapName
	// Required: true
	Endpoint *string `json:"endpoint"`

	// The name of the fileset. You can use the same name as the bucket
	// Required: true
	FilesetName *string `json:"filesetName"`

	// Group id/name for fileset users
	Gid string `json:"gid,omitempty"`

	// Fileset access mode -  independent-writer(iw), single-writer(sw) - default, read-only(ro) or local-updates(lu)
	// Enum: [iw sw ro lu]
	Mode string `json:"mode,omitempty"`

	// Create a new COS bucket
	// Enum: [true false]
	NewBucket string `json:"newBucket,omitempty"`

	// Access permission in octal
	Permission string `json:"permission,omitempty"`

	// Policy rules for the fileset (ignoring tmpDir and tmpFile)
	Policy []string `json:"policy"`

	// Enable eviction when used 80% of N Gigabyte blocks
	QuotaBlocks int32 `json:"quotaBlocks,omitempty"`

	// Ennable eviction when used 80% of N files
	QuotaFiles int32 `json:"quotaFiles,omitempty"`

	// Download size [in numeric], default is zero to get the full object
	ReadSize int32 `json:"readSize,omitempty"`

	// Secret key for your bucket. Use together with Access key
	SecretKey string `json:"secretKey,omitempty"`

	// Directory pattern to keep local (if no policy specified)
	TmpDir string `json:"tmpDir,omitempty"`

	// File pattern to keep local (if no policy specified)
	TmpFile string `json:"tmpFile,omitempty"`

	// User id/name for fileset owner
	UID string `json:"uid,omitempty"`

	// Use Google Cloud Services, for Google GCS
	UseGcs bool `json:"useGcs,omitempty"`

	// Handle COS more like a file system
	UseObjectFs bool `json:"useObjectFs,omitempty"`

	// Enable SSL certificate verification, valid only with https
	UseSslCertVerify bool `json:"useSslCertVerify,omitempty"`

	// Use user keys on requests from object store
	UseUserKeys bool `json:"useUserKeys,omitempty"`

	// Use Virtual Hosted Bucket, for Alibaba OSS
	UseVhb bool `json:"useVhb,omitempty"`

	// Get/set user extended attributes
	UseXattr bool `json:"useXattr,omitempty"`
}

// Validate validates this cos fileset create
func (m *CosFilesetCreate) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateEndpoint(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFilesetName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMode(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNewBucket(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CosFilesetCreate) validateEndpoint(formats strfmt.Registry) error {

	if err := validate.Required("endpoint", "body", m.Endpoint); err != nil {
		return err
	}

	return nil
}

func (m *CosFilesetCreate) validateFilesetName(formats strfmt.Registry) error {

	if err := validate.Required("filesetName", "body", m.FilesetName); err != nil {
		return err
	}

	return nil
}

var cosFilesetCreateTypeModePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["iw","sw","ro","lu"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		cosFilesetCreateTypeModePropEnum = append(cosFilesetCreateTypeModePropEnum, v)
	}
}

const (

	// CosFilesetCreateModeIw captures enum value "iw"
	CosFilesetCreateModeIw string = "iw"

	// CosFilesetCreateModeSw captures enum value "sw"
	CosFilesetCreateModeSw string = "sw"

	// CosFilesetCreateModeRo captures enum value "ro"
	CosFilesetCreateModeRo string = "ro"

	// CosFilesetCreateModeLu captures enum value "lu"
	CosFilesetCreateModeLu string = "lu"
)

// prop value enum
func (m *CosFilesetCreate) validateModeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, cosFilesetCreateTypeModePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CosFilesetCreate) validateMode(formats strfmt.Registry) error {

	if swag.IsZero(m.Mode) { // not required
		return nil
	}

	// value enum
	if err := m.validateModeEnum("mode", "body", m.Mode); err != nil {
		return err
	}

	return nil
}

var cosFilesetCreateTypeNewBucketPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["true","false"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		cosFilesetCreateTypeNewBucketPropEnum = append(cosFilesetCreateTypeNewBucketPropEnum, v)
	}
}

const (

	// CosFilesetCreateNewBucketTrue captures enum value "true"
	CosFilesetCreateNewBucketTrue string = "true"

	// CosFilesetCreateNewBucketFalse captures enum value "false"
	CosFilesetCreateNewBucketFalse string = "false"
)

// prop value enum
func (m *CosFilesetCreate) validateNewBucketEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, cosFilesetCreateTypeNewBucketPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *CosFilesetCreate) validateNewBucket(formats strfmt.Registry) error {

	if swag.IsZero(m.NewBucket) { // not required
		return nil
	}

	// value enum
	if err := m.validateNewBucketEnum("newBucket", "body", m.NewBucket); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CosFilesetCreate) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CosFilesetCreate) UnmarshalBinary(b []byte) error {
	var res CosFilesetCreate
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
