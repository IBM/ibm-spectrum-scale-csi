
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>csiplugin: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/IBM/ibm-spectrum-scale-csi/driver/csiplugin/controllerserver.go (2.9%)</option>
				
				<option value="file1">github.com/IBM/ibm-spectrum-scale-csi/driver/csiplugin/gpfs.go (58.8%)</option>
				
				<option value="file2">github.com/IBM/ibm-spectrum-scale-csi/driver/csiplugin/gpfs_util.go (13.5%)</option>
				
				<option value="file3">github.com/IBM/ibm-spectrum-scale-csi/driver/csiplugin/identityserver.go (0.0%)</option>
				
				<option value="file4">github.com/IBM/ibm-spectrum-scale-csi/driver/csiplugin/nodeserver.go (0.0%)</option>
				
				<option value="file5">github.com/IBM/ibm-spectrum-scale-csi/driver/csiplugin/server.go (0.0%)</option>
				
				<option value="file6">github.com/IBM/ibm-spectrum-scale-csi/driver/csiplugin/utils.go (30.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/**
 * Copyright 2019 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package scale

import (
        "fmt"
        "path/filepath"
        "strconv"
        "strings"
        "time"

        "github.com/IBM/ibm-spectrum-scale-csi/driver/csiplugin/connectors"
        "github.com/IBM/ibm-spectrum-scale-csi/driver/csiplugin/settings"
        "github.com/IBM/ibm-spectrum-scale-csi/driver/csiplugin/utils"
        "github.com/container-storage-interface/spec/lib/go/csi"
        "github.com/golang/glog"
        "github.com/golang/protobuf/ptypes/timestamp"
        "golang.org/x/net/context"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

const (
        no                           = "no"
        yes                          = "yes"
        notFound                     = "NOT_FOUND"
        filesystemTypeRemote         = "remote"
        filesystemMounted            = "mounted"
        filesetUnlinkedPath          = "--"
        ResponseStatusUnknown        = "UNKNOWN"
        oneGB                 uint64 = 1024 * 1024 * 1024
        smallestVolSize       uint64 = oneGB // 1GB
        defaultSnapWindow            = "30"  // default snapWindow for Consistency Group snapshots is 30 minutes

)

type ScaleControllerServer struct {
        Driver *ScaleDriver
}

func (cs *ScaleControllerServer) IfSameVolReqInProcess(scVol *scaleVolume) (bool, error) <span class="cov0" title="0">{
        cap, volpresent := cs.Driver.reqmap[scVol.VolName]
        if volpresent </span><span class="cov0" title="0">{
                if cap == int64(scVol.VolSize) </span><span class="cov0" title="0">{
                        return true, nil
                }</span> else<span class="cov0" title="0"> {
                        return false, status.Error(codes.Internal, fmt.Sprintf("Volume %v present in map but requested size %v does not match with size %v in map", scVol.VolName, scVol.VolSize, cap))
                }</span>
        }
        <span class="cov0" title="0">return false, nil</span>
}

func (cs *ScaleControllerServer) GetPriConnAndSLnkPath() (connectors.SpectrumScaleConnector, string, string, string, string, string, error) <span class="cov0" title="0">{
        primaryConn, isprimaryConnPresent := cs.Driver.connmap["primary"]

        if isprimaryConnPresent </span><span class="cov0" title="0">{
                return primaryConn, cs.Driver.primary.SymlinkRelativePath, cs.Driver.primary.GetPrimaryFs(), cs.Driver.primary.PrimaryFSMount, cs.Driver.primary.SymlinkAbsolutePath, cs.Driver.primary.PrimaryCid, nil
        }</span>

        <span class="cov0" title="0">return nil, "", "", "", "", "", status.Error(codes.Internal, "Primary connector not present in configMap")</span>
}

// createLWVol: Create lightweight volume - return relative path of directory created
func (cs *ScaleControllerServer) createLWVol(scVol *scaleVolume) (string, error) <span class="cov0" title="0">{
        glog.V(4).Infof("volume: [%v] - ControllerServer:createLWVol", scVol.VolName)
        var err error

        // check if directory exist
        dirExists, err := scVol.PrimaryConnector.CheckIfFileDirPresent(scVol.VolBackendFs, scVol.VolDirBasePath)
        if err != nil </span><span class="cov0" title="0">{
                glog.Errorf("volume:[%v] - unable to check if DirBasePath %v is present in filesystem %v. Error : %v", scVol.VolName, scVol.VolDirBasePath, scVol.VolBackendFs, err)
                return "", status.Error(codes.Internal, fmt.Sprintf("unable to check if DirBasePath %v is present in filesystem %v. Error : %v", scVol.VolDirBasePath, scVol.VolBackendFs, err))
        }</span>

        <span class="cov0" title="0">if !dirExists </span><span class="cov0" title="0">{
                glog.Errorf("volume:[%v] - directory base path %v not present in filesystem %v", scVol.VolName, scVol.VolDirBasePath, scVol.VolBackendFs)
                return "", status.Error(codes.Internal, fmt.Sprintf("directory base path %v not present in filesystem %v", scVol.VolDirBasePath, scVol.VolBackendFs))
        }</span>

        // create directory in the filesystem specified in storageClass
        <span class="cov0" title="0">dirPath := fmt.Sprintf("%s/%s", scVol.VolDirBasePath, scVol.VolName)

        glog.V(4).Infof("volume: [%v] - creating directory %v", scVol.VolName, dirPath)
        err = cs.createDirectory(scVol, scVol.VolName, dirPath)
        if err != nil </span><span class="cov0" title="0">{
                glog.Errorf("volume:[%v] - failed to create directory %v. Error : %v", scVol.VolName, dirPath, err)
                return "", status.Error(codes.Internal, err.Error())
        }</span>
        <span class="cov0" title="0">return dirPath, nil</span>
}

//generateVolID: Generate volume ID
//VolID format for all newly created volumes (from 2.5.0 onwards):

// &lt;storageclass_type&gt;;&lt;volume_type&gt;;&lt;cluster_id&gt;;&lt;filesystem_uuid&gt;;&lt;consistency_group&gt;;&lt;fileset_name&gt;;&lt;path&gt;
func (cs *ScaleControllerServer) generateVolID(scVol *scaleVolume, uid string, isNewVolumeType bool, targetPath string) (string, error) <span class="cov0" title="0">{
        glog.V(4).Infof("volume: [%v] - ControllerServer:generateVolId", scVol.VolName)
        var volID string
        var storageClassType string
        var volumeType string

        filesetName := scVol.VolName
        consistencyGroup := ""
        path := ""

        if isNewVolumeType </span><span class="cov0" title="0">{
                primaryConn, isprimaryConnPresent := cs.Driver.connmap["primary"]
                if !isprimaryConnPresent </span><span class="cov0" title="0">{
                        glog.Errorf("unable to get connector for primary cluster")
                        return "", status.Error(codes.Internal, "unable to find primary cluster details in custom resource")
                }</span>
                <span class="cov0" title="0">fsMountPoint, err := primaryConn.GetFilesystemMountDetails(scVol.LocalFS)
                if err != nil </span><span class="cov0" title="0">{
                        return "", status.Error(codes.Internal, fmt.Sprintf("unable to get mount info for FS [%v] in cluster", scVol.LocalFS))
                }</span>
                <span class="cov0" title="0">path = fmt.Sprintf("%s/%s", fsMountPoint.MountPoint, targetPath)</span>
        } else<span class="cov0" title="0"> {
                path = fmt.Sprintf("%s/%s", scVol.PrimarySLnkPath, scVol.VolName)
        }</span>
        <span class="cov0" title="0">glog.V(4).Infof("volume: [%v] - ControllerServer:generateVolId: targetPath: [%v]", scVol.VolName, path)

        if isNewVolumeType </span><span class="cov0" title="0">{
                storageClassType = STORAGECLASS_ADVANCED
                volumeType = FILE_DEPENDENTFILESET_VOLUME
                consistencyGroup = scVol.ConsistencyGroup
        }</span> else<span class="cov0" title="0"> {
                storageClassType = STORAGECLASS_CLASSIC
                if scVol.IsFilesetBased </span><span class="cov0" title="0">{
                        if scVol.FilesetType == independentFileset </span><span class="cov0" title="0">{
                                volumeType = FILE_INDEPENDENTFILESET_VOLUME
                        }</span> else<span class="cov0" title="0"> {
                                volumeType = FILE_DEPENDENTFILESET_VOLUME
                        }</span>
                } else<span class="cov0" title="0"> {
                        volumeType = FILE_DIRECTORYBASED_VOLUME
                        //filesetName for LW volume is empty
                        filesetName = ""
                }</span>
        }

        <span class="cov0" title="0">volID = fmt.Sprintf("%s;%s;%s;%s;%s;%s;%s", storageClassType, volumeType, scVol.ClusterId, uid, consistencyGroup, filesetName, path)
        return volID, nil</span>
}

// getTargetPath: retrun relative volume path from filesystem mount point
func (cs *ScaleControllerServer) getTargetPath(fsetLinkPath, fsMountPoint, volumeName string, createDataDir bool, isNewVolumeType bool) (string, error) <span class="cov0" title="0">{
        if fsetLinkPath == "" || fsMountPoint == "" </span><span class="cov0" title="0">{
                glog.Errorf("volume:[%v] - missing details to generate target path fileset junctionpath: [%v], filesystem mount point: [%v]", volumeName, fsetLinkPath, fsMountPoint)
                return "", fmt.Errorf("missing details to generate target path fileset junctionpath: [%v], filesystem mount point: [%v]", fsetLinkPath, fsMountPoint)
        }</span>
        <span class="cov0" title="0">glog.V(4).Infof("volume: [%v] - ControllerServer:getTargetPath", volumeName)
        targetPath := strings.Replace(fsetLinkPath, fsMountPoint, "", 1)
        if createDataDir &amp;&amp; !isNewVolumeType </span><span class="cov0" title="0">{
                targetPath = fmt.Sprintf("%s/%s-data", targetPath, volumeName)
        }</span>
        <span class="cov0" title="0">targetPath = strings.Trim(targetPath, "!/")

        return targetPath, nil</span>
}

// createDirectory: Create directory if not present
func (cs *ScaleControllerServer) createDirectory(scVol *scaleVolume, volName string, targetPath string) error <span class="cov0" title="0">{
        glog.V(4).Infof("volume: [%v] - ControllerServer:createDirectory", volName)
        dirExists, err := scVol.Connector.CheckIfFileDirPresent(scVol.VolBackendFs, targetPath)
        if err != nil </span><span class="cov0" title="0">{
                glog.Errorf("volume:[%v] - unable to check if directory path [%v] exists in filesystem [%v]. Error : %v", volName, targetPath, scVol.VolBackendFs, err)
                return fmt.Errorf("unable to check if directory path [%v] exists in filesystem [%v]. Error : %v", targetPath, scVol.VolBackendFs, err)
        }</span>

        <span class="cov0" title="0">if !dirExists </span><span class="cov0" title="0">{
                if scVol.VolPermissions != "" </span><span class="cov0" title="0">{
                        err = scVol.Connector.MakeDirectoryV2(scVol.VolBackendFs, targetPath, scVol.VolUid, scVol.VolGid, scVol.VolPermissions)
                        if err != nil </span><span class="cov0" title="0">{
                                // Directory creation failed, no cleanup will retry in next retry
                                glog.Errorf("volume:[%v] - unable to create directory [%v] in filesystem [%v]. Error : %v", volName, targetPath, scVol.VolBackendFs, err)
                                return fmt.Errorf("unable to create directory [%v] in filesystem [%v]. Error : %v", targetPath, scVol.VolBackendFs, err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        err = scVol.Connector.MakeDirectory(scVol.VolBackendFs, targetPath, scVol.VolUid, scVol.VolGid)
                        if err != nil </span><span class="cov0" title="0">{
                                // Directory creation failed, no cleanup will retry in next retry
                                glog.Errorf("volume:[%v] - unable to create directory [%v] in filesystem [%v]. Error : %v", volName, targetPath, scVol.VolBackendFs, err)
                                return fmt.Errorf("unable to create directory [%v] in filesystem [%v]. Error : %v", targetPath, scVol.VolBackendFs, err)
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// createSoftlink: Create soft link if not present
func (cs *ScaleControllerServer) createSoftlink(scVol *scaleVolume, target string) error <span class="cov0" title="0">{
        glog.V(4).Infof("volume: [%v] - ControllerServer:createSoftlink", scVol.VolName)
        volSlnkPath := fmt.Sprintf("%s/%s", scVol.PrimarySLnkRelPath, scVol.VolName)
        symLinkExists, err := scVol.PrimaryConnector.CheckIfFileDirPresent(scVol.PrimaryFS, volSlnkPath)
        if err != nil </span><span class="cov0" title="0">{
                glog.Errorf("volume:[%v] - unable to check if symlink path [%v] exists in filesystem [%v]. Error: %v", scVol.VolName, volSlnkPath, scVol.PrimaryFS, err)
                return fmt.Errorf("unable to check if symlink path [%v] exists in filesystem [%v]. Error: %v", volSlnkPath, scVol.PrimaryFS, err)
        }</span>

        <span class="cov0" title="0">if !symLinkExists </span><span class="cov0" title="0">{
                glog.Infof("symlink info filesystem [%v] TargetFS [%v]  target Path [%v] linkPath [%v]", scVol.PrimaryFS, scVol.LocalFS, target, volSlnkPath)
                err = scVol.PrimaryConnector.CreateSymLink(scVol.PrimaryFS, scVol.LocalFS, target, volSlnkPath)
                if err != nil </span><span class="cov0" title="0">{
                        glog.Errorf("volume:[%v] - failed to create symlink [%v] in filesystem [%v], for target [%v] in filesystem [%v]. Error [%v]", scVol.VolName, volSlnkPath, scVol.PrimaryFS, target, scVol.LocalFS, err)
                        return fmt.Errorf("failed to create symlink [%v] in filesystem [%v], for target [%v] in filesystem [%v]. Error [%v]", volSlnkPath, scVol.PrimaryFS, target, scVol.LocalFS, err)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// setQuota: Set quota if not set
func (cs *ScaleControllerServer) setQuota(scVol *scaleVolume, volName string) error <span class="cov0" title="0">{
        glog.V(4).Infof("volume: [%v] - ControllerServer:setQuota", volName)
        quota, err := scVol.Connector.ListFilesetQuota(scVol.VolBackendFs, volName)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to list quota for fileset [%v] in filesystem [%v]. Error [%v]", volName, scVol.VolBackendFs, err)
        }</span>

        <span class="cov0" title="0">filesetQuotaBytes, err := ConvertToBytes(quota)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "Invalid number specified") </span><span class="cov0" title="0">{
                        // Invalid number specified means quota is not set
                        filesetQuotaBytes = 0
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("unable to convert quota for fileset [%v] in filesystem [%v]. Error [%v]", volName, scVol.VolBackendFs, err)
                }</span>
        }

        <span class="cov0" title="0">if filesetQuotaBytes &lt; scVol.VolSize &amp;&amp; filesetQuotaBytes != 0 </span><span class="cov0" title="0">{
                // quota does not match and it is not 0 - It might not be fileset created by us
                return fmt.Errorf("fileset %v present but quota %v does not match with requested size %v", volName, filesetQuotaBytes, scVol.VolSize)
        }</span>

        <span class="cov0" title="0">if filesetQuotaBytes == 0 </span><span class="cov0" title="0">{
                volsiz := strconv.FormatUint(scVol.VolSize, 10)
                err = scVol.Connector.SetFilesetQuota(scVol.VolBackendFs, volName, volsiz)
                if err != nil </span><span class="cov0" title="0">{
                        // failed to set quota, no cleanup, next retry might be able to set quota
                        return fmt.Errorf("unable to set quota [%v] on fileset [%v] of FS [%v]", scVol.VolSize, volName, scVol.VolBackendFs)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// createFilesetBasedVol: Create fileset based volume  - return relative path of volume created
func (cs *ScaleControllerServer) createFilesetBasedVol(scVol *scaleVolume, isNewVolumeType bool) (string, error) <span class="cov0" title="0">{ //nolint:gocyclo,funlen
        glog.V(4).Infof("volume: [%v] - ControllerServer:createFilesetBasedVol", scVol.VolName)
        opt := make(map[string]interface{})

        // fileset can not be created if filesystem is remote.
        glog.V(4).Infof("check if volumes filesystem [%v] is remote or local for cluster [%v]", scVol.VolBackendFs, scVol.ClusterId)
        fsDetails, err := scVol.Connector.GetFilesystemDetails(scVol.VolBackendFs)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "Invalid value in filesystemName") </span><span class="cov0" title="0">{
                        glog.Errorf("volume:[%v] - filesystem %s in not known to cluster %v. Error: %v", scVol.VolName, scVol.VolBackendFs, scVol.ClusterId, err)
                        return "", status.Error(codes.Internal, fmt.Sprintf("Filesystem %s in not known to cluster %v. Error: %v", scVol.VolBackendFs, scVol.ClusterId, err))
                }</span>
                <span class="cov0" title="0">glog.Errorf("volume:[%v] - unable to check type of filesystem [%v]. Error: %v", scVol.VolName, scVol.VolBackendFs, err)
                return "", status.Error(codes.Internal, fmt.Sprintf("unable to check type of filesystem [%v]. Error: %v", scVol.VolBackendFs, err))</span>
        }

        <span class="cov0" title="0">if fsDetails.Type == filesystemTypeRemote </span><span class="cov0" title="0">{
                glog.Errorf("volume:[%v] - filesystem [%v] is not local to cluster [%v]", scVol.VolName, scVol.VolBackendFs, scVol.ClusterId)
                return "", status.Error(codes.Internal, fmt.Sprintf("filesystem [%v] is not local to cluster [%v]", scVol.VolBackendFs, scVol.ClusterId))
        }</span>

        // if filesystem is remote, check it is mounted on remote GUI node.
        <span class="cov0" title="0">if cs.Driver.primary.PrimaryCid != scVol.ClusterId </span><span class="cov0" title="0">{
                if fsDetails.Mount.Status != filesystemMounted </span><span class="cov0" title="0">{
                        glog.Errorf("volume:[%v] -  filesystem [%v] is [%v] on remote GUI of cluster [%v]", scVol.VolName, scVol.VolBackendFs, fsDetails.Mount.Status, scVol.ClusterId)
                        return "", status.Error(codes.Internal, fmt.Sprintf("Filesystem %v in cluster %v is not mounted", scVol.VolBackendFs, scVol.ClusterId))
                }</span>
                <span class="cov0" title="0">glog.V(4).Infof("volume:[%v] - mount point of volume filesystem [%v] on owning cluster is %v", scVol.VolName, scVol.VolBackendFs, fsDetails.Mount.MountPoint)</span>
        }

        // check if quota is enabled on volume filesystem
        <span class="cov0" title="0">glog.V(4).Infof("check if quota is enabled on filesystem [%v] ", scVol.VolBackendFs)
        if scVol.VolSize != 0 </span><span class="cov0" title="0">{
                err = scVol.Connector.CheckIfFSQuotaEnabled(scVol.VolBackendFs)
                if err != nil </span><span class="cov0" title="0">{
                        glog.Errorf("volume:[%v] - quota not enabled for filesystem %v of cluster %v. Error: %v", scVol.VolName, scVol.VolBackendFs, scVol.ClusterId, err)
                        return "", status.Error(codes.Internal, fmt.Sprintf("quota not enabled for filesystem %v of cluster %v", scVol.VolBackendFs, scVol.ClusterId))
                }</span>
        }

        <span class="cov0" title="0">if scVol.VolUid != "" </span><span class="cov0" title="0">{
                opt[connectors.UserSpecifiedUid] = scVol.VolUid
        }</span>
        <span class="cov0" title="0">if scVol.VolGid != "" </span><span class="cov0" title="0">{
                opt[connectors.UserSpecifiedGid] = scVol.VolGid
        }</span>
        <span class="cov0" title="0">if scVol.InodeLimit != "" </span><span class="cov0" title="0">{
                opt[connectors.UserSpecifiedInodeLimit] = scVol.InodeLimit
        }</span> else<span class="cov0" title="0"> {
                var inodeLimit uint64
                if scVol.VolSize &gt; 10*oneGB </span><span class="cov0" title="0">{
                        inodeLimit = 200000
                }</span> else<span class="cov0" title="0"> {
                        inodeLimit = 100000
                }</span>
                <span class="cov0" title="0">opt[connectors.UserSpecifiedInodeLimit] = strconv.FormatUint(inodeLimit, 10)</span>
        }

        <span class="cov0" title="0">if isNewVolumeType </span><span class="cov0" title="0">{
                // For new storageClass first create independent fileset if not present
                indepFilesetName := scVol.ConsistencyGroup
                glog.V(4).Infof("creating independent fileset for new storageClass with fileset name: [%v]", indepFilesetName)
                opt[connectors.UserSpecifiedFilesetType] = independentFileset
                opt[connectors.UserSpecifiedParentFset] = ""
                //Set uid and gid as 0 for CG independent fileset
                opt[connectors.UserSpecifiedUid] = "0"
                opt[connectors.UserSpecifiedGid] = "0"
                if scVol.InodeLimit != "" </span><span class="cov0" title="0">{
                        opt[connectors.UserSpecifiedInodeLimit] = scVol.InodeLimit
                }</span> else<span class="cov0" title="0"> {
                        opt[connectors.UserSpecifiedInodeLimit] = "1M"
                        // Assumption: On an average a consistency group contains 10 volumes
                }</span>
                <span class="cov0" title="0">scVol.ParentFileset = ""
                createDataDir := false
                filesetPath, err := cs.createFilesetVol(scVol, indepFilesetName, fsDetails, opt, createDataDir, true, isNewVolumeType)
                if err != nil </span><span class="cov0" title="0">{
                        glog.Errorf("volume:[%v] - failed to create independent fileset [%v] in filesystem [%v]. Error: %v", indepFilesetName, indepFilesetName, scVol.VolBackendFs, err)
                        return "", err
                }</span>
                <span class="cov0" title="0">glog.V(4).Infof("finished creation of independent fileset for new storageClass with fileset name: [%v]", indepFilesetName)

                // Now create dependent fileset
                glog.V(4).Infof("creating dependent fileset for new storageClass with fileset name: [%v]", scVol.VolName)
                opt[connectors.UserSpecifiedFilesetType] = dependentFileset
                opt[connectors.UserSpecifiedParentFset] = indepFilesetName
                delete(opt, connectors.UserSpecifiedUid)
                delete(opt, connectors.UserSpecifiedGid)
                if scVol.VolUid != "" </span><span class="cov0" title="0">{
                        opt[connectors.UserSpecifiedUid] = scVol.VolUid
                }</span>
                <span class="cov0" title="0">if scVol.VolGid != "" </span><span class="cov0" title="0">{
                        opt[connectors.UserSpecifiedGid] = scVol.VolGid
                }</span>
                <span class="cov0" title="0">if scVol.VolPermissions != "" </span><span class="cov0" title="0">{
                        opt[connectors.UserSpecifiedPermissions] = scVol.VolPermissions
                }</span>

                <span class="cov0" title="0">scVol.ParentFileset = indepFilesetName
                createDataDir = true
                filesetPath, err = cs.createFilesetVol(scVol, scVol.VolName, fsDetails, opt, createDataDir, false, isNewVolumeType)
                if err != nil </span><span class="cov0" title="0">{
                        glog.Errorf("volume:[%v] - failed to create dependent fileset [%v] in filesystem [%v]. Error: %v", scVol.VolName, scVol.VolName, scVol.VolBackendFs, err)
                        return "", err
                }</span>
                <span class="cov0" title="0">glog.V(4).Infof("finished creation of dependent fileset for new storageClass with fileset name: [%v]", scVol.VolName)
                return filesetPath, nil</span>
        } else<span class="cov0" title="0"> {
                // Create volume for classic storageClass
                // Check if FileSetType not specified
                if scVol.FilesetType != "" </span><span class="cov0" title="0">{
                        opt[connectors.UserSpecifiedFilesetType] = scVol.FilesetType
                }</span>
                <span class="cov0" title="0">if scVol.ParentFileset != "" </span><span class="cov0" title="0">{
                        opt[connectors.UserSpecifiedParentFset] = scVol.ParentFileset
                }</span>

                // Create fileset
                <span class="cov0" title="0">glog.V(4).Infof("creating fileset for classic storageClass with fileset name: [%v]", scVol.VolName)
                createDataDir := true
                filesetPath, err := cs.createFilesetVol(scVol, scVol.VolName, fsDetails, opt, createDataDir, false, isNewVolumeType)
                if err != nil </span><span class="cov0" title="0">{
                        glog.Errorf("volume:[%v] - failed to create fileset [%v] in filesystem [%v]. Error: %v", scVol.VolName, scVol.VolName, scVol.VolBackendFs, err)
                        return "", err
                }</span>
                <span class="cov0" title="0">glog.V(4).Infof("finished creation of fileset for classic storageClass with fileset name: [%v]", scVol.VolName)
                return filesetPath, nil</span>
        }

}

func (cs *ScaleControllerServer) createFilesetVol(scVol *scaleVolume, volName string, fsDetails connectors.FileSystem_v2, opt map[string]interface{}, createDataDir bool, isCGIndependentFset bool, isNewVolumeType bool) (string, error) <span class="cov0" title="0">{ //nolint:gocyclo,funlen
        // Check if fileset exist
        filesetInfo, err := scVol.Connector.ListFileset(scVol.VolBackendFs, volName)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "Invalid value in 'filesetName'") </span><span class="cov0" title="0">{
                        // This means fileset is not present, create it
                        fseterr := scVol.Connector.CreateFileset(scVol.VolBackendFs, volName, opt)

                        if fseterr != nil </span><span class="cov0" title="0">{
                                // fileset creation failed return without cleanup
                                glog.Errorf("volume:[%v] - unable to create fileset [%v] in filesystem [%v]. Error: %v", volName, volName, scVol.VolBackendFs, fseterr)
                                return "", status.Error(codes.Internal, fmt.Sprintf("unable to create fileset [%v] in filesystem [%v]. Error: %v", volName, scVol.VolBackendFs, fseterr))
                        }</span>
                        // list fileset and update filesetInfo
                        <span class="cov0" title="0">filesetInfo, err = scVol.Connector.ListFileset(scVol.VolBackendFs, volName)
                        if err != nil </span><span class="cov0" title="0">{
                                // fileset got created but listing failed, return without cleanup
                                glog.Errorf("volume:[%v] - unable to list newly created fileset [%v] in filesystem [%v]. Error: %v", volName, volName, scVol.VolBackendFs, err)
                                return "", status.Error(codes.Internal, fmt.Sprintf("unable to list newly created fileset [%v] in filesystem [%v]. Error: %v", volName, scVol.VolBackendFs, err))
                        }</span>
                } else<span class="cov0" title="0"> {
                        glog.Errorf("volume:[%v] - unable to list fileset [%v] in filesystem [%v]. Error: %v", volName, volName, scVol.VolBackendFs, err)
                        return "", status.Error(codes.Internal, fmt.Sprintf("unable to list fileset [%v] in filesystem [%v]. Error: %v", volName, scVol.VolBackendFs, err))
                }</span>
        } else<span class="cov0" title="0"> {
                // fileset is present. Confirm if creator is IBM Spectrum Scale CSI driver and fileset type is correct.
                if filesetInfo.Config.Comment != connectors.FilesetComment </span><span class="cov0" title="0">{
                        glog.Errorf("volume:[%v] - the fileset is not created by IBM Spectrum Scale CSI driver. Cannot use it.", volName)
                        return "", status.Error(codes.Internal, fmt.Sprintf("volume:[%v] - the fileset is not created by IBM Spectrum Scale CSI driver. Cannot use it.", volName))
                }</span>
                <span class="cov0" title="0">listFilesetType := ""
                if filesetInfo.Config.IsInodeSpaceOwner == true </span><span class="cov0" title="0">{
                        listFilesetType = independentFileset
                }</span> else<span class="cov0" title="0"> {
                        listFilesetType = dependentFileset
                }</span>
                <span class="cov0" title="0">if opt[connectors.UserSpecifiedFilesetType] != listFilesetType </span><span class="cov0" title="0">{
                        glog.Errorf("volume:[%v] - the fileset type is not as expected, got type: [%s], expected type: [%s]", volName, listFilesetType, opt[connectors.UserSpecifiedFilesetType])
                        return "", status.Error(codes.Internal, fmt.Sprintf("volume:[%v] - the fileset type is not as expected, got type: [%s], expected type: [%s]", volName, listFilesetType, opt[connectors.UserSpecifiedFilesetType]))
                }</span>
        }

        // fileset is present/created. Confirm if fileset is linked
        <span class="cov0" title="0">if (filesetInfo.Config.Path == "") || (filesetInfo.Config.Path == filesetUnlinkedPath) </span><span class="cov0" title="0">{
                // this means not linked, link it
                var junctionPath string
                junctionPath = fmt.Sprintf("%s/%s", fsDetails.Mount.MountPoint, volName)

                if scVol.ParentFileset != "" </span><span class="cov0" title="0">{
                        parentfilesetInfo, err := scVol.Connector.ListFileset(scVol.VolBackendFs, scVol.ParentFileset)
                        if err != nil </span><span class="cov0" title="0">{
                                glog.Errorf("volume:[%v] - unable to get details of parent fileset [%v] in filesystem [%v]. Error: %v", volName, scVol.ParentFileset, scVol.VolBackendFs, err)
                                return "", status.Error(codes.Internal, fmt.Sprintf("volume:[%v] - unable to get details of parent fileset [%v] in filesystem [%v]. Error: %v", volName, scVol.ParentFileset, scVol.VolBackendFs, err))
                        }</span>
                        <span class="cov0" title="0">if (parentfilesetInfo.Config.Path == "") || (parentfilesetInfo.Config.Path == filesetUnlinkedPath) </span><span class="cov0" title="0">{
                                glog.Errorf("volume:[%v] - parent fileset [%v] is not linked", volName, scVol.ParentFileset)
                                return "", status.Error(codes.Internal, fmt.Sprintf("volume:[%v] - parent fileset [%v] is not linked", volName, scVol.ParentFileset))
                        }</span>
                        <span class="cov0" title="0">junctionPath = fmt.Sprintf("%s/%s", parentfilesetInfo.Config.Path, volName)</span>
                }

                <span class="cov0" title="0">err := scVol.Connector.LinkFileset(scVol.VolBackendFs, volName, junctionPath)
                if err != nil </span><span class="cov0" title="0">{
                        glog.Errorf("volume:[%v] - linking fileset [%v] in filesystem [%v] at path [%v] failed. Error: %v", volName, volName, scVol.VolBackendFs, junctionPath, err)
                        return "", status.Error(codes.Internal, fmt.Sprintf("linking fileset [%v] in filesystem [%v] at path [%v] failed. Error: %v", volName, scVol.VolBackendFs, junctionPath, err))
                }</span>
                // update fileset details
                <span class="cov0" title="0">filesetInfo, err = scVol.Connector.ListFileset(scVol.VolBackendFs, volName)
                if err != nil </span><span class="cov0" title="0">{
                        glog.Errorf("volume:[%v] - unable to list fileset [%v] in filesystem [%v] after linking. Error: %v", volName, volName, scVol.VolBackendFs, err)
                        return "", status.Error(codes.Internal, fmt.Sprintf("unable to list fileset [%v] in filesystem [%v] after linking. Error: %v", volName, scVol.VolBackendFs, err))
                }</span>
        }
        <span class="cov0" title="0">targetBasePath := ""
        if !isCGIndependentFset </span><span class="cov0" title="0">{
                if scVol.VolSize != 0 </span><span class="cov0" title="0">{
                        err = cs.setQuota(scVol, volName)
                        if err != nil </span><span class="cov0" title="0">{
                                if strings.Contains(fmt.Sprint(err), "does not match with requested size") </span><span class="cov0" title="0">{
                                        return "", status.Error(codes.AlreadyExists, err.Error())
                                }</span> else<span class="cov0" title="0"> {
                                        return "", status.Error(codes.Internal, err.Error())
                                }</span>
                        }
                }

                <span class="cov0" title="0">targetBasePath, err = cs.getTargetPath(filesetInfo.Config.Path, fsDetails.Mount.MountPoint, volName, createDataDir, isNewVolumeType)
                if err != nil </span><span class="cov0" title="0">{
                        return "", status.Error(codes.Internal, err.Error())
                }</span>

                <span class="cov0" title="0">err = cs.createDirectory(scVol, volName, targetBasePath)
                if err != nil </span><span class="cov0" title="0">{
                        return "", status.Error(codes.Internal, err.Error())
                }</span>
        }
        <span class="cov0" title="0">return targetBasePath, nil</span>
}

func (cs *ScaleControllerServer) getVolumeSizeInBytes(req *csi.CreateVolumeRequest) int64 <span class="cov0" title="0">{
        cap := req.GetCapacityRange()
        return cap.GetRequiredBytes()
}</span>

func (cs *ScaleControllerServer) getConnFromClusterID(cid string) (connectors.SpectrumScaleConnector, error) <span class="cov8" title="1">{
        connector, isConnPresent := cs.Driver.connmap[cid]
        if isConnPresent </span><span class="cov8" title="1">{
                return connector, nil
        }</span>
        <span class="cov0" title="0">glog.Errorf("unable to get connector for cluster ID %v", cid)
        return nil, status.Error(codes.Internal, fmt.Sprintf("unable to find cluster [%v] details in custom resource", cid))</span>
}

// checkSCSupportedParams checks if given CreateVolume request parameter keys
// are supported by Spectrum Scale CSI and returns ("", true) if all parameter
// keys are supported, otherwise returns (&lt;list of invalid keys seperated by
// comma&gt;, false)
func checkSCSupportedParams(params map[string]string) (string, bool) <span class="cov0" title="0">{
        var invalidParams []string
        for k := range params </span><span class="cov0" title="0">{
                switch k </span>{
                case "csi.storage.k8s.io/pv/name", "csi.storage.k8s.io/pvc/name",
                        "csi.storage.k8s.io/pvc/namespace", "storage.kubernetes.io/csiProvisionerIdentity",
                        "volBackendFs", "volDirBasePath", "uid", "gid", "permissions",
                        "clusterId", "filesetType", "parentFileset", "inodeLimit", "nodeClass",
                        "version", "tier", "compression", "consistencyGroup", "shared":<span class="cov0" title="0"></span>
                        // These are valid parameters, do nothing here
                default:<span class="cov0" title="0">
                        invalidParams = append(invalidParams, k)</span>
                }
        }
        <span class="cov0" title="0">if len(invalidParams) == 0 </span><span class="cov0" title="0">{
                return "", true
        }</span>
        <span class="cov0" title="0">return strings.Join(invalidParams[:], ", "), false</span>
}

// CreateVolume - Create Volume
func (cs *ScaleControllerServer) CreateVolume(ctx context.Context, req *csi.CreateVolumeRequest) (*csi.CreateVolumeResponse, error) <span class="cov0" title="0">{ //nolint:gocyclo,funlen
        glog.V(3).Infof("create volume req: %v", req)

        if err := cs.Driver.ValidateControllerServiceRequest(csi.ControllerServiceCapability_RPC_CREATE_DELETE_VOLUME); err != nil </span><span class="cov0" title="0">{
                glog.V(3).Infof("invalid create volume req: %v", req)
                return nil, status.Error(codes.Internal, fmt.Sprintf("CreateVolume ValidateControllerServiceRequest failed: %v", err))
        }</span>

        <span class="cov0" title="0">if req == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "Request cannot be empty")
        }</span>

        <span class="cov0" title="0">volName := req.GetName()
        if volName == "" </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "Volume Name is a required field")
        }</span>

        /* Get volume size in bytes */
        <span class="cov0" title="0">volSize := cs.getVolumeSizeInBytes(req)

        reqCapabilities := req.GetVolumeCapabilities()
        if reqCapabilities == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "Volume Capabilities is a required field")
        }</span>

        <span class="cov0" title="0">for _, reqCap := range reqCapabilities </span><span class="cov0" title="0">{
                if reqCap.GetBlock() != nil </span><span class="cov0" title="0">{
                        return nil, status.Error(codes.Unimplemented, "Block Volume is not supported")
                }</span>
                <span class="cov0" title="0">if reqCap.GetAccessMode().GetMode() == csi.VolumeCapability_AccessMode_MULTI_NODE_READER_ONLY </span><span class="cov0" title="0">{
                        return nil, status.Error(codes.Unimplemented, "Volume with Access Mode ReadOnlyMany is not supported")
                }</span>
        }

        <span class="cov0" title="0">invalidParams, allValid := checkSCSupportedParams(req.GetParameters())
        if !allValid </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "The Parameter(s) not supported in storageClass: "+invalidParams)
        }</span>
        <span class="cov0" title="0">scaleVol, err := getScaleVolumeOptions(req.GetParameters())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">isNewVolumeType := false
        if scaleVol.StorageClassType == STORAGECLASS_ADVANCED </span><span class="cov0" title="0">{
                isNewVolumeType = true
        }</span>

        <span class="cov0" title="0">scaleVol.VolName = volName
        if scaleVol.IsFilesetBased &amp;&amp; uint64(volSize) &lt; smallestVolSize </span><span class="cov0" title="0">{
                scaleVol.VolSize = smallestVolSize
        }</span> else<span class="cov0" title="0"> {
                scaleVol.VolSize = uint64(volSize)
        }</span>

        /* Get details for Primary Cluster */
        <span class="cov0" title="0">pConn, PSLnkRelPath, PFS, PFSMount, PSLnkPath, PCid, err := cs.GetPriConnAndSLnkPath()

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">scaleVol.PrimaryConnector = pConn
        scaleVol.PrimarySLnkRelPath = PSLnkRelPath
        scaleVol.PrimaryFS = PFS
        scaleVol.PrimaryFSMount = PFSMount
        scaleVol.PrimarySLnkPath = PSLnkPath

        volSrc := req.GetVolumeContentSource()
        isSnapSource := false
        isVolSource := false

        snapIdMembers := scaleSnapId{}
        srcVolumeIDMembers := scaleVolId{}

        if volSrc != nil </span><span class="cov0" title="0">{
                srcVolume := volSrc.GetVolume()
                if srcVolume != nil </span><span class="cov0" title="0">{
                        srcVolumeID := srcVolume.GetVolumeId()
                        srcVolumeIDMembers, err = getVolIDMembers(srcVolumeID)
                        if err != nil </span><span class="cov0" title="0">{
                                glog.Errorf("volume:[%v] - Invalid Volume ID %s [%v]", volName, srcVolumeID, err)
                                return nil, status.Error(codes.NotFound, fmt.Sprintf("volume source volume is not found: %v", err))
                        }</span>
                        <span class="cov0" title="0">isVolSource = true</span>
                } else<span class="cov0" title="0"> {

                        srcSnap := volSrc.GetSnapshot()
                        if srcSnap != nil </span><span class="cov0" title="0">{
                                snapId := srcSnap.GetSnapshotId()
                                snapIdMembers, err = cs.GetSnapIdMembers(snapId)
                                if err != nil </span><span class="cov0" title="0">{
                                        glog.Errorf("volume:[%v] - Invalid snapshot ID %s [%v]", volName, snapId, err)
                                        return nil, status.Error(codes.NotFound, fmt.Sprintf("volume source snapshot is not found: %v", err))
                                }</span>
                                <span class="cov0" title="0">isSnapSource = true</span>
                        }
                }
        }

        // Check if Primary Fileset is linked
        <span class="cov0" title="0">primaryFileset := cs.Driver.primary.PrimaryFset
        glog.V(5).Infof("volume:[%v] - check if primary fileset [%v] is linked", scaleVol.VolName, primaryFileset)
        isPrimaryFilesetLinked, err := scaleVol.PrimaryConnector.IsFilesetLinked(scaleVol.PrimaryFS, primaryFileset)
        if err != nil </span><span class="cov0" title="0">{
                glog.Errorf("volume:[%v] - unable to get details of Primary Fileset [%v]. Error : [%v]", scaleVol.VolName, primaryFileset, err)
                return nil, status.Error(codes.Internal, fmt.Sprintf("unable to get details of Primary Fileset [%v]. Error : [%v]", primaryFileset, err))
        }</span>
        <span class="cov0" title="0">if !isPrimaryFilesetLinked </span><span class="cov0" title="0">{
                glog.Errorf("volume:[%v] - primary fileset [%v] is not linked", scaleVol.VolName, primaryFileset)
                return nil, status.Error(codes.Internal, fmt.Sprintf("primary fileset [%v] is not linked", primaryFileset))
        }</span>

        <span class="cov0" title="0">if scaleVol.PrimaryFS != scaleVol.VolBackendFs </span><span class="cov0" title="0">{
                // primary filesytem must be mounted on GUI node so that we can create the softlink
                // skip if primary and volume filesystem is same
                glog.V(4).Infof("volume:[%v] - check if primary filesystem [%v] is mounted on GUI node of Primary cluster", scaleVol.VolName, scaleVol.PrimaryFS)
                isPfsMounted, err := scaleVol.PrimaryConnector.IsFilesystemMountedOnGUINode(scaleVol.PrimaryFS)
                if err != nil </span><span class="cov0" title="0">{
                        glog.Errorf("volume:[%v] - unable to get filesystem mount details for %s on Primary cluster. Error: %v", scaleVol.VolName, scaleVol.PrimaryFS, err)
                        return nil, status.Error(codes.Internal, fmt.Sprintf("unable to get filesystem mount details for %s on Primary cluster. Error: %v", scaleVol.PrimaryFS, err))
                }</span>
                <span class="cov0" title="0">if !isPfsMounted </span><span class="cov0" title="0">{
                        glog.Errorf("volume:[%v] - primary filesystem %s is not mounted on GUI node of Primary cluster", scaleVol.VolName, scaleVol.PrimaryFS)
                        return nil, status.Error(codes.Internal, fmt.Sprintf("primary filesystem %s is not mounted on GUI node of Primary cluster", scaleVol.PrimaryFS))
                }</span>
        }

        <span class="cov0" title="0">glog.V(5).Infof("volume:[%v] - check if volume filesystem [%v] is mounted on GUI node of Primary cluster", scaleVol.VolName, scaleVol.VolBackendFs)
        volFsInfo, err := scaleVol.PrimaryConnector.GetFilesystemDetails(scaleVol.VolBackendFs)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "Invalid value in filesystemName") </span><span class="cov0" title="0">{
                        glog.Errorf("volume:[%v] - filesystem %s in not known to primary cluster. Error: %v", scaleVol.VolName, scaleVol.VolBackendFs, err)
                        return nil, status.Error(codes.Internal, fmt.Sprintf("filesystem %s in not known to primary cluster. Error: %v", scaleVol.VolBackendFs, err))
                }</span>
                <span class="cov0" title="0">glog.Errorf("volume:[%v] - unable to get details for filesystem [%v] in Primary cluster. Error: %v", scaleVol.VolName, scaleVol.VolBackendFs, err)
                return nil, status.Error(codes.Internal, fmt.Sprintf("unable to get details for filesystem [%v] in Primary cluster. Error: %v", scaleVol.VolBackendFs, err))</span>
        }

        <span class="cov0" title="0">if volFsInfo.Mount.Status != filesystemMounted </span><span class="cov0" title="0">{
                glog.Errorf("volume:[%v] - volume filesystem %s is not mounted on GUI node of Primary cluster", scaleVol.VolName, scaleVol.VolBackendFs)
                return nil, status.Error(codes.Internal, fmt.Sprintf("volume filesystem %s is not mounted on GUI node of Primary cluster", scaleVol.VolBackendFs))
        }</span>

        <span class="cov0" title="0">glog.V(5).Infof("volume:[%v] - mount point of volume filesystem [%v] is on Primary cluster is %v", scaleVol.VolName, scaleVol.VolBackendFs, volFsInfo.Mount.MountPoint)

        /* scaleVol.VolBackendFs will always be local cluster FS. So we need to find a
           remote cluster FS in case local cluster FS is remotely mounted. We will find local FS RemoteDeviceName on local cluster, will use that as VolBackendFs and        create fileset on that FS. */

        if scaleVol.IsFilesetBased </span><span class="cov0" title="0">{
                remoteDeviceName := volFsInfo.Mount.RemoteDeviceName
                scaleVol.LocalFS = scaleVol.VolBackendFs
                scaleVol.VolBackendFs = getRemoteFsName(remoteDeviceName)
        }</span> else<span class="cov0" title="0"> {
                scaleVol.LocalFS = scaleVol.VolBackendFs
        }</span>

        // LocalFs is name of filesystem on K8s cluster
        // VolBackendFs is changed to name on remote cluster in case of fileset based provisioning

        <span class="cov0" title="0">var remoteClusterID string
        if scaleVol.ClusterId == "" &amp;&amp; volFsInfo.Type == filesystemTypeRemote </span><span class="cov0" title="0">{
                glog.V(5).Infof("filesystem %s is remotely mounted, getting cluster ID information of the owning cluster.", volFsInfo.Name)
                clusterName := strings.Split(volFsInfo.Mount.RemoteDeviceName, ":")[0]
                if remoteClusterID, err = cs.getRemoteClusterID(clusterName); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">glog.V(5).Infof("cluster ID for remote cluster %s is %s", clusterName, remoteClusterID)</span>
        }

        <span class="cov0" title="0">if scaleVol.IsFilesetBased </span><span class="cov0" title="0">{
                if scaleVol.ClusterId == "" </span><span class="cov0" title="0">{
                        if volFsInfo.Type == filesystemTypeRemote </span><span class="cov0" title="0">{ // if fileset based and remotely mounted.
                                glog.V(3).Infof("volume filesystem %s is remotely mounted on Primary cluster, using owning cluster ID %s.", scaleVol.LocalFS, remoteClusterID)
                                scaleVol.ClusterId = remoteClusterID
                        }</span> else<span class="cov0" title="0"> {
                                glog.V(3).Infof("volume filesystem %s is locally mounted on Primary cluster, using primary cluster ID %s.", scaleVol.LocalFS, PCid)
                                scaleVol.ClusterId = PCid
                        }</span>
                }
                <span class="cov0" title="0">conn, err := cs.getConnFromClusterID(scaleVol.ClusterId)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">scaleVol.Connector = conn</span>
        } else<span class="cov0" title="0"> {
                scaleVol.Connector = scaleVol.PrimaryConnector
                scaleVol.ClusterId = PCid
        }</span>

        <span class="cov0" title="0">if isNewVolumeType </span><span class="cov0" title="0">{
                if err := cs.checkCGSupport(scaleVol.Connector); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">if isVolSource </span><span class="cov0" title="0">{
                err = cs.validateCloneRequest(&amp;srcVolumeIDMembers, scaleVol, PCid, volFsInfo)
                if err != nil </span><span class="cov0" title="0">{
                        glog.Errorf("volume:[%v] - Error in source volume validation [%v]", volName, err)
                        return nil, err
                }</span>

        }

        <span class="cov0" title="0">if isSnapSource </span><span class="cov0" title="0">{
                err = cs.validateSnapId(&amp;snapIdMembers, scaleVol, PCid)
                if err != nil </span><span class="cov0" title="0">{
                        glog.Errorf("volume:[%v] - Error in source snapshot validation [%v]", volName, err)
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">glog.Infof("volume:[%v] -  spectrum scale volume create params : %v\n", scaleVol.VolName, scaleVol)

        if scaleVol.IsFilesetBased &amp;&amp; scaleVol.Compression != "" </span><span class="cov0" title="0">{
                glog.Infof("createvolume: compression is enabled: changing volume name")
                scaleVol.VolName = fmt.Sprintf("%s-COMPRESS%scsi", scaleVol.VolName, strings.ToUpper(scaleVol.Compression))
        }</span>

        <span class="cov0" title="0">if scaleVol.IsFilesetBased &amp;&amp; scaleVol.Tier != "" </span><span class="cov0" title="0">{
                if err := cs.checkVolTierSupport(volFsInfo.Version); err != nil </span><span class="cov0" title="0">{
                        // TODO: Remove this secondary call to local gui when GUI refreshes remote cache immediately
                        tempFsInfo, err := scaleVol.Connector.GetFilesystemDetails(scaleVol.VolBackendFs)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">if err := cs.checkVolTierSupport(tempFsInfo.Version); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }

                <span class="cov0" title="0">if err := scaleVol.Connector.DoesTierExist(scaleVol.Tier, scaleVol.VolBackendFs); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">rule := "RULE 'csi-T%s' SET POOL '%s' WHERE FILESET_NAME LIKE 'pvc-%%-T%scsi%%'"
                policy := connectors.Policy{}

                policy.Policy = fmt.Sprintf(rule, scaleVol.Tier, scaleVol.Tier, scaleVol.Tier)
                policy.Priority = -5
                policy.Partition = fmt.Sprintf("csi-T%s", scaleVol.Tier)

                scaleVol.VolName = fmt.Sprintf("%s-T%scsi", scaleVol.VolName, scaleVol.Tier)
                err = scaleVol.Connector.SetFilesystemPolicy(&amp;policy, scaleVol.VolBackendFs)
                if err != nil </span><span class="cov0" title="0">{
                        glog.Errorf("volume:[%v] - setting policy failed [%v]", volName, err)
                        return nil, err
                }</span>

                // Since we are using a SET POOL rule, if there is not already a default rule in place in the policy partition
                // then all files that do not match our rules will have no defined place to go. This sets a default rule with
                // "lower" priority than the main policy as a catch all. If there is already a default rule in the main policy
                // file then that will take precedence
                <span class="cov0" title="0">defaultPartitionName := "csi-defaultRule"
                if !scaleVol.Connector.CheckIfDefaultPolicyPartitionExists(defaultPartitionName, scaleVol.VolBackendFs) </span><span class="cov0" title="0">{
                        glog.Infof("createvolume: setting default policy partition rule")

                        dataTierName, err := scaleVol.Connector.GetFirstDataTier(scaleVol.VolBackendFs)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, status.Error(codes.Unavailable, fmt.Sprintf("tier info request could not be completed: filesystemName %s", scaleVol.VolBackendFs))
                        }</span>
                        <span class="cov0" title="0">defaultPolicy := connectors.Policy{}
                        defaultPolicy.Policy = fmt.Sprintf("RULE 'csi-defaultRule' SET POOL '%s'", dataTierName)
                        defaultPolicy.Priority = 5
                        defaultPolicy.Partition = defaultPartitionName
                        err = scaleVol.Connector.SetFilesystemPolicy(&amp;defaultPolicy, scaleVol.VolBackendFs)
                        if err != nil </span><span class="cov0" title="0">{
                                glog.Errorf("volume:[%v] - setting default policy failed [%v]", volName, err)
                                return nil, err
                        }</span>
                }
        }

        <span class="cov0" title="0">volReqInProcess, err := cs.IfSameVolReqInProcess(scaleVol)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if volReqInProcess </span><span class="cov0" title="0">{
                glog.Errorf("volume:[%v] - volume creation already in process ", scaleVol.VolName)
                return nil, status.Error(codes.Aborted, fmt.Sprintf("volume creation already in process : %v", scaleVol.VolName))
        }</span>
        <span class="cov0" title="0">if isVolSource </span><span class="cov0" title="0">{
                jobDetails, found := cs.Driver.volcopyjobstatusmap.Load(scaleVol.VolName)
                if found </span><span class="cov0" title="0">{
                        jobStatus := jobDetails.(VolCopyJobDetails).jobStatus
                        volID := jobDetails.(VolCopyJobDetails).volID
                        glog.V(5).Infof("volume: [%v] found in volcopyjobstatusmap with volID: [%v], jobStatus: [%v]", scaleVol.VolName, volID, jobStatus)
                        switch jobStatus </span>{
                        case VOLCOPY_JOB_RUNNING:<span class="cov0" title="0">
                                glog.Errorf("volume:[%v] -  volume cloning request in progress.", scaleVol.VolName)
                                return nil, status.Error(codes.Aborted, fmt.Sprintf("volume cloning request in progress for volume: %s", scaleVol.VolName))</span>
                        case VOLCOPY_JOB_FAILED:<span class="cov0" title="0">
                                glog.Errorf("volume:[%v] -  volume cloning job had failed", scaleVol.VolName)
                                return nil, status.Error(codes.Internal, fmt.Sprintf("volume cloning job had failed for volume:[%v]", scaleVol.VolName))</span>
                        case VOLCOPY_JOB_COMPLETED:<span class="cov0" title="0">
                                glog.V(5).Infof("volume:[%v] -  volume cloning request has already completed successfully.", scaleVol.VolName)
                                return &amp;csi.CreateVolumeResponse{
                                        Volume: &amp;csi.Volume{
                                                VolumeId:      volID,
                                                CapacityBytes: int64(scaleVol.VolSize),
                                                VolumeContext: req.GetParameters(),
                                                ContentSource: volSrc,
                                        },
                                }, nil</span>
                        case JOB_STATUS_UNKNOWN:<span class="cov0" title="0">
                                //Remove the entry from map, so that it can be retried
                                glog.V(5).Infof("volume:[%v] -  the status of volume cloning job is unknown.", scaleVol.VolName)
                                cs.Driver.volcopyjobstatusmap.Delete(scaleVol.VolName)</span>
                        }
                } else<span class="cov0" title="0"> {
                        glog.V(5).Infof("volume: [%v] not found in volcopyjobstatusmap", scaleVol.VolName)
                }</span>
        }

        <span class="cov0" title="0">if isSnapSource </span><span class="cov0" title="0">{
                jobDetails, found := cs.Driver.snapjobstatusmap.Load(scaleVol.VolName)
                if found </span><span class="cov0" title="0">{
                        jobStatus := jobDetails.(SnapCopyJobDetails).jobStatus
                        volID := jobDetails.(SnapCopyJobDetails).volID
                        glog.V(5).Infof("volume: [%v] found in snapjobstatusmap with volID: [%v], jobStatus: [%v]", scaleVol.VolName, volID, jobStatus)
                        switch jobStatus </span>{
                        case SNAP_JOB_RUNNING:<span class="cov0" title="0">
                                glog.Errorf("volume:[%v] -  snapshot copy request in progress for snapshot: %s.", scaleVol.VolName, snapIdMembers.SnapName)
                                return nil, status.Error(codes.Aborted, fmt.Sprintf("snapshot copy request in progress for snapshot: %s", snapIdMembers.SnapName))</span>
                        case SNAP_JOB_FAILED:<span class="cov0" title="0">
                                glog.Errorf("volume:[%v] -  snapshot copy job had failed for snapshot %s", scaleVol.VolName, snapIdMembers.SnapName)
                                return nil, status.Error(codes.Internal, fmt.Sprintf("snapshot copy job had failed for snapshot: %s", snapIdMembers.SnapName))</span>
                        case SNAP_JOB_COMPLETED:<span class="cov0" title="0">
                                glog.V(5).Infof("volume:[%v] -  snapshot copy request has already completed successfully for snapshot: %s", scaleVol.VolName, snapIdMembers.SnapName)
                                return &amp;csi.CreateVolumeResponse{
                                        Volume: &amp;csi.Volume{
                                                VolumeId:      volID,
                                                CapacityBytes: int64(scaleVol.VolSize),
                                                VolumeContext: req.GetParameters(),
                                                ContentSource: volSrc,
                                        },
                                }, nil</span>
                        case JOB_STATUS_UNKNOWN:<span class="cov0" title="0">
                                //Remove the entry from map, so that it can be retried
                                glog.V(5).Infof("volume:[%v] -  the status of snapshot copy job for snapshot [%s] is unknown", scaleVol.VolName, snapIdMembers.SnapName)
                                cs.Driver.snapjobstatusmap.Delete(scaleVol.VolName)</span>
                        }
                } else<span class="cov0" title="0"> {
                        glog.V(5).Infof("volume: [%v] not found in snapjobstatusmap", scaleVol.VolName)
                }</span>
        }

        <span class="cov0" title="0">if scaleVol.VolPermissions != "" </span><span class="cov0" title="0">{
                versionCheck, err := cs.checkMinScaleVersion(scaleVol.Connector, "5112")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, status.Error(codes.Internal, fmt.Sprintf("the minimum Spectrum Scale version check for permissions failed with error %s", err))
                }</span>
                <span class="cov0" title="0">if !versionCheck </span><span class="cov0" title="0">{
                        return nil, status.Error(codes.Internal, "the minimum required Spectrum Scale version for permissions support with CSI is 5.1.1-2")
                }</span>
        }

        /* Update driver map with new volume. Make sure to defer delete */

        <span class="cov0" title="0">cs.Driver.reqmap[scaleVol.VolName] = int64(scaleVol.VolSize)
        defer delete(cs.Driver.reqmap, scaleVol.VolName)

        var targetPath string

        if scaleVol.IsFilesetBased </span><span class="cov0" title="0">{
                targetPath, err = cs.createFilesetBasedVol(scaleVol, isNewVolumeType)
        }</span> else<span class="cov0" title="0"> {
                targetPath, err = cs.createLWVol(scaleVol)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if !isNewVolumeType </span><span class="cov0" title="0">{
                // Create symbolic link if not present
                err = cs.createSoftlink(scaleVol, targetPath)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, status.Error(codes.Internal, err.Error())
                }</span>
        }

        <span class="cov0" title="0">volID, volIDErr := cs.generateVolID(scaleVol, volFsInfo.UUID, isNewVolumeType, targetPath)
        if volIDErr != nil </span><span class="cov0" title="0">{
                return nil, volIDErr
        }</span>

        <span class="cov0" title="0">if isVolSource </span><span class="cov0" title="0">{
                err = cs.copyVolumeContent(scaleVol, srcVolumeIDMembers, volFsInfo, targetPath, volID)
                if err != nil </span><span class="cov0" title="0">{
                        glog.Errorf("CreateVolume [%s]: [%v]", volName, err)
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">if isSnapSource </span><span class="cov0" title="0">{
                err = cs.copySnapContent(scaleVol, snapIdMembers, volFsInfo, targetPath, volID)
                if err != nil </span><span class="cov0" title="0">{
                        glog.Errorf("createVolume failed while copying snapshot content [%s]: [%v]", volName, err)
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">return &amp;csi.CreateVolumeResponse{
                Volume: &amp;csi.Volume{
                        VolumeId:      volID,
                        CapacityBytes: int64(scaleVol.VolSize),
                        VolumeContext: req.GetParameters(),
                        ContentSource: volSrc,
                },
        }, nil</span>
}

func (cs *ScaleControllerServer) copySnapContent(scVol *scaleVolume, snapId scaleSnapId, fsDetails connectors.FileSystem_v2, targetPath string, volID string) error <span class="cov0" title="0">{
        glog.V(3).Infof("copySnapContent snapId: [%v], scaleVolume: [%v]", snapId, scVol)
        conn, err := cs.getConnFromClusterID(snapId.ClusterId)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        //err = cs.validateRemoteFs(fsDetails, scVol)
        //if err != nil {
        //        return err
        //}

        <span class="cov0" title="0">targetFsName, err := conn.GetFilesystemName(fsDetails.UUID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">targetFsDetails, err := conn.GetFilesystemDetails(targetFsName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">fsMntPt := targetFsDetails.Mount.MountPoint
        targetPath = fmt.Sprintf("%s/%s", fsMntPt, targetPath)

        snapIDPath := snapId.Path
        filesetForCopy := snapId.FsetName
        if snapId.StorageClassType == STORAGECLASS_ADVANCED </span><span class="cov0" title="0">{
                snapIDPath = fmt.Sprintf("/%s", snapId.FsetName)
                filesetForCopy = snapId.ConsistencyGroup
        }</span>
        <span class="cov0" title="0">jobStatus, jobID, err := conn.CopyFsetSnapshotPath(snapId.FsName, filesetForCopy, snapId.SnapName, snapIDPath, targetPath, scVol.NodeClass)
        if err != nil </span><span class="cov0" title="0">{
                glog.Errorf("failed to create volume from snapshot %s: [%v]", snapId.SnapName, err)
                return status.Error(codes.Internal, fmt.Sprintf("failed to create volume from snapshot %s: [%v]", snapId.SnapName, err))

        }</span>

        <span class="cov0" title="0">jobDetails := SnapCopyJobDetails{SNAP_JOB_RUNNING, volID}
        cs.Driver.snapjobstatusmap.Store(scVol.VolName, jobDetails)

        isResponseStatusUnknown := false
        response, err := conn.WaitForJobCompletionWithResp(jobStatus, jobID)
        if len(response.Jobs) != 0 </span><span class="cov0" title="0">{
                if response.Jobs[0].Status == ResponseStatusUnknown </span><span class="cov0" title="0">{
                        isResponseStatusUnknown = true
                }</span>
        }
        <span class="cov0" title="0">if err != nil || isResponseStatusUnknown </span><span class="cov0" title="0">{
                glog.Errorf("unable to copy snapshot %s: %v.", snapId.SnapName, err)
                if err != nil &amp;&amp; strings.Contains(err.Error(), "EFSSG0632C") </span><span class="cov0" title="0">{
                        //TODO: When the GUI issue https://jazz07.rchland.ibm.com:21443/jazz/web/projects/GPFS#action=com.ibm.team.workitem.viewWorkItem&amp;id=300263
                        // is fixed, check whether the err.Error() says mmxcp is already running for the same
                        // source and destination and then set the job status as SNAP_JOB_RUNNING, so that
                        // mmxcp is not run again for the same source and destination.

                        // EFSSG0632C = Command execution aborted
                        // Store SNAP_JOB_NOT_STARTED in snapjobstatusmap if error was due to same mmxcp in progress
                        // or max no. of mmxcp already running. In these cases we want to retry again
                        // in the next k8s rety cycle
                        jobDetails.jobStatus = SNAP_JOB_NOT_STARTED
                }</span> else<span class="cov0" title="0"> if isResponseStatusUnknown </span><span class="cov0" title="0">{
                        jobDetails.jobStatus = JOB_STATUS_UNKNOWN
                }</span> else<span class="cov0" title="0"> {
                        jobDetails.jobStatus = SNAP_JOB_FAILED
                }</span>
                <span class="cov0" title="0">cs.Driver.snapjobstatusmap.Store(scVol.VolName, jobDetails)
                return err</span>
        }

        <span class="cov0" title="0">glog.Infof("copy snapshot completed for snapId: [%v], scaleVolume: [%v]", snapId, scVol)
        jobDetails.jobStatus = SNAP_JOB_COMPLETED
        cs.Driver.snapjobstatusmap.Store(scVol.VolName, jobDetails)
        //delete(cs.Driver.snapjobmap, scVol.VolName)
        return nil</span>
}

func (cs *ScaleControllerServer) copyVolumeContent(newvolume *scaleVolume, sourcevolume scaleVolId, fsDetails connectors.FileSystem_v2, targetPath string, volID string) error <span class="cov0" title="0">{
        glog.V(3).Infof("copyVolContent volume ID: [%v], scaleVolume: [%v], volume name: [%v]", sourcevolume, newvolume, newvolume.VolName)
        conn, err := cs.getConnFromClusterID(sourcevolume.ClusterId)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // err = cs.validateRemoteFs(fsDetails, scVol)
        // if err != nil {
        //         return err
        // }

        <span class="cov0" title="0">targetFsName, err := conn.GetFilesystemName(fsDetails.UUID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">targetFsDetails, err := conn.GetFilesystemDetails(targetFsName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">fsMntPt := targetFsDetails.Mount.MountPoint
        targetPath = fmt.Sprintf("%s/%s", fsMntPt, targetPath)

        jobDetails := VolCopyJobDetails{VOLCOPY_JOB_NOT_STARTED, volID}
        response := connectors.GenericResponse{}
        if newvolume.IsFilesetBased </span><span class="cov0" title="0">{
                path := ""
                if sourcevolume.StorageClassType == STORAGECLASS_ADVANCED </span><span class="cov0" title="0">{
                        path = "/"
                }</span> else<span class="cov0" title="0"> {
                        path = fmt.Sprintf("%s%s", sourcevolume.FsetName, "-data")
                }</span>

                <span class="cov0" title="0">jobStatus, jobID, jobErr := conn.CopyFilesetPath(sourcevolume.FsName, sourcevolume.FsetName, path, targetPath, newvolume.NodeClass)
                if jobErr != nil </span><span class="cov0" title="0">{
                        glog.Errorf("failed to clone volume from volume. Error: [%v]", jobErr)
                        return status.Error(codes.Internal, fmt.Sprintf("failed to clone volume from volume. Error: [%v]", jobErr))
                }</span>

                <span class="cov0" title="0">jobDetails = VolCopyJobDetails{VOLCOPY_JOB_RUNNING, volID}
                cs.Driver.volcopyjobstatusmap.Store(newvolume.VolName, jobDetails)
                response, err = conn.WaitForJobCompletionWithResp(jobStatus, jobID)</span>
        } else<span class="cov0" title="0"> {
                sLinkRelPath := strings.Replace(sourcevolume.Path, cs.Driver.primary.PrimaryFSMount, "", 1)
                sLinkRelPath = strings.Trim(sLinkRelPath, "!/")

                jobStatus, jobID, jobErr := conn.CopyDirectoryPath(sourcevolume.FsName, sLinkRelPath, targetPath, newvolume.NodeClass)

                if jobErr != nil </span><span class="cov0" title="0">{
                        glog.Errorf("failed to clone volume from volume. Error: [%v]", jobErr)
                        return status.Error(codes.Internal, fmt.Sprintf("failed to clone volume from volume. Error: [%v]", jobErr))
                }</span>

                <span class="cov0" title="0">jobDetails = VolCopyJobDetails{VOLCOPY_JOB_RUNNING, volID}
                cs.Driver.volcopyjobstatusmap.Store(newvolume.VolName, jobDetails)
                response, err = conn.WaitForJobCompletionWithResp(jobStatus, jobID)</span>
        }
        <span class="cov0" title="0">isResponseStatusUnknown := false
        if len(response.Jobs) != 0 </span><span class="cov0" title="0">{
                if response.Jobs[0].Status == ResponseStatusUnknown </span><span class="cov0" title="0">{
                        isResponseStatusUnknown = true
                }</span>
        }
        <span class="cov0" title="0">if err != nil || isResponseStatusUnknown </span><span class="cov0" title="0">{
                glog.Errorf("unable to copy volume: %v.", err)
                if err != nil &amp;&amp; strings.Contains(err.Error(), "EFSSG0632C") </span><span class="cov0" title="0">{
                        //TODO: When the GUI issue https://jazz07.rchland.ibm.com:21443/jazz/web/projects/GPFS#action=com.ibm.team.workitem.viewWorkItem&amp;id=300263
                        // is fixed, check whether the err.Error() says mmxcp is already running for the same
                        // source and destination and then set the job status as VOLCOPY_JOB_RUNNING, so that
                        // mmxcp is not run again for the same source and destination.

                        // EFSSG0632C = Command execution aborted
                        // Store VOLCOPY_JOB_NOT_STARTED in volcopyjobstatusmap if error was due to same mmxcp in progress
                        // or max no. of mmxcp already running. In these cases we want to retry again
                        // in the next k8s rety cycle
                        jobDetails.jobStatus = VOLCOPY_JOB_NOT_STARTED
                }</span> else<span class="cov0" title="0"> if isResponseStatusUnknown </span><span class="cov0" title="0">{
                        jobDetails.jobStatus = JOB_STATUS_UNKNOWN
                }</span> else<span class="cov0" title="0"> {
                        jobDetails.jobStatus = VOLCOPY_JOB_FAILED
                }</span>
                <span class="cov0" title="0">glog.Errorf("logging volume cloning error for VolName: [%v] Error: [%v] JobDetails: [%v]", newvolume.VolName, err, jobDetails)
                cs.Driver.volcopyjobstatusmap.Store(newvolume.VolName, jobDetails)
                return err</span>
        }

        <span class="cov0" title="0">glog.Infof("volume copy completed for volumeID: [%v], scaleVolume: [%v]", sourcevolume, newvolume)
        jobDetails.jobStatus = VOLCOPY_JOB_COMPLETED
        cs.Driver.volcopyjobstatusmap.Store(newvolume.VolName, jobDetails)
        //delete(cs.Driver.volcopyjobstatusmap, scVol.VolName)
        return nil</span>
}

func (cs *ScaleControllerServer) checkMinScaleVersion(conn connectors.SpectrumScaleConnector, version string) (bool, error) <span class="cov0" title="0">{
        scaleVersion, err := conn.GetScaleVersion()
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        /* Assuming Spectrum Scale version is in a format like 5.0.0-0_170818.165000 */
        // "serverVersion" : "5.1.1.1-developer build",
        <span class="cov0" title="0">splitScaleVer := strings.Split(scaleVersion, ".")
        if len(splitScaleVer) &lt; 3 </span><span class="cov0" title="0">{
                return false, status.Error(codes.Internal, fmt.Sprintf("invalid Spectrum Scale version - %s", scaleVersion))
        }</span>
        <span class="cov0" title="0">var splitMinorVer []string
        assembledScaleVer := ""
        if len(splitScaleVer) == 4 </span><span class="cov0" title="0">{
                //dev build e.g. "5.1.5.0-developer build"
                splitMinorVer = strings.Split(splitScaleVer[3], "-")
                assembledScaleVer = splitScaleVer[0] + splitScaleVer[1] + splitScaleVer[2] + splitMinorVer[0]
        }</span> else<span class="cov0" title="0"> {
                //GA build e.g. "5.1.5-0"
                splitMinorVer = strings.Split(splitScaleVer[2], "-")
                assembledScaleVer = splitScaleVer[0] + splitScaleVer[1] + splitMinorVer[0] + splitMinorVer[1][0:1]
        }</span>
        <span class="cov0" title="0">if assembledScaleVer &lt; version </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">return true, nil</span>
}

func (cs *ScaleControllerServer) checkMinFsVersion(fsVersion string, version string) bool <span class="cov0" title="0">{
        /* Assuming Filesystem version (fsVersion) in a format like 27.00 and version as 2700 */
        assembledFsVer := strings.ReplaceAll(fsVersion, ".", "")

        glog.Infof("fs version (%s) vs min required version (%s)", assembledFsVer, version)
        if assembledFsVer &lt; version </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

func (cs *ScaleControllerServer) checkSnapshotSupport(conn connectors.SpectrumScaleConnector) error <span class="cov0" title="0">{
        /* Verify Spectrum Scale Version is not below 5.1.1-0 */
        versionCheck, err := cs.checkMinScaleVersion(conn, "5110")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !versionCheck </span><span class="cov0" title="0">{
                return status.Error(codes.FailedPrecondition, "the minimum required Spectrum Scale version for snapshot support with CSI is 5.1.1-0")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (cs *ScaleControllerServer) checkVolCloneSupport(conn connectors.SpectrumScaleConnector) error <span class="cov0" title="0">{
        /* Verify Spectrum Scale Version is not below 5.1.2-1 */
        versionCheck, err := cs.checkMinScaleVersion(conn, "5121")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !versionCheck </span><span class="cov0" title="0">{
                return status.Error(codes.FailedPrecondition, "the minimum required Spectrum Scale version for volume cloning support with CSI is 5.1.2-1")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (cs *ScaleControllerServer) checkVolTierSupport(version string) error <span class="cov0" title="0">{
        /* Verify Spectrum Scale Filesystem Version is not below 5.1.3-0 (27.00) */

        versionCheck := cs.checkMinFsVersion(version, "2700")

        if !versionCheck </span><span class="cov0" title="0">{
                return status.Error(codes.FailedPrecondition, "the minimum required Spectrum Scale Filesystem version for tiering support with CSI is 27.00 (5.1.3-0)")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (cs *ScaleControllerServer) checkCGSupport(conn connectors.SpectrumScaleConnector) error <span class="cov0" title="0">{
        /* Verify Spectrum Scale Version is not below 5.1.3-0 */

        versionCheck, err := cs.checkMinScaleVersion(conn, "5130")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !versionCheck </span><span class="cov0" title="0">{
                return status.Error(codes.FailedPrecondition, "the minimum required Spectrum Scale version for consistency group support with CSI is 5.1.3-0")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (cs *ScaleControllerServer) checkGuiHASupport(conn connectors.SpectrumScaleConnector) error <span class="cov0" title="0">{
        /* Verify Spectrum Scale Version is not below 5.1.5-0 */

        versionCheck, err := cs.checkMinScaleVersion(conn, "5150")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !versionCheck </span><span class="cov0" title="0">{
                return status.Error(codes.FailedPrecondition, "the minimum required Spectrum Scale version for GUI HA support with CSI is 5.1.5-0")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (cs *ScaleControllerServer) validateSnapId(sourcesnapshot *scaleSnapId, newvolume *scaleVolume, pCid string) error <span class="cov0" title="0">{
        glog.V(3).Infof("validateSnapId [%v]", sourcesnapshot)
        conn, err := cs.getConnFromClusterID(sourcesnapshot.ClusterId)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Restrict cross cluster cloning
        <span class="cov0" title="0">if newvolume.ClusterId != sourcesnapshot.ClusterId </span><span class="cov0" title="0">{
                return status.Error(codes.Unimplemented, "creating volume from snapshot across clusters is not supported")
        }</span>

        // Restrict cross storage class version volume from snapshot
        // if len(newvolume.StorageClassType) != 0 || len(sourcesnapshot.StorageClassType) != 0 {
        //         if newvolume.StorageClassType != sourcesnapshot.StorageClassType {
        //                 return status.Error(codes.Unimplemented, "creating volume from snapshot between different version of storageClass is not supported")
        //         }
        // }

        // Restrict creating LW volume from snapshot
        // if !newvolume.IsFilesetBased {
        //         return status.Error(codes.Unimplemented, "creating lightweight volume from snapshot is not supported")
        // }

        // // Restrict creating dependent fileset based volume from snapshot
        // if newvolume.StorageClassType == STORAGECLASS_CLASSIC &amp;&amp; newvolume.FilesetType == dependentFileset {
        //         return status.Error(codes.Unimplemented, "creating dependent fileset based volume from snapshot is not supported")
        // }

        /* Check if Spectrum Scale supports Snapshot */
        <span class="cov0" title="0">chkSnapshotErr := cs.checkSnapshotSupport(conn)
        if chkSnapshotErr != nil </span><span class="cov0" title="0">{
                return chkSnapshotErr
        }</span>

        <span class="cov0" title="0">if newvolume.NodeClass != "" </span><span class="cov0" title="0">{
                isValidNodeclass, err := conn.IsValidNodeclass(newvolume.NodeClass)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if !isValidNodeclass </span><span class="cov0" title="0">{
                        return status.Error(codes.NotFound, fmt.Sprintf("nodeclass [%s] not found on cluster [%v]", newvolume.NodeClass, newvolume.ClusterId))
                }</span>
        }

        <span class="cov0" title="0">sourcesnapshot.FsName, err = conn.GetFilesystemName(sourcesnapshot.FsUUID)

        if err != nil </span><span class="cov0" title="0">{
                return status.Error(codes.Internal, fmt.Sprintf("unable to get filesystem Name for Id [%v] and clusterId [%v]. Error [%v]", sourcesnapshot.FsUUID, sourcesnapshot.ClusterId, err))
        }</span>

        <span class="cov0" title="0">if sourcesnapshot.FsName != newvolume.VolBackendFs </span><span class="cov0" title="0">{
                isFsMounted, err := conn.IsFilesystemMountedOnGUINode(sourcesnapshot.FsName)
                if err != nil </span><span class="cov0" title="0">{
                        return status.Error(codes.Internal, fmt.Sprintf("error in getting filesystem mount details for %s", sourcesnapshot.FsName))
                }</span>
                <span class="cov0" title="0">if !isFsMounted </span><span class="cov0" title="0">{
                        return status.Error(codes.Internal, fmt.Sprintf("filesystem %s is not mounted on GUI node", sourcesnapshot.FsName))
                }</span>
        }

        <span class="cov0" title="0">filesetToCheck := sourcesnapshot.FsetName
        if sourcesnapshot.StorageClassType == STORAGECLASS_ADVANCED </span><span class="cov0" title="0">{
                filesetToCheck = sourcesnapshot.ConsistencyGroup
        }</span>
        <span class="cov0" title="0">isFsetLinked, err := conn.IsFilesetLinked(sourcesnapshot.FsName, filesetToCheck)
        if err != nil </span><span class="cov0" title="0">{
                return status.Error(codes.Internal, fmt.Sprintf("unable to get fileset link information for [%v]", filesetToCheck))
        }</span>
        <span class="cov0" title="0">if !isFsetLinked </span><span class="cov0" title="0">{
                return status.Error(codes.Internal, fmt.Sprintf("fileset [%v] of source snapshot is not linked", filesetToCheck))
        }</span>

        <span class="cov0" title="0">isSnapExist, err := conn.CheckIfSnapshotExist(sourcesnapshot.FsName, filesetToCheck, sourcesnapshot.SnapName)
        if err != nil </span><span class="cov0" title="0">{
                return status.Error(codes.Internal, fmt.Sprintf("unable to get snapshot information for [%v]", sourcesnapshot.SnapName))
        }</span>
        <span class="cov0" title="0">if !isSnapExist </span><span class="cov0" title="0">{
                return status.Error(codes.Internal, fmt.Sprintf("snapshot [%v] does not exist for fileset [%v]", sourcesnapshot.SnapName, filesetToCheck))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (cs *ScaleControllerServer) validateCloneRequest(sourcevolume *scaleVolId, newvolume *scaleVolume, pCid string, volFsInfo connectors.FileSystem_v2) error <span class="cov0" title="0">{
        glog.V(3).Infof("validateVolId [%v]", sourcevolume)

        conn, err := cs.getConnFromClusterID(sourcevolume.ClusterId)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // This is kind of snapshot restore
        <span class="cov0" title="0">chkVolCloneErr := cs.checkVolCloneSupport(conn)
        if chkVolCloneErr != nil </span><span class="cov0" title="0">{
                return chkVolCloneErr
        }</span>

        // Restrict cross cluster cloning
        <span class="cov0" title="0">if newvolume.ClusterId != sourcevolume.ClusterId </span><span class="cov0" title="0">{
                return status.Error(codes.Unimplemented, "cloning of volume across clusters is not supported")
        }</span>

        // Restrict cross storage class version
        <span class="cov0" title="0">if len(newvolume.StorageClassType) != 0 || len(sourcevolume.StorageClassType) != 0 </span><span class="cov0" title="0">{
                if newvolume.StorageClassType != sourcevolume.StorageClassType </span><span class="cov0" title="0">{
                        return status.Error(codes.Unimplemented, "cloning of volumes between different version of storageClass is not supported")
                }</span>
        }

        // Restrict cloning LW to Fileset based or vise a versa
        <span class="cov0" title="0">if newvolume.IsFilesetBased != sourcevolume.IsFilesetBased </span><span class="cov0" title="0">{
                return status.Error(codes.Unimplemented, "cloning of directory based volume to fileset based volume or vice a versa is not supported")
        }</span>

        // Restrict if new volune is lw and is from remote
        <span class="cov0" title="0">if !newvolume.IsFilesetBased </span><span class="cov0" title="0">{
                if volFsInfo.Type == filesystemTypeRemote </span><span class="cov0" title="0">{
                        return status.Error(codes.Unimplemented, "Volume cloning for directories for remote file system is not supported")
                }</span>
        }

        <span class="cov0" title="0">sourcevolume.FsName, err = conn.GetFilesystemName(sourcevolume.FsUUID)
        if err != nil </span><span class="cov0" title="0">{
                return status.Error(codes.Internal, fmt.Sprintf("unable to get filesystem Name for Id [%v] and clusterId [%v]. Error [%v]", sourcevolume.FsUUID, sourcevolume.ClusterId, err))
        }</span>

        <span class="cov0" title="0">sourceFsDetails, err := conn.GetFilesystemDetails(sourcevolume.FsName)
        if err != nil </span><span class="cov0" title="0">{
                return status.Error(codes.Internal, fmt.Sprintf("error in getting filesystem mount details for %s", sourcevolume.FsName))
        }</span>

        // restrict remote lw to local lw cloning
        <span class="cov0" title="0">if !sourcevolume.IsFilesetBased &amp;&amp; sourceFsDetails.Type == filesystemTypeRemote </span><span class="cov0" title="0">{
                return status.Error(codes.Unimplemented, "cloning of directory based volume belonging to remote cluster is not supported")
        }</span>

        <span class="cov0" title="0">if sourcevolume.FsName != newvolume.VolBackendFs </span><span class="cov0" title="0">{
                if sourceFsDetails.Mount.Status != "mounted" </span><span class="cov0" title="0">{
                        return status.Error(codes.Internal, fmt.Sprintf("filesystem %s is not mounted on GUI node", sourcevolume.FsName))
                }</span>
        }

        <span class="cov0" title="0">if sourcevolume.IsFilesetBased </span><span class="cov0" title="0">{
                if sourcevolume.FsetName == "" </span><span class="cov0" title="0">{
                        sourcevolume.FsetName, err = conn.GetFileSetNameFromId(sourcevolume.FsName, sourcevolume.FsetId)
                        if err != nil </span><span class="cov0" title="0">{
                                return status.Error(codes.Internal, fmt.Sprintf("error in getting fileset details for %s", sourcevolume.FsetId))
                        }</span>
                }

                <span class="cov0" title="0">isFsetLinked, err := conn.IsFilesetLinked(sourcevolume.FsName, sourcevolume.FsetName)
                if err != nil </span><span class="cov0" title="0">{
                        return status.Error(codes.Internal, fmt.Sprintf("unable to get fileset link information for [%v]", sourcevolume.FsetName))
                }</span>
                <span class="cov0" title="0">if !isFsetLinked </span><span class="cov0" title="0">{
                        return status.Error(codes.Internal, fmt.Sprintf("fileset [%v] of source volume is not linked", sourcevolume.FsetName))
                }</span>
        }

        <span class="cov0" title="0">if newvolume.NodeClass != "" </span><span class="cov0" title="0">{
                isValidNodeclass, err := conn.IsValidNodeclass(newvolume.NodeClass)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if !isValidNodeclass </span><span class="cov0" title="0">{
                        return status.Error(codes.NotFound, fmt.Sprintf("nodeclass [%s] not found on cluster [%v]", newvolume.NodeClass, newvolume.ClusterId))
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (cs *ScaleControllerServer) GetSnapIdMembers(sId string) (scaleSnapId, error) <span class="cov0" title="0">{
        splitSid := strings.Split(sId, ";")
        var sIdMem scaleSnapId

        if len(splitSid) &lt; 4 </span><span class="cov0" title="0">{
                return scaleSnapId{}, status.Error(codes.Internal, fmt.Sprintf("Invalid Snapshot Id : [%v]", sId))
        }</span>

        <span class="cov0" title="0">if len(splitSid) &gt;= 8 </span><span class="cov0" title="0">{
                /* storageclass_type;volumeType;clusterId;FSUUID;consistency_group;filesetName;snapshotName;path */
                sIdMem.StorageClassType = splitSid[0]
                sIdMem.VolType = splitSid[1]
                sIdMem.ClusterId = splitSid[2]
                sIdMem.FsUUID = splitSid[3]
                sIdMem.ConsistencyGroup = splitSid[4]
                sIdMem.FsetName = splitSid[5]
                sIdMem.SnapName = splitSid[6]
                sIdMem.MetaSnapName = splitSid[7]
                if len(splitSid) == 9 &amp;&amp; splitSid[8] != "" </span><span class="cov0" title="0">{
                        sIdMem.Path = splitSid[8]
                }</span> else<span class="cov0" title="0"> {
                        sIdMem.Path = "/"
                }</span>
        } else<span class="cov0" title="0"> {
                /* clusterId;FSUUID;filesetName;snapshotName;path */
                sIdMem.ClusterId = splitSid[0]
                sIdMem.FsUUID = splitSid[1]
                sIdMem.FsetName = splitSid[2]
                sIdMem.SnapName = splitSid[3]
                if len(splitSid) == 5 &amp;&amp; splitSid[4] != "" </span><span class="cov0" title="0">{
                        sIdMem.Path = splitSid[4]
                }</span> else<span class="cov0" title="0"> {
                        sIdMem.Path = "/"
                }</span>
                <span class="cov0" title="0">sIdMem.StorageClassType = STORAGECLASS_CLASSIC</span>
        }
        <span class="cov0" title="0">return sIdMem, nil</span>
}

func (cs *ScaleControllerServer) DeleteFilesetVol(FilesystemName string, FilesetName string, volumeIdMembers scaleVolId, conn connectors.SpectrumScaleConnector) (bool, error) <span class="cov0" title="0">{
        //Check if fileset exist has any snapshot
        snapshotList, err := conn.ListFilesetSnapshots(FilesystemName, FilesetName)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "EFSSG0072C") ||
                        strings.Contains(err.Error(), "400 Invalid value in 'filesetName'") </span><span class="cov0" title="0">{ // fileset is already deleted
                        glog.V(4).Infof("fileset seems already deleted - %v", err)
                        return true, nil
                }</span>
                <span class="cov0" title="0">return false, status.Error(codes.Internal, fmt.Sprintf("unable to list snapshot for fileset [%v]. Error: [%v]", FilesetName, err))</span>
        }

        <span class="cov0" title="0">if len(snapshotList) &gt; 0 </span><span class="cov0" title="0">{
                return false, status.Error(codes.Internal, fmt.Sprintf("volume fileset [%v] contains one or more snapshot, delete snapshot/volumesnapshot", FilesetName))
        }</span>
        <span class="cov0" title="0">glog.V(4).Infof("there is no snapshot present in the fileset [%v], continue DeleteFilesetVol", FilesetName)

        err = conn.DeleteFileset(FilesystemName, FilesetName)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "EFSSG0072C") ||
                        strings.Contains(err.Error(), "400 Invalid value in 'filesetName'") </span><span class="cov0" title="0">{ // fileset is already deleted
                        glog.V(4).Infof("fileset seems already deleted - %v", err)
                        return true, nil
                }</span>
                <span class="cov0" title="0">return false, status.Error(codes.Internal, fmt.Sprintf("unable to Delete Fileset [%v] for FS [%v] and clusterId [%v].Error : [%v]", FilesetName, FilesystemName, volumeIdMembers.ClusterId, err))</span>
        }
        <span class="cov0" title="0">return false, nil</span>
}

// This function deletes fileset for Consitency Group
func (cs *ScaleControllerServer) DeleteCGFileset(FilesystemName string, volumeIdMembers scaleVolId, conn connectors.SpectrumScaleConnector) error <span class="cov0" title="0">{
        glog.V(4).Infof("trying to delete independent fileset for consistency group [%v]", volumeIdMembers.ConsistencyGroup)

        filesetDetails, err := conn.ListFileset(FilesystemName, volumeIdMembers.ConsistencyGroup)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "EFSSG0072C") ||
                        strings.Contains(err.Error(), "400 Invalid value in 'filesetName'") </span><span class="cov0" title="0">{ // fileset is already deleted
                        glog.V(4).Infof("fileset seems already deleted - %v", err)
                        return nil
                }</span>
                <span class="cov0" title="0">return status.Error(codes.Internal, fmt.Sprintf("unable to list fileset [%v]. Error: [%v]", volumeIdMembers.ConsistencyGroup, err))</span>
        }

        // Check if fileset was created by IBM Spectrum Scale CSI Driver
        <span class="cov0" title="0">if filesetDetails.Config.Comment == connectors.FilesetComment </span><span class="cov0" title="0">{
                // before deletion of fileset get its inodeSpace.
                // this will help to identify if there are one or more dependent filesets for same inodeSpace
                // which is shared with independent fileset
                inodeSpace := filesetDetails.Config.InodeSpace
                filesets, err := conn.GetFilesetsInodeSpace(FilesystemName, inodeSpace)
                if err != nil </span><span class="cov0" title="0">{
                        return status.Error(codes.Internal, fmt.Sprintf("listing of filesets for filesystem: [%v] failed. Error: [%v]", FilesystemName, err))
                }</span>

                <span class="cov0" title="0">if len(filesets) &gt; 1 </span><span class="cov0" title="0">{
                        glog.V(4).Infof("found atleast one dependent fileset for consistency group: [%v]", volumeIdMembers.ConsistencyGroup)
                        return nil
                }</span>

                // Delete independent fileset for consistency group
                <span class="cov0" title="0">_, err = cs.DeleteFilesetVol(FilesystemName, volumeIdMembers.ConsistencyGroup, volumeIdMembers, conn)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">glog.V(4).Infof("deleted independent fileset for consistency group [%v]", volumeIdMembers.ConsistencyGroup)</span>
        } else<span class="cov0" title="0"> {
                glog.V(4).Infof("independent fileset for consistency group [%v] not created by IBM Spectrum Scale CSI Driver. Cannot delete it.", volumeIdMembers.ConsistencyGroup)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (cs *ScaleControllerServer) DeleteVolume(ctx context.Context, req *csi.DeleteVolumeRequest) (*csi.DeleteVolumeResponse, error) <span class="cov0" title="0">{
        glog.V(3).Infof("DeleteVolume [%v]", req)

        if err := cs.Driver.ValidateControllerServiceRequest(csi.ControllerServiceCapability_RPC_CREATE_DELETE_VOLUME); err != nil </span><span class="cov0" title="0">{
                glog.Warningf("invalid delete volume req: %v", req)
                return nil, status.Error(codes.InvalidArgument,
                        fmt.Sprintf("invalid delete volume req (%v): %v", req, err))
        }</span>
        // For now the image get unconditionally deleted, but here retention policy can be checked
        <span class="cov0" title="0">volumeID := req.GetVolumeId()

        if volumeID == "" </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "volume Id is missing")
        }</span>

        <span class="cov0" title="0">volumeIdMembers, err := getVolIDMembers(volumeID)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;csi.DeleteVolumeResponse{}, nil
        }</span>

        <span class="cov0" title="0">glog.Infof("Volume Id Members [%v]", volumeIdMembers)

        conn, err := cs.getConnFromClusterID(volumeIdMembers.ClusterId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">primaryConn, isprimaryConnPresent := cs.Driver.connmap["primary"]
        if !isprimaryConnPresent </span><span class="cov0" title="0">{
                glog.Errorf("unable to get connector for primary cluster")
                return nil, status.Error(codes.Internal, "unable to find primary cluster details in custom resource")
        }</span>

        /* FsUUID in volumeIdMembers will be of Primary cluster. So lets get Name of it
           from Primary cluster */
        <span class="cov0" title="0">FilesystemName, err := primaryConn.GetFilesystemName(volumeIdMembers.FsUUID)

        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, fmt.Sprintf("unable to get filesystem Name for Id [%v] and clusterId [%v]. Error [%v]", volumeIdMembers.FsUUID, volumeIdMembers.ClusterId, err))
        }</span>

        <span class="cov0" title="0">mountInfo, err := primaryConn.GetFilesystemMountDetails(FilesystemName)

        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, fmt.Sprintf("unable to get mount info for FS [%v] in primary cluster", FilesystemName))
        }</span>

        <span class="cov0" title="0">relPath := ""
        if volumeIdMembers.StorageClassType == STORAGECLASS_ADVANCED </span><span class="cov0" title="0">{
                relPath = strings.Replace(volumeIdMembers.Path, mountInfo.MountPoint, "", 1)
        }</span> else<span class="cov0" title="0"> {
                relPath = strings.Replace(volumeIdMembers.Path, cs.Driver.primary.PrimaryFSMount, "", 1)
        }</span>
        <span class="cov0" title="0">relPath = strings.Trim(relPath, "!/")

        if volumeIdMembers.IsFilesetBased </span><span class="cov0" title="0">{
                var FilesetName string

                FilesystemName = getRemoteFsName(mountInfo.RemoteDeviceName)
                if volumeIdMembers.FsetName != "" </span><span class="cov0" title="0">{
                        FilesetName = volumeIdMembers.FsetName
                }</span> else<span class="cov0" title="0"> {
                        FilesetName, err = conn.GetFileSetNameFromId(FilesystemName, volumeIdMembers.FsetId)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, status.Error(codes.Internal, fmt.Sprintf("Unable to get Fileset Name for Id [%v] FS [%v] ClusterId [%v]", volumeIdMembers.FsetId, FilesystemName, volumeIdMembers.ClusterId))
                        }</span>
                }

                <span class="cov0" title="0">if FilesetName != "" </span><span class="cov0" title="0">{
                        /* Confirm it is same fileset which was created for this PV */
                        pvName := filepath.Base(relPath)
                        if pvName == FilesetName </span><span class="cov0" title="0">{
                                isFilesetAlreadyDel, err := cs.DeleteFilesetVol(FilesystemName, FilesetName, volumeIdMembers, conn)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>

                                // Delete fileset related symlink
                                <span class="cov0" title="0">if !isFilesetAlreadyDel &amp;&amp; volumeIdMembers.StorageClassType != STORAGECLASS_ADVANCED </span><span class="cov0" title="0">{
                                        err = primaryConn.DeleteSymLnk(cs.Driver.primary.GetPrimaryFs(), relPath)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, status.Error(codes.Internal, fmt.Sprintf("unable to delete symlnk [%v:%v] Error [%v]", cs.Driver.primary.GetPrimaryFs(), relPath, err))
                                        }</span>
                                }

                                <span class="cov0" title="0">if volumeIdMembers.StorageClassType == STORAGECLASS_ADVANCED </span><span class="cov0" title="0">{
                                        err := cs.DeleteCGFileset(FilesystemName, volumeIdMembers, conn)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, err
                                        }</span>
                                }
                                <span class="cov0" title="0">return &amp;csi.DeleteVolumeResponse{}, nil</span>
                        } else<span class="cov0" title="0"> {
                                glog.Infof("pv name from path [%v] does not match with filesetName [%v]. Skipping delete of fileset", pvName, FilesetName)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                /* Delete Dir for Lw volume */
                err = primaryConn.DeleteDirectory(cs.Driver.primary.GetPrimaryFs(), relPath, false)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, status.Error(codes.Internal, fmt.Sprintf("unable to Delete Dir using FS [%v] Relative SymLink [%v]. Error [%v]", FilesystemName, relPath, err))
                }</span>
        }

        <span class="cov0" title="0">if volumeIdMembers.StorageClassType != STORAGECLASS_ADVANCED </span><span class="cov0" title="0">{
                err = primaryConn.DeleteSymLnk(cs.Driver.primary.GetPrimaryFs(), relPath)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, status.Error(codes.Internal, fmt.Sprintf("unable to delete symlnk [%v:%v] Error [%v]", cs.Driver.primary.GetPrimaryFs(), relPath, err))
                }</span>
        }

        <span class="cov0" title="0">return &amp;csi.DeleteVolumeResponse{}, nil</span>
}

// ControllerGetCapabilities implements the default GRPC callout.
func (cs *ScaleControllerServer) ControllerGetCapabilities(ctx context.Context, req *csi.ControllerGetCapabilitiesRequest) (*csi.ControllerGetCapabilitiesResponse, error) <span class="cov0" title="0">{
        glog.V(4).Infof("ControllerGetCapabilities called with req: %#v", req)
        return &amp;csi.ControllerGetCapabilitiesResponse{
                Capabilities: cs.Driver.cscap,
        }, nil
}</span>

func (cs *ScaleControllerServer) ValidateVolumeCapabilities(ctx context.Context, req *csi.ValidateVolumeCapabilitiesRequest) (*csi.ValidateVolumeCapabilitiesResponse, error) <span class="cov0" title="0">{
        volumeID := req.GetVolumeId()

        if volumeID == "" </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "VolumeID not present")
        }</span>

        <span class="cov0" title="0">if len(req.VolumeCapabilities) == 0 </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "No volume capability specified")
        }</span>

        <span class="cov0" title="0">for _, cap := range req.VolumeCapabilities </span><span class="cov0" title="0">{
                if cap.GetAccessMode().GetMode() != csi.VolumeCapability_AccessMode_MULTI_NODE_MULTI_WRITER </span><span class="cov0" title="0">{
                        return &amp;csi.ValidateVolumeCapabilitiesResponse{Message: ""}, nil
                }</span>
        }
        <span class="cov0" title="0">return &amp;csi.ValidateVolumeCapabilitiesResponse{
                Confirmed: &amp;csi.ValidateVolumeCapabilitiesResponse_Confirmed{
                        VolumeCapabilities: req.VolumeCapabilities,
                },
        }, nil</span>
}

func (cs *ScaleControllerServer) ControllerUnpublishVolume(ctx context.Context, req *csi.ControllerUnpublishVolumeRequest) (*csi.ControllerUnpublishVolumeResponse, error) <span class="cov0" title="0">{
        glog.V(3).Infof("controllerserver ControllerUnpublishVolume")
        glog.V(4).Infof("ControllerUnpublishVolume : req %#v", req)

        if err := cs.Driver.ValidateControllerServiceRequest(csi.ControllerServiceCapability_RPC_PUBLISH_UNPUBLISH_VOLUME); err != nil </span><span class="cov0" title="0">{
                glog.V(3).Infof("invalid Unpublish volume request: %v", req)
                return nil, status.Error(codes.Internal, fmt.Sprintf("ControllerUnpublishVolume: ValidateControllerServiceRequest failed: %v", err))
        }</span>

        <span class="cov0" title="0">volumeID := req.GetVolumeId()
        _, err := getVolIDMembers(volumeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "ControllerUnpublishVolume : VolumeID is not in proper format")
        }</span>

        <span class="cov0" title="0">return &amp;csi.ControllerUnpublishVolumeResponse{}, nil</span>
}

func (cs *ScaleControllerServer) ControllerPublishVolume(ctx context.Context, req *csi.ControllerPublishVolumeRequest) (*csi.ControllerPublishVolumeResponse, error) <span class="cov0" title="0">{ //nolint:gocyclo,funlen
        glog.V(3).Infof("controllerserver ControllerPublishVolume")
        glog.V(4).Infof("ControllerPublishVolume : req %#v", req)

        if err := cs.Driver.ValidateControllerServiceRequest(csi.ControllerServiceCapability_RPC_PUBLISH_UNPUBLISH_VOLUME); err != nil </span><span class="cov0" title="0">{
                glog.V(3).Infof("invalid Publish volume request: %v", req)
                return nil, status.Error(codes.Internal, fmt.Sprintf("ControllerPublishVolume: ValidateControllerServiceRequest failed: %v", err))
        }</span>

        //ControllerPublishVolumeRequest{VolumeId:"934225357755027944;09762E35:5D26932A;path=/ibm/gpfs0/volume1", NodeId:"node4", VolumeCapability:(*csi.VolumeCapability)(0xc00005d6c0), Readonly:false, Secrets:map[string]string(nil), VolumeContext:map[string]string(nil), XXX_NoUnkeyedLiteral:struct {}{}, XXX_unrecognized:[]uint8(nil), XXX_sizecache:0}

        <span class="cov0" title="0">nodeID := req.GetNodeId()

        if nodeID == "" </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "NodeID not present")
        }</span>

        <span class="cov0" title="0">volumeID := req.GetVolumeId()

        if volumeID == "" </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "ControllerPublishVolume : VolumeID is not present")
        }</span>

        <span class="cov0" title="0">var isFsMounted bool

        //Assumption : filesystem_uuid is always from local/primary cluster.

        if req.VolumeCapability == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "ControllerPublishVolume :volume capabilities are empty")
        }</span>

        <span class="cov0" title="0">volumeIDMembers, err := getVolIDMembers(volumeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "ControllerPublishVolume : VolumeID is not in proper format")
        }</span>

        <span class="cov0" title="0">filesystemID := volumeIDMembers.FsUUID
        volumePath := volumeIDMembers.Path

        // if SKIP_MOUNT_UNMOUNT == "yes" then mount/unmount will not be invoked
        skipMountUnmount := utils.GetEnv(SKIP_MOUNT_UNMOUNT, yes)
        glog.V(4).Infof("ControllerPublishVolume : SKIP_MOUNT_UNMOUNT is set to %s", skipMountUnmount)

        //Get filesystem name from UUID
        fsName, err := cs.Driver.connmap["primary"].GetFilesystemName(filesystemID)
        if err != nil </span><span class="cov0" title="0">{
                glog.Errorf("ControllerPublishVolume : Error in getting filesystem Name for filesystem ID of %s.", filesystemID)
                return nil, status.Error(codes.Internal, fmt.Sprintf("ControllerPublishVolume : Error in getting filesystem Name for filesystem ID of %s. Error [%v]", filesystemID, err))
        }</span>

        //Check if primary filesystem is mounted.
        <span class="cov0" title="0">primaryfsName := cs.Driver.primary.GetPrimaryFs()
        pfsMount, err := cs.Driver.connmap["primary"].GetFilesystemMountDetails(primaryfsName)
        if err != nil </span><span class="cov0" title="0">{
                glog.Errorf("ControllerPublishVolume : Error in getting filesystem mount details for %s", primaryfsName)
                return nil, status.Error(codes.Internal, fmt.Sprintf("ControllerPublishVolume : Error in getting filesystem mount details for %s. Error [%v]", primaryfsName, err))
        }</span>

        // Node mapping check
        <span class="cov0" title="0">scalenodeID := getNodeMapping(nodeID)
        glog.V(4).Infof("ControllerUnpublishVolume : scalenodeID:%s --known as-- k8snodeName: %s", scalenodeID, nodeID)

        shortnameNodeMapping := utils.GetEnv(SHORTNAME_NODE_MAPPING, no)
        if shortnameNodeMapping == yes </span><span class="cov0" title="0">{
                glog.V(4).Infof("ControllerPublishVolume : SHORTNAME_NODE_MAPPING is set to %s", shortnameNodeMapping)
        }</span>

        <span class="cov0" title="0">var ispFsMounted bool
        // NodesMounted has admin node names
        // This means node mapping must be to admin names.
        // Unless shortnameNodeMapping=="yes", then we should check shortname portion matches.
        if shortnameNodeMapping == yes </span><span class="cov0" title="0">{
                ispFsMounted = shortnameInSlice(scalenodeID, pfsMount.NodesMounted)
        }</span> else<span class="cov0" title="0"> {
                ispFsMounted = utils.StringInSlice(scalenodeID, pfsMount.NodesMounted)
        }</span>

        <span class="cov0" title="0">glog.V(4).Infof("ControllerPublishVolume : Primary FS is mounted on %v", pfsMount.NodesMounted)
        glog.V(4).Infof("ControllerPublishVolume : Primary Fileystem is %s and Volume is from Filesystem %s", primaryfsName, fsName)
        // Skip if primary filesystem and volume filesystem is same
        if volumeIDMembers.StorageClassType == STORAGECLASS_ADVANCED || primaryfsName != fsName </span><span class="cov0" title="0">{
                //Check if filesystem is mounted
                fsMount, err := cs.Driver.connmap["primary"].GetFilesystemMountDetails(fsName)
                if err != nil </span><span class="cov0" title="0">{
                        glog.Errorf("ControllerPublishVolume : Error in getting filesystem mount details for %s", fsName)
                        return nil, status.Error(codes.Internal, fmt.Sprintf("ControllerPublishVolume : Error in getting filesystem mount details for %s. Error [%v]", fsName, err))
                }</span>

                <span class="cov0" title="0">if volumeIDMembers.StorageClassType == STORAGECLASS_ADVANCED &amp;&amp;
                        !strings.HasPrefix(volumePath, fsMount.MountPoint) </span><span class="cov0" title="0">{
                        glog.Errorf("ControllerPublishVolume : Volume path %s is not part of the filesystem %s", volumePath, fsName)
                        return nil, status.Error(codes.Internal, fmt.Sprintf("ControllerPublishVolume : Volume path %s is not part of the filesystem %s", volumePath, fsName))
                }</span> else<span class="cov0" title="0"> if !strings.HasPrefix(volumePath, fsMount.MountPoint) &amp;&amp;
                        !strings.HasPrefix(volumePath, pfsMount.MountPoint) </span><span class="cov0" title="0">{
                        glog.Errorf("ControllerPublishVolume : Volume path %s is not part of the filesystem %s or %s", volumePath, primaryfsName, fsName)
                        return nil, status.Error(codes.Internal, fmt.Sprintf("ControllerPublishVolume : Volume path %s is not part of the filesystem %s or %s", volumePath, primaryfsName, fsName))
                }</span>

                // NodesMounted has admin node names
                // This means node mapping must be to admin names.
                // Unless shortnameNodeMapping=="yes", then we should check shortname portion matches.
                <span class="cov0" title="0">if shortnameNodeMapping == yes </span><span class="cov0" title="0">{
                        isFsMounted = shortnameInSlice(scalenodeID, pfsMount.NodesMounted)
                }</span> else<span class="cov0" title="0"> {
                        isFsMounted = utils.StringInSlice(scalenodeID, pfsMount.NodesMounted)
                }</span>

                <span class="cov0" title="0">glog.V(4).Infof("ControllerPublishVolume : Volume Source FS is mounted on %v", fsMount.NodesMounted)</span>
        } else<span class="cov0" title="0"> {
                if !strings.HasPrefix(volumePath, pfsMount.MountPoint) </span><span class="cov0" title="0">{
                        glog.Errorf("ControllerPublishVolume : Volume path %s is not part of the filesystem %s", volumePath, primaryfsName)
                        return nil, status.Error(codes.Internal, fmt.Sprintf("ControllerPublishVolume : Volume path %s is not part of the filesystem %s", volumePath, primaryfsName))
                }</span>

                <span class="cov0" title="0">isFsMounted = ispFsMounted</span>
        }

        <span class="cov0" title="0">glog.V(4).Infof("ControllerPublishVolume : Mount Status Primaryfs [ %t ], Sourcefs [ %t ]", ispFsMounted, isFsMounted)

        if isFsMounted &amp;&amp; ispFsMounted </span><span class="cov0" title="0">{
                glog.V(4).Infof("ControllerPublishVolume : %s and %s are mounted on %s so returning success", fsName, primaryfsName, scalenodeID)
                return &amp;csi.ControllerPublishVolumeResponse{}, nil
        }</span>

        <span class="cov0" title="0">if skipMountUnmount == "yes" &amp;&amp; (!isFsMounted || !ispFsMounted) </span><span class="cov0" title="0">{
                glog.Errorf("ControllerPublishVolume : SKIP_MOUNT_UNMOUNT == yes and either %s or %s is not mounted on node %s", primaryfsName, fsName, scalenodeID)
                return nil, status.Error(codes.Internal, fmt.Sprintf("ControllerPublishVolume : SKIP_MOUNT_UNMOUNT == yes and either %s or %s is not mounted on node %s.", primaryfsName, fsName, scalenodeID))
        }</span>

        //mount the primary filesystem if not mounted
        <span class="cov0" title="0">if !(ispFsMounted) &amp;&amp; skipMountUnmount == no </span><span class="cov0" title="0">{
                glog.V(4).Infof("ControllerPublishVolume : mounting Filesystem %s on %s", primaryfsName, scalenodeID)
                err = cs.Driver.connmap["primary"].MountFilesystem(primaryfsName, scalenodeID)
                if err != nil </span><span class="cov0" title="0">{
                        glog.Errorf("ControllerPublishVolume : Error in mounting filesystem %s on node %s", primaryfsName, scalenodeID)
                        return nil, status.Error(codes.Internal, fmt.Sprintf("ControllerPublishVolume :  Error in mounting filesystem %s on node %s. Error [%v]", primaryfsName, scalenodeID, err))
                }</span>
        }

        //mount the volume filesystem if mounted
        <span class="cov0" title="0">if !(isFsMounted) &amp;&amp; skipMountUnmount == no &amp;&amp; primaryfsName != fsName </span><span class="cov0" title="0">{
                glog.V(4).Infof("ControllerPublishVolume : mounting %s on %s", fsName, scalenodeID)
                err = cs.Driver.connmap["primary"].MountFilesystem(fsName, scalenodeID)
                if err != nil </span><span class="cov0" title="0">{
                        glog.Errorf("ControllerPublishVolume : Error in mounting filesystem %s on node %s", fsName, scalenodeID)
                        return nil, status.Error(codes.Internal, fmt.Sprintf("ControllerPublishVolume : Error in mounting filesystem %s on node %s. Error [%v]", fsName, scalenodeID, err))
                }</span>
        }
        <span class="cov0" title="0">return &amp;csi.ControllerPublishVolumeResponse{}, nil</span>
}

func (cs *ScaleControllerServer) CheckNewSnapRequired(conn connectors.SpectrumScaleConnector, filesystemName string, filesetName string, snapWindow int) (string, error) <span class="cov0" title="0">{
        latestSnapList, err := conn.GetLatestFilesetSnapshots(filesystemName, filesetName)
        if err != nil </span><span class="cov0" title="0">{
                glog.Errorf("CheckNewSnapRequired - getting latest snapshot list failed for fileset: [%s:%s]. Error: [%v]", filesystemName, filesetName, err)
                return "", err
        }</span>

        <span class="cov0" title="0">if len(latestSnapList) == 0 </span><span class="cov0" title="0">{
                // No snapshot exists, so create new one
                return "", nil
        }</span>

        <span class="cov0" title="0">timestamp, err := cs.getSnapshotCreateTimestamp(conn, filesystemName, filesetName, latestSnapList[0].SnapshotName)
        if err != nil </span><span class="cov0" title="0">{
                glog.Errorf("error getting create timestamp for snapshot %s:%s:%s", filesystemName, filesetName, latestSnapList[0].SnapshotName)
                return "", err
        }</span>

        <span class="cov0" title="0">var timestampSecs int64
        timestampSecs = timestamp.GetSeconds()
        lastSnapTime := time.Unix(timestampSecs, 0)
        passedTime := time.Now().Sub(lastSnapTime).Seconds()
        glog.V(3).Infof("for fileset [%s:%s], last snapshot time: [%v], current time: [%v], passed time: %v seconds, snapWindow: %v minutes", filesystemName, filesetName, lastSnapTime, time.Now(), int64(passedTime), snapWindow)

        snapWindowSeconds := snapWindow * 60

        if passedTime &lt; float64(snapWindowSeconds) </span><span class="cov0" title="0">{
                // we don't need to take new snapshot
                glog.V(3).Infof("CheckNewSnapRequired - for fileset [%s:%s], using existing snapshot [%s]", filesystemName, filesetName, latestSnapList[0].SnapshotName)
                return latestSnapList[0].SnapshotName, nil
        }</span>

        <span class="cov0" title="0">glog.V(3).Infof("CheckNewSnapRequired - for fileset [%s:%s] we need to create new snapshot", filesystemName, filesetName)
        return "", nil</span>
}

func (cs *ScaleControllerServer) MakeSnapMetadataDir(conn connectors.SpectrumScaleConnector, filesystemName string, filesetName string, indepFileset string, cgSnapName string, metaSnapName string) error <span class="cov0" title="0">{
        path := fmt.Sprintf("%s/%s/%s", indepFileset, cgSnapName, metaSnapName)
        glog.V(3).Infof("MakeSnapMetadataDir - creating directory [%s] for fileset: [%s:%s]", path, filesystemName, filesetName)
        err := conn.MakeDirectory(filesystemName, path, "0", "0")
        if err != nil </span><span class="cov0" title="0">{
                // Directory creation failed
                glog.Errorf("for volume:[%v] - unable to create directory [%v] in filesystem [%v]. Error : %v", filesetName, path, filesystemName, err)
                return fmt.Errorf("unable to create directory [%v] in filesystem [%v]. Error : %v", path, filesystemName, err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// CreateSnapshot Create Snapshot
func (cs *ScaleControllerServer) CreateSnapshot(ctx context.Context, req *csi.CreateSnapshotRequest) (*csi.CreateSnapshotResponse, error) <span class="cov0" title="0">{ //nolint:gocyclo,funlen
        glog.V(3).Infof("CreateSnapshot - create snapshot req: %v", req)

        if err := cs.Driver.ValidateControllerServiceRequest(csi.ControllerServiceCapability_RPC_CREATE_DELETE_SNAPSHOT); err != nil </span><span class="cov0" title="0">{
                glog.V(3).Infof("CreateSnapshot - invalid create snapshot req: %v", req)
                return nil, status.Error(codes.Internal, fmt.Sprintf("CreateSnapshot ValidateControllerServiceRequest failed: %v", err))
        }</span>

        <span class="cov0" title="0">if req == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "CreateSnapshot - Request cannot be empty")
        }</span>

        <span class="cov0" title="0">volID := req.GetSourceVolumeId()
        if volID == "" </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "CreateSnapshot - Source Volume ID is a required field")
        }</span>

        <span class="cov0" title="0">volumeIDMembers, err := getVolIDMembers(volID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, fmt.Sprintf("CreateSnapshot - Error in source Volume ID %v: %v", volID, err))
        }</span>

        <span class="cov0" title="0">if !volumeIDMembers.IsFilesetBased </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, fmt.Sprintf("CreateSnapshot - volume [%s] - Volume snapshot can only be created when source volume is fileset", volID))
        }</span>

        <span class="cov0" title="0">if (volumeIDMembers.StorageClassType == STORAGECLASS_ADVANCED) &amp;&amp; (volumeIDMembers.VolType != FILE_DEPENDENTFILESET_VOLUME) </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, fmt.Sprintf("CreateSnapshot - volume [%s] - Volume snapshot can only be created when source volume is dependent fileset for new storageClass", volID))
        }</span>

        <span class="cov0" title="0">conn, err := cs.getConnFromClusterID(volumeIDMembers.ClusterId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        /* Check if Spectrum Scale supports Snapshot */
        <span class="cov0" title="0">chkSnapshotErr := cs.checkSnapshotSupport(conn)
        if chkSnapshotErr != nil </span><span class="cov0" title="0">{
                return nil, chkSnapshotErr
        }</span>

        <span class="cov0" title="0">primaryConn, isprimaryConnPresent := cs.Driver.connmap["primary"]
        if !isprimaryConnPresent </span><span class="cov0" title="0">{
                glog.Errorf("CreateSnapshot - unable to get connector for primary cluster")
                return nil, status.Error(codes.Internal, "CreateSnapshot - unable to find primary cluster details in custom resource")
        }</span>

        <span class="cov0" title="0">filesystemName, err := primaryConn.GetFilesystemName(volumeIDMembers.FsUUID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, fmt.Sprintf("CreateSnapshot - Unable to get filesystem Name for Filesystem Uid [%v] and clusterId [%v]. Error [%v]", volumeIDMembers.FsUUID, volumeIDMembers.ClusterId, err))
        }</span>

        <span class="cov0" title="0">mountInfo, err := primaryConn.GetFilesystemMountDetails(filesystemName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, fmt.Sprintf("CreateSnapshot - unable to get mount info for FS [%v] in primary cluster", filesystemName))
        }</span>

        <span class="cov0" title="0">filesetResp := connectors.Fileset_v2{}
        filesystemName = getRemoteFsName(mountInfo.RemoteDeviceName)
        if volumeIDMembers.FsetName != "" </span><span class="cov0" title="0">{
                filesetResp, err = conn.GetFileSetResponseFromName(filesystemName, volumeIDMembers.FsetName)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, status.Error(codes.Internal, fmt.Sprintf("CreateSnapshot - Unable to get Fileset response for Fileset [%v] FS [%v] ClusterId [%v]", volumeIDMembers.FsetName, filesystemName, volumeIDMembers.ClusterId))
                }</span>
        } else<span class="cov0" title="0"> {
                filesetResp, err = conn.GetFileSetResponseFromId(filesystemName, volumeIDMembers.FsetId)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, status.Error(codes.Internal, fmt.Sprintf("CreateSnapshot - Unable to get Fileset response for Fileset Id [%v] FS [%v] ClusterId [%v]", volumeIDMembers.FsetId, filesystemName, volumeIDMembers.ClusterId))
                }</span>
        }

        <span class="cov0" title="0">if volumeIDMembers.StorageClassType != STORAGECLASS_ADVANCED </span><span class="cov0" title="0">{
                if filesetResp.Config.ParentId &gt; 0 </span><span class="cov0" title="0">{
                        return nil, status.Error(codes.InvalidArgument, fmt.Sprintf("CreateSnapshot - volume [%s] - Volume snapshot can only be created when source volume is independent fileset", volID))
                }</span>
        }

        <span class="cov0" title="0">filesetName := filesetResp.FilesetName
        relPath := ""
        if volumeIDMembers.StorageClassType == STORAGECLASS_ADVANCED </span><span class="cov0" title="0">{
                glog.V(3).Infof("CreateSnapshot - creating snapshot for advanced storageClass")
                relPath = strings.Replace(volumeIDMembers.Path, mountInfo.MountPoint, "", 1)
        }</span> else<span class="cov0" title="0"> {
                glog.V(3).Infof("CreateSnapshot - creating snapshot for classic storageClass")
                relPath = strings.Replace(volumeIDMembers.Path, cs.Driver.primary.PrimaryFSMount, "", 1)
        }</span>
        <span class="cov0" title="0">relPath = strings.Trim(relPath, "!/")

        /* Confirm it is same fileset which was created for this PV */
        pvName := filepath.Base(relPath)
        if pvName != filesetName </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, fmt.Sprintf("CreateSnapshot - PV name from path [%v] does not match with filesetName [%v].", pvName, filesetName))
        }</span>

        <span class="cov0" title="0">if volumeIDMembers.StorageClassType == STORAGECLASS_ADVANCED </span><span class="cov0" title="0">{
                filesetName = volumeIDMembers.ConsistencyGroup
        }</span>

        <span class="cov0" title="0">snapName := req.GetName()
        snapWindowInt := 0
        if volumeIDMembers.StorageClassType == STORAGECLASS_ADVANCED </span><span class="cov0" title="0">{
                snapParams := req.GetParameters()
                snapWindow, snapWindowSpecified := snapParams[connectors.UserSpecifiedSnapWindow]
                if !snapWindowSpecified </span><span class="cov0" title="0">{
                        // use default snapshot window for consistency group
                        snapWindow = defaultSnapWindow
                        glog.V(3).Infof("snapWindow not specified. Using default snapWindow: [%s] for for fileset[%s:%s]", snapWindow, filesetResp.FilesetName, filesystemName)
                }</span>
                <span class="cov0" title="0">snapWindowInt, err = strconv.Atoi(snapWindow)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, status.Error(codes.Internal, fmt.Sprintf("CreateSnapshot [%s] - invalid snapWindow value: [%v]", snapName, snapWindow))
                }</span>
        }

        <span class="cov0" title="0">snapExist, err := conn.CheckIfSnapshotExist(filesystemName, filesetName, snapName)
        if err != nil </span><span class="cov0" title="0">{
                glog.Errorf("CreateSnapshot [%s] - Unable to get the snapshot details. Error [%v]", snapName, err)
                return nil, status.Error(codes.Internal, fmt.Sprintf("Unable to get the snapshot details for [%s]. Error [%v]", snapName, err))
        }</span>

        <span class="cov0" title="0">if !snapExist </span><span class="cov0" title="0">{
                /* For new storageClass check last snapshot creation time, if time passed is less than
                 * snapWindow then return existing snapshot */
                createNewSnap := true
                if volumeIDMembers.StorageClassType == STORAGECLASS_ADVANCED </span><span class="cov0" title="0">{
                        cgSnapName, err := cs.CheckNewSnapRequired(conn, filesystemName, filesetName, snapWindowInt)
                        if err != nil </span><span class="cov0" title="0">{
                                glog.Errorf("CreateSnapshot [%s] - unable to check if snapshot is required for new storageClass for fileset [%s:%s]. Error: [%v]", snapName, filesystemName, filesetName, err)
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">if cgSnapName != "" </span><span class="cov0" title="0">{
                                usable, err := cs.isExistingSnapUseableForVol(conn, filesystemName, filesetName, filesetResp.FilesetName, cgSnapName)
                                if !usable </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">createNewSnap = false
                                snapName = cgSnapName</span>
                        } else<span class="cov0" title="0"> {
                                glog.V(3).Infof("CreateSnapshot - creating new snapshot for consistency group for fileset: [%s:%s]", filesystemName, filesetName)
                        }</span>
                }

                <span class="cov0" title="0">if createNewSnap </span><span class="cov0" title="0">{
                        snapshotList, err := conn.ListFilesetSnapshots(filesystemName, filesetName)
                        if err != nil </span><span class="cov0" title="0">{
                                glog.Errorf("CreateSnapshot [%s] - unable to list snapshots for fileset [%s:%s]. Error: [%v]", snapName, filesystemName, filesetName, err)
                                return nil, status.Error(codes.Internal, fmt.Sprintf("unable to list snapshots for fileset [%s:%s]. Error: [%v]", filesystemName, filesetName, err))
                        }</span>

                        <span class="cov0" title="0">if len(snapshotList) &gt;= 256 </span><span class="cov0" title="0">{
                                glog.Errorf("CreateSnapshot [%s] - max limit of snapshots reached for fileset [%s:%s]. No more snapshots can be created for this fileset.", snapName, filesystemName, filesetName)
                                return nil, status.Error(codes.OutOfRange, fmt.Sprintf("max limit of snapshots reached for fileset [%s:%s]. No more snapshots can be created for this fileset.", filesystemName, filesetName))
                        }</span>

                        <span class="cov0" title="0">snaperr := conn.CreateSnapshot(filesystemName, filesetName, snapName)
                        if snaperr != nil </span><span class="cov0" title="0">{
                                glog.Errorf("snapshot [%s] - Unable to create snapshot. Error [%v]", snapName, snaperr)
                                return nil, status.Error(codes.Internal, fmt.Sprintf("unable to create snapshot [%s]. Error [%v]", snapName, snaperr))
                        }</span>
                }
        }

        <span class="cov0" title="0">snapID := ""
        if volumeIDMembers.StorageClassType == STORAGECLASS_ADVANCED </span><span class="cov0" title="0">{
                // storageclass_type;volumeType;clusterId;FSUUID;consistency_group;filesetName;snapshotName;metaSnapshotName
                snapID = fmt.Sprintf("%s;%s;%s;%s;%s;%s;%s;%s", volumeIDMembers.StorageClassType, volumeIDMembers.VolType, volumeIDMembers.ClusterId, volumeIDMembers.FsUUID, filesetName, filesetResp.FilesetName, snapName, req.GetName())
        }</span> else<span class="cov0" title="0"> {
                if filesetResp.Config.Comment == connectors.FilesetComment &amp;&amp;
                        (cs.Driver.primary.PrimaryFset != filesetName || cs.Driver.primary.PrimaryFs != filesystemName) </span><span class="cov0" title="0">{
                        // Dynamically created PVC, here path is the xxx-data directory within the fileset where all volume data resides
                        // storageclass_type;volumeType;clusterId;FSUUID;consistency_group;filesetName;snapshotName;metaSnapshotName;path
                        snapID = fmt.Sprintf("%s;%s;%s;%s;%s;%s;%s;%s;%s-data", volumeIDMembers.StorageClassType, volumeIDMembers.VolType, volumeIDMembers.ClusterId, volumeIDMembers.FsUUID, "", filesetName, snapName, "", filesetName)
                }</span> else<span class="cov0" title="0"> {
                        // This is statically created PVC from an independent fileset, here path is the root of fileset
                        // storageclass_type;volumeType;clusterId;FSUUID;consistency_group;filesetName;snapshotName;metaSnapshotName;/
                        snapID = fmt.Sprintf("%s;%s;%s;%s;%s;%s;%s;%s;/", volumeIDMembers.StorageClassType, volumeIDMembers.VolType, volumeIDMembers.ClusterId, volumeIDMembers.FsUUID, "", filesetName, snapName, "")
                }</span>
        }

        <span class="cov0" title="0">timestamp, err := cs.getSnapshotCreateTimestamp(conn, filesystemName, filesetName, snapName)
        if err != nil </span><span class="cov0" title="0">{
                glog.Errorf("error getting create timestamp for snapshot %s:%s:%s", filesystemName, filesetName, snapName)
                return nil, err
        }</span>

        <span class="cov0" title="0">restoreSize, err := cs.getSnapRestoreSize(conn, filesystemName, filesetResp.FilesetName)
        if err != nil </span><span class="cov0" title="0">{
                glog.Errorf("error getting the snapshot restore size for snapshot %s:%s:%s", filesystemName, filesetResp.FilesetName, snapName)
                return nil, err
        }</span>

        <span class="cov0" title="0">if volumeIDMembers.StorageClassType == STORAGECLASS_ADVANCED </span><span class="cov0" title="0">{
                err := cs.MakeSnapMetadataDir(conn, filesystemName, filesetResp.FilesetName, filesetName, snapName, req.GetName())
                if err != nil </span><span class="cov0" title="0">{
                        glog.Errorf("error in creating directory for storing metadata information for advanced storageClass. Error: [%v]", err)
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">return &amp;csi.CreateSnapshotResponse{
                Snapshot: &amp;csi.Snapshot{
                        SnapshotId:     snapID,
                        SourceVolumeId: volID,
                        ReadyToUse:     true,
                        CreationTime:   &amp;timestamp,
                        SizeBytes:      restoreSize,
                },
        }, nil</span>
}

func (cs *ScaleControllerServer) getSnapshotCreateTimestamp(conn connectors.SpectrumScaleConnector, fs string, fset string, snap string) (timestamp.Timestamp, error) <span class="cov0" title="0">{
        var timestamp timestamp.Timestamp

        createTS, err := conn.GetSnapshotCreateTimestamp(fs, fset, snap)
        if err != nil </span><span class="cov0" title="0">{
                glog.Errorf("snapshot [%s] - Unable to get snapshot create timestamp", snap)
                return timestamp, err
        }</span>

        <span class="cov0" title="0">timezoneOffset, err := conn.GetTimeZoneOffset()
        if err != nil </span><span class="cov0" title="0">{
                glog.Errorf("snapshot [%s] - Unable to get cluster timezone", snap)
                return timestamp, err
        }</span>

        // for GMT, REST API returns Z instead of 00:00
        <span class="cov0" title="0">if timezoneOffset == "Z" </span><span class="cov0" title="0">{
                timezoneOffset = "+00:00"
        }</span>

        // Rest API returns create timestamp in the format 2006-01-02 15:04:05,000
        // irrespective of the cluster timezone. We replace the last part of this date
        // with the timezone offset returned by cluster config REST API and then parse
        // the timestamp with correct zone info
        <span class="cov0" title="0">const longForm = "2006-01-02 15:04:05-07:00"
        //nolint::staticcheck

        createTSTZ := strings.Replace(createTS, ",000", timezoneOffset, 1)
        t, err := time.Parse(longForm, createTSTZ)
        if err != nil </span><span class="cov0" title="0">{
                glog.Errorf("snapshot - for fileset [%s:%s] error in parsing timestamp: [%v]. Error: [%v]", fs, fset, createTS, err)
                return timestamp, err
        }</span>
        <span class="cov0" title="0">timestamp.Seconds = t.Unix()
        timestamp.Nanos = 0

        glog.V(3).Infof("getSnapshotCreateTimestamp: for fileset [%s:%s] snapshot creation timestamp: [%v]", fs, fset, createTSTZ)
        return timestamp, nil</span>
}

func (cs *ScaleControllerServer) getSnapRestoreSize(conn connectors.SpectrumScaleConnector, filesystemName string, filesetName string) (int64, error) <span class="cov0" title="0">{
        quotaResp, err := conn.GetFilesetQuotaDetails(filesystemName, filesetName)

        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">if quotaResp.BlockLimit &lt; 0 </span><span class="cov0" title="0">{
                glog.Errorf("getSnapRestoreSize: Invalid block limit [%v] for fileset [%s:%s] found", quotaResp.BlockLimit, filesystemName, filesetName)
                return 0, status.Error(codes.Internal, fmt.Sprintf("invalid block limit [%v] for fileset [%s:%s] found", quotaResp.BlockLimit, filesystemName, filesetName))
        }</span>

        // REST API returns block limit in kb, convert it to bytes and return
        <span class="cov0" title="0">return int64(quotaResp.BlockLimit * 1024), nil</span>
}

func (cs *ScaleControllerServer) isExistingSnapUseableForVol(conn connectors.SpectrumScaleConnector, filesystemName string, consistencyGroup string, filesetName string, cgSnapName string) (bool, error) <span class="cov0" title="0">{
        pathDir := fmt.Sprintf("%s/.snapshots/%s/%s", consistencyGroup, cgSnapName, filesetName)
        _, err := conn.StatDirectory(filesystemName, pathDir)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), "EFSSG0264C") ||
                        strings.Contains(err.Error(), "does not exist") </span><span class="cov0" title="0">{ // directory does not exist
                        return false, status.Error(codes.Internal, fmt.Sprintf("snapshot for volume [%v] in filesystem [%v] is not taken. Wait till current snapWindow expires.", filesetName, filesystemName))
                }</span> else<span class="cov0" title="0"> {
                        return false, err
                }</span>
        }
        <span class="cov0" title="0">return true, nil</span>
}

func (cs *ScaleControllerServer) DelSnapMetadataDir(conn connectors.SpectrumScaleConnector, filesystemName string, consistencyGroup string, filesetName string, cgSnapName string, metaSnapName string) (bool, error) <span class="cov0" title="0">{
        pathDir := fmt.Sprintf("%s/%s/%s", consistencyGroup, cgSnapName, metaSnapName)
        err := conn.DeleteDirectory(filesystemName, pathDir, false)
        if err != nil </span><span class="cov0" title="0">{
                if !(strings.Contains(err.Error(), "EFSSG0264C") ||
                        strings.Contains(err.Error(), "does not exist")) </span><span class="cov0" title="0">{ // directory is already deleted
                        return false, status.Error(codes.Internal, fmt.Sprintf("unable to Delete Dir using FS [%v] at path [%v]. Error [%v]", filesystemName, pathDir, err))
                }</span>
        }

        // Now check if consistency group snapshot metadata directory can be deleted
        <span class="cov0" title="0">pathDir = fmt.Sprintf("%s/%s", consistencyGroup, cgSnapName)
        statInfo, err := conn.StatDirectory(filesystemName, pathDir)
        if err != nil </span><span class="cov0" title="0">{
                if !(strings.Contains(err.Error(), "EFSSG0264C") ||
                        strings.Contains(err.Error(), "does not exist")) </span><span class="cov0" title="0">{ // directory is already deleted
                        return false, status.Error(codes.Internal, fmt.Sprintf("unable to stat directory using FS [%v] at path [%v]. Error [%v]", filesystemName, pathDir, err))
                }</span>
                <span class="cov0" title="0">return true, nil</span>
        }

        <span class="cov0" title="0">statSplit := strings.Split(statInfo, "\n")
        thirdLineSplit := strings.Split(statSplit[2], " ")
        lenSplit := len(thirdLineSplit)
        linkStr := strings.TrimRight(thirdLineSplit[lenSplit-1], "\n")
        nlink, err := strconv.Atoi(linkStr)
        if err != nil </span><span class="cov0" title="0">{
                return false, status.Error(codes.Internal, fmt.Sprintf("invalid number of links [%v] returned in stat output for FS [%v] at path [%v]. Error [%v]", linkStr, filesystemName, pathDir, err))
        }</span>

        <span class="cov0" title="0">glog.V(3).Infof("DelSnapMetadataDir - number of links for directory in FS [%v] at path [%v] is [%v]", filesystemName, pathDir, nlink)

        if nlink == 2 </span><span class="cov0" title="0">{
                // directory can be deleted
                err := conn.DeleteDirectory(filesystemName, pathDir, true)
                if err != nil </span><span class="cov0" title="0">{
                        if !(strings.Contains(err.Error(), "EFSSG0264C") ||
                                strings.Contains(err.Error(), "does not exist")) </span><span class="cov0" title="0">{
                                return false, status.Error(codes.Internal, fmt.Sprintf("unable to delete directory for FS [%v] at path [%v]. Error: [%v]", filesystemName, pathDir, err))
                        }</span>
                }
                <span class="cov0" title="0">return true, nil</span>
        }
        <span class="cov0" title="0">return false, nil</span>
}

// DeleteSnapshot - Delete snapshot
func (cs *ScaleControllerServer) DeleteSnapshot(ctx context.Context, req *csi.DeleteSnapshotRequest) (*csi.DeleteSnapshotResponse, error) <span class="cov0" title="0">{
        glog.V(3).Infof("DeleteSnapshot - delete snapshot req: %v", req)

        if err := cs.Driver.ValidateControllerServiceRequest(csi.ControllerServiceCapability_RPC_CREATE_DELETE_SNAPSHOT); err != nil </span><span class="cov0" title="0">{
                glog.Errorf("DeleteSnapshot - invalid delete snapshot req %v: %v", req, err)
                return nil, status.Error(codes.Internal, fmt.Sprintf("DeleteSnapshot - ValidateControllerServiceRequest failed: %v", err))
        }</span>

        <span class="cov0" title="0">if req == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "DeleteSnapshot - request cannot be empty")
        }</span>
        <span class="cov0" title="0">snapID := req.GetSnapshotId()

        if snapID == "" </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "DeleteSnapshot - snapshot Id is a required field")
        }</span>

        <span class="cov0" title="0">snapIdMembers, err := cs.GetSnapIdMembers(snapID)
        if err != nil </span><span class="cov0" title="0">{
                glog.Errorf("invalid snapshot ID %s [%v]", snapID, err)
                return nil, err
        }</span>

        <span class="cov0" title="0">conn, err := cs.getConnFromClusterID(snapIdMembers.ClusterId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">filesystemName, err := conn.GetFilesystemName(snapIdMembers.FsUUID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, fmt.Sprintf("DeleteSnapshot - unable to get filesystem Name for Filesystem UID [%v] and clusterId [%v]. Error [%v]", snapIdMembers.FsUUID, snapIdMembers.ClusterId, err))
        }</span>

        <span class="cov0" title="0">filesetExist := false
        if snapIdMembers.StorageClassType == STORAGECLASS_ADVANCED </span><span class="cov0" title="0">{
                filesetExist, err = conn.CheckIfFilesetExist(filesystemName, snapIdMembers.ConsistencyGroup)
        }</span> else<span class="cov0" title="0"> {
                filesetExist, err = conn.CheckIfFilesetExist(filesystemName, snapIdMembers.FsetName)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, fmt.Sprintf("DeleteSnapshot - unable to get the fileset %s details details. Error [%v]", snapIdMembers.FsetName, err))
        }</span>

        //skip delete if snapshot not exist, return success
        <span class="cov0" title="0">if filesetExist </span><span class="cov0" title="0">{
                snapExist := false
                if snapIdMembers.StorageClassType == STORAGECLASS_ADVANCED </span><span class="cov0" title="0">{
                        glog.V(5).Infof("DeleteSnapshot - for advanced storageClass check if snapshot [%s] exist in fileset [%s] under filesystem [%s]", snapIdMembers.SnapName, snapIdMembers.ConsistencyGroup, filesystemName)
                        chkSnapExist, err := conn.CheckIfSnapshotExist(filesystemName, snapIdMembers.ConsistencyGroup, snapIdMembers.SnapName)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, status.Error(codes.Internal, fmt.Sprintf("DeleteSnapshot - unable to get the snapshot details. Error [%v]", err))
                        }</span>
                        <span class="cov0" title="0">snapExist = chkSnapExist</span>
                } else<span class="cov0" title="0"> {
                        glog.V(5).Infof("DeleteSnapshot - for classic storageClass check if snapshot [%s] exist in fileset [%s] under filesystem [%s]", snapIdMembers.SnapName, snapIdMembers.FsetName, filesystemName)
                        chkSnapExist, err := conn.CheckIfSnapshotExist(filesystemName, snapIdMembers.FsetName, snapIdMembers.SnapName)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, status.Error(codes.Internal, fmt.Sprintf("DeleteSnapshot - unable to get the snapshot details. Error [%v]", err))
                        }</span>
                        <span class="cov0" title="0">snapExist = chkSnapExist</span>
                }

                // skip delete snapshot if not exist, return success
                <span class="cov0" title="0">if snapExist </span><span class="cov0" title="0">{
                        deleteSnapshot := true
                        filesetName := snapIdMembers.FsetName
                        if snapIdMembers.StorageClassType == STORAGECLASS_ADVANCED </span><span class="cov0" title="0">{
                                delSnap, snaperr := cs.DelSnapMetadataDir(conn, filesystemName, snapIdMembers.ConsistencyGroup, snapIdMembers.FsetName, snapIdMembers.SnapName, snapIdMembers.MetaSnapName)
                                if snaperr != nil </span><span class="cov0" title="0">{
                                        glog.Errorf("DeleteSnapshot - error while deleting snapshot %v: Error: %v", snapIdMembers.SnapName, snaperr)
                                        return nil, snaperr
                                }</span>
                                <span class="cov0" title="0">if delSnap </span><span class="cov0" title="0">{
                                        filesetName = snapIdMembers.ConsistencyGroup
                                        glog.V(5).Infof("DeleteSnapshot - for advanced storageClass we can delete snapshot [%s] from fileset [%s] under filesystem [%s]", snapIdMembers.SnapName, filesetName, filesystemName)
                                }</span> else<span class="cov0" title="0"> {
                                        deleteSnapshot = false
                                }</span>
                        }

                        <span class="cov0" title="0">if deleteSnapshot </span><span class="cov0" title="0">{
                                glog.V(5).Infof("DeleteSnapshot - deleting snapshot [%s] from fileset [%s] under filesystem [%s]", snapIdMembers.SnapName, filesetName, filesystemName)
                                snaperr := conn.DeleteSnapshot(filesystemName, filesetName, snapIdMembers.SnapName)
                                if snaperr != nil </span><span class="cov0" title="0">{
                                        glog.Errorf("DeleteSnapshot - error deleting snapshot %v: %v", snapIdMembers.SnapName, snaperr)
                                        return nil, snaperr
                                }</span>
                                <span class="cov0" title="0">glog.V(5).Infof("DeleteSnapshot - successfully deleted snapshot [%s] from fileset [%s] under filesystem [%s]", snapIdMembers.SnapName, filesetName, filesystemName)</span>
                        }
                }
        }

        <span class="cov0" title="0">return &amp;csi.DeleteSnapshotResponse{}, nil</span>
}

func (cs *ScaleControllerServer) ListSnapshots(ctx context.Context, req *csi.ListSnapshotsRequest) (*csi.ListSnapshotsResponse, error) <span class="cov0" title="0">{
        return nil, status.Error(codes.Unimplemented, "")
}</span>

func (cs *ScaleControllerServer) GetCapacity(ctx context.Context, req *csi.GetCapacityRequest) (*csi.GetCapacityResponse, error) <span class="cov0" title="0">{
        return nil, status.Error(codes.Unimplemented, "")
}</span>
func (cs *ScaleControllerServer) ListVolumes(ctx context.Context, req *csi.ListVolumesRequest) (*csi.ListVolumesResponse, error) <span class="cov0" title="0">{
        return nil, status.Error(codes.Unimplemented, "")
}</span>
func (cs *ScaleControllerServer) ControllerExpandVolume(ctx context.Context, req *csi.ControllerExpandVolumeRequest) (*csi.ControllerExpandVolumeResponse, error) <span class="cov8" title="1">{
        glog.V(3).Infof("ControllerExpandVolume - Volume expand req: %v", req)

        if err := cs.Driver.ValidateControllerServiceRequest(csi.ControllerServiceCapability_RPC_EXPAND_VOLUME); err != nil </span><span class="cov0" title="0">{
                glog.V(3).Infof("ControllerExpandVolume - invalid expand volume req: %v", req)
                return nil, status.Error(codes.Internal, fmt.Sprintf("ControllerExpandVolume ValidateControllerServiceRequest failed: %v", err))
        }</span>

        <span class="cov8" title="1">volID := req.GetVolumeId()
        if len(volID) == 0 </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "volume ID missing in request")
        }</span>
        <span class="cov8" title="1">capRange := req.GetCapacityRange()
        if capRange == nil </span><span class="cov8" title="1">{
                return nil, status.Error(codes.InvalidArgument, "capacity range not provided")
        }</span>
        <span class="cov8" title="1">capacity := uint64(capRange.GetRequiredBytes())
        volumeIDMembers, err := getVolIDMembers(volID)

        if err != nil </span><span class="cov0" title="0">{
                glog.Errorf("ControllerExpandVolume - Error in source Volume ID %v: %v", volID, err)
                return nil, status.Error(codes.InvalidArgument, fmt.Sprintf("ControllerExpandVolume - Error in source Volume ID %v: %v", volID, err))
        }</span>
        // For lightweight return volume expanded as no action is required
        <span class="cov8" title="1">if !volumeIDMembers.IsFilesetBased </span><span class="cov0" title="0">{
                return &amp;csi.ControllerExpandVolumeResponse{
                        CapacityBytes:         int64(capacity),
                        NodeExpansionRequired: false,
                }, nil
        }</span>

        <span class="cov8" title="1">conn, err := cs.getConnFromClusterID(volumeIDMembers.ClusterId)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">filesystemName, err := conn.GetFilesystemName(volumeIDMembers.FsUUID)
        if err != nil </span><span class="cov0" title="0">{
                glog.Errorf("ControllerExpandVolume - unable to get filesystem Name for Filesystem Uid [%v] and clusterId [%v]. Error [%v]", volumeIDMembers.FsUUID, volumeIDMembers.ClusterId, err)
                return nil, status.Error(codes.Internal, fmt.Sprintf("ControllerExpandVolume - unable to get filesystem Name for Filesystem Uid [%v] and clusterId [%v]. Error [%v]", volumeIDMembers.FsUUID, volumeIDMembers.ClusterId, err))
        }</span>
        <span class="cov8" title="1">filesetName := volumeIDMembers.FsetName

        fsetExist, err := conn.CheckIfFilesetExist(filesystemName, filesetName)
        if err != nil </span><span class="cov0" title="0">{
                glog.Errorf("unable to check fileset [%v] existance in filesystem [%v]. Error [%v]", filesetName, filesystemName, err)
                return nil, status.Error(codes.Internal, fmt.Sprintf("unable to check fileset [%v] existance in filesystem [%v]. Error [%v]", filesetName, filesystemName, err))
        }</span>
        <span class="cov8" title="1">if !fsetExist </span><span class="cov0" title="0">{
                glog.Errorf("fileset [%v] does not exist in filesystem [%v]. Error [%v]", filesetName, filesystemName, err)
                return nil, status.Error(codes.Internal, fmt.Sprintf("fileset [%v] does not exist in filesystem [%v]. Error [%v]", filesetName, filesystemName, err))
        }</span>

        <span class="cov8" title="1">quota, err := conn.ListFilesetQuota(filesystemName, filesetName)
        if err != nil </span><span class="cov8" title="1">{
                glog.Errorf("unable to list quota for fileset [%v] in filesystem [%v]. Error [%v]", filesetName, filesystemName, err)
                return nil, status.Error(codes.Internal, fmt.Sprintf("unable to list quota for fileset [%v] in filesystem [%v]. Error [%v]", filesetName, filesystemName, err))
        }</span>
        <span class="cov8" title="1">filesetQuotaBytes, err := ConvertToBytes(quota)
        if err != nil </span><span class="cov0" title="0">{
                glog.Errorf("unable to convert quota for fileset [%v] in filesystem [%v]. Error [%v]", filesetName, filesystemName, err)
                return nil, status.Error(codes.Internal, fmt.Sprintf("unable to convert quota for fileset [%v] in filesystem [%v]. Error [%v]", filesetName, filesystemName, err))
        }</span>
        <span class="cov8" title="1">if filesetQuotaBytes &lt; capacity </span><span class="cov8" title="1">{
                volsize := strconv.FormatUint(capacity, 10)
                err = conn.SetFilesetQuota(filesystemName, filesetName, volsize)
                if err != nil </span><span class="cov0" title="0">{
                        glog.Errorf("unable to update the quota. Error [%v]", err)
                        return nil, status.Error(codes.Internal, fmt.Sprintf("unable to expand the volume. Error [%v]", err))
                }</span>
        }

        <span class="cov8" title="1">fsetDetails, err := conn.ListFileset(filesystemName, filesetName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Internal, fmt.Sprintf("unable to get the fileset details. Error [%v]", err))
        }</span>
        //check if fileset is dependent of independent\
        <span class="cov8" title="1">maxInodesCombination := []int{100096, 100352, 102400, 106496, 114688, 131072}

        if fsetDetails.Config.ParentId == 0 </span><span class="cov8" title="1">{
                if capacity &gt; 10*oneGB </span><span class="cov0" title="0">{
                        if numberInSlice(fsetDetails.Config.MaxNumInodes, maxInodesCombination) </span><span class="cov0" title="0">{
                                opt := make(map[string]interface{})
                                opt[connectors.UserSpecifiedInodeLimit] = strconv.FormatUint(200000, 10)
                                fseterr := conn.UpdateFileset(filesystemName, filesetName, opt)
                                if fseterr != nil </span><span class="cov0" title="0">{
                                        glog.Errorf("volume:[%v] - unable to update fileset [%v] in filesystem [%v]. Error: %v", filesetName, filesetName, filesystemName, fseterr)
                                        return nil, status.Error(codes.Internal, fmt.Sprintf("unable to update fileset [%v] in filesystem [%v]. Error: %v", filesetName, filesystemName, fseterr))
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return &amp;csi.ControllerExpandVolumeResponse{
                CapacityBytes:         int64(capacity),
                NodeExpansionRequired: false,
        }, nil</span>
}

func (cs *ScaleControllerServer) ControllerGetVolume(ctx context.Context, req *csi.ControllerGetVolumeRequest) (*csi.ControllerGetVolumeResponse, error) <span class="cov0" title="0">{
        return nil, status.Error(codes.Unimplemented, "")
}</span>

// getRemoteClusterID returns the cluster ID for the passed cluster name.
func (cs *ScaleControllerServer) getRemoteClusterID(clusterName string) (string, error) <span class="cov0" title="0">{

        glog.V(5).Infof("fetching cluster details from cache map for cluster %s", clusterName)
        clusterDetails, found := cs.Driver.clusterMap.Load(ClusterName{clusterName})
        if found </span><span class="cov0" title="0">{
                glog.V(5).Infof("checking if cluster details found from cache map for cluster %s has expired.", clusterName)
                if expired := checkExpiry(clusterDetails); !expired </span><span class="cov0" title="0">{ // cluster details are not expired.
                        glog.V(5).Infof("cluster details found from cache map for cluster %s are valid.", clusterName)
                        return clusterDetails.(ClusterDetails).id, nil
                }</span> else<span class="cov0" title="0"> { // cluster details are expired
                        glog.V(5).Infof("cluster details found from cache map for cluster %s are expired.", clusterName)
                        cID := clusterDetails.(ClusterDetails).id
                        conn, err := cs.getConnFromClusterID(cID)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov0" title="0">clusterSummary, err := conn.GetClusterSummary()
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov0" title="0">cName := clusterSummary.ClusterName
                        if cName == clusterName </span><span class="cov0" title="0">{
                                glog.V(5).Infof("updating cluster details in cache map for cluster %s.", clusterName)
                                cs.Driver.clusterMap.Store(ClusterName{cName}, ClusterDetails{cID, cName, time.Now(), 24})
                                cs.Driver.clusterMap.Store(ClusterID{cID}, ClusterDetails{cID, cName, time.Now(), 24})
                                glog.V(5).Infof("ClusterMap updated, [%s : %s]", cID, cName)
                                return cID, nil
                        }</span> else<span class="cov0" title="0"> {
                                found = false
                        }</span>
                }
        }

        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                glog.V(5).Infof("cluster details are either expired or not found in cache map for cluster %s. Updating the cache map.", clusterName)
                scaleconfig := settings.LoadScaleConfigSettings()

                for i := range scaleconfig.Clusters </span><span class="cov0" title="0">{

                        cID := scaleconfig.Clusters[i].ID
                        glog.V(5).Infof("fetching cluster details from cache map for cluster %s", scaleconfig.Clusters[i].ID)
                        clusterDetails, found := cs.Driver.clusterMap.Load(ClusterID{cID})
                        if found </span><span class="cov0" title="0">{
                                glog.V(5).Infof("checking if cluster details found from cache map for cluster %s has expired.", scaleconfig.Clusters[i].ID)
                                if expired := checkExpiry(clusterDetails); !expired </span><span class="cov0" title="0">{
                                        glog.V(5).Infof("cluster details found from cache map for cluster %s are valid.", scaleconfig.Clusters[i].ID)
                                        cName := clusterDetails.(ClusterDetails).name
                                        if cName == clusterName </span><span class="cov0" title="0">{
                                                return cID, nil
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        glog.V(5).Infof("cluster details found from cache map for cluster %s are expired.", scaleconfig.Clusters[i].ID)
                                        glog.V(5).Infof("updating cluster details in cache map for cluster %s.", scaleconfig.Clusters[i].ID)
                                        cName, updated := cs.updateClusterMap(cID)
                                        if !updated </span><span class="cov0" title="0">{
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">if cName == clusterName </span><span class="cov0" title="0">{
                                                return cID, nil
                                        }</span>
                                }
                        } else<span class="cov0" title="0"> { // if !found
                                glog.V(5).Infof("cluster details not found in cache map for cluster %s.", scaleconfig.Clusters[i].ID)
                                glog.V(5).Infof("adding cluster details in cache map for cluster %s.", scaleconfig.Clusters[i].ID)
                                cName, updated := cs.updateClusterMap(cID)
                                if !updated </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">if cName == clusterName </span><span class="cov0" title="0">{
                                        return cID, nil
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return "", status.Error(codes.Internal, fmt.Sprintf("unable to get cluster ID for cluster %s", clusterName))</span>
}

// checkExpiry returns false if cluster detials are valid.
// It returns true if cluster details have expired.
func checkExpiry(clusterDetails interface{}) bool <span class="cov0" title="0">{
        updateTime := clusterDetails.(ClusterDetails).lastupdated
        expiryDuration := clusterDetails.(ClusterDetails).expiryDuration
        if time.Since(updateTime).Hours() &lt; float64(expiryDuration) </span><span class="cov0" title="0">{
                return false
        }</span> else<span class="cov0" title="0"> {
                return true
        }</span>
}

// updateClusterMap updates the clusterMap with cluster details.
// It returns true if cache map is updated else it returns false.
func (cs *ScaleControllerServer) updateClusterMap(cID string) (string, bool) <span class="cov0" title="0">{
        glog.V(5).Infof("creating new connector for the cluster %s", cID)
        clusterConnector, err := cs.getConnFromClusterID(cID)
        // clusterConnector, err := connectors.NewSpectrumRestV2(cluster)
        if err != nil </span><span class="cov0" title="0">{
                glog.V(5).Infof("unable to create new connector for the cluster %s", cID)
                return "", false
        }</span>

        <span class="cov0" title="0">clusterSummary, err := clusterConnector.GetClusterSummary()
        if err != nil </span><span class="cov0" title="0">{
                glog.V(5).Infof("unable to get cluster summary for cluster %s", cID)
                return "", false
        }</span>

        <span class="cov0" title="0">cName := clusterSummary.ClusterName
        // cID = fmt.Sprint(clusterSummary.ClusterID)
        cs.Driver.clusterMap.Store(ClusterName{cName}, ClusterDetails{cID, cName, time.Now(), 24})
        cs.Driver.clusterMap.Store(ClusterID{cID}, ClusterDetails{cID, cName, time.Now(), 24})
        glog.V(5).Infof("ClusterMap updated: [%s : %s]", cID, cName)
        return cName, true</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">/**
 * Copyright 2019 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package scale

import (
        "fmt"
        "path"
        "strings"
        "sync"
        "time"

        "github.com/IBM/ibm-spectrum-scale-csi/driver/csiplugin/connectors"
        "github.com/IBM/ibm-spectrum-scale-csi/driver/csiplugin/settings"
        "github.com/IBM/ibm-spectrum-scale-csi/driver/csiplugin/utils"
        "github.com/container-storage-interface/spec/lib/go/csi"
        "github.com/golang/glog"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

const (
        DefaultPrimaryFileset = "spectrum-scale-csi-volume-store"

        SNAP_JOB_NOT_STARTED    = 0
        SNAP_JOB_RUNNING        = 1
        SNAP_JOB_COMPLETED      = 2
        SNAP_JOB_FAILED         = 3
        VOLCOPY_JOB_FAILED      = 4
        VOLCOPY_JOB_RUNNING     = 5
        VOLCOPY_JOB_COMPLETED   = 6
        VOLCOPY_JOB_NOT_STARTED = 7
        JOB_STATUS_UNKNOWN      = 8

        STORAGECLASS_CLASSIC  = "0"
        STORAGECLASS_ADVANCED = "1"

        // Volume types
        FILE_DIRECTORYBASED_VOLUME     = "0"
        FILE_DEPENDENTFILESET_VOLUME   = "1"
        FILE_INDEPENDENTFILESET_VOLUME = "2"

// BLOCK_FILESET_VOLUME = 3
)

type SnapCopyJobDetails struct {
        jobStatus int
        volID     string
}

type VolCopyJobDetails struct {
        jobStatus int
        volID     string
}

// ClusterDetails stores information of the cluster.
type ClusterDetails struct {
        // id of the Spectrum Scale cluster
        id string
        // name of the Spectrum Scale cluster
        name string
        // time when the object was last updated.
        lastupdated time.Time
        // expiry duration in hours.
        expiryDuration float64
}

// ClusterName stores the name of the cluster.
type ClusterName struct {
        // name of the Spectrum Scale cluster
        name string
}

// ClusterID stores the id of the cluster.
type ClusterID struct {
        // id of the Spectrum Scale cluster
        id string
}

type ScaleDriver struct {
        name          string
        vendorVersion string
        nodeID        string

        ids *ScaleIdentityServer
        ns  *ScaleNodeServer
        cs  *ScaleControllerServer

        connmap map[string]connectors.SpectrumScaleConnector
        cmap    settings.ScaleSettingsConfigMap
        primary settings.Primary
        reqmap  map[string]int64

        snapjobstatusmap    sync.Map
        volcopyjobstatusmap sync.Map

        // clusterMap map stores the cluster name as key and cluster details as value.
        clusterMap sync.Map

        vcap  []*csi.VolumeCapability_AccessMode
        cscap []*csi.ControllerServiceCapability
        nscap []*csi.NodeServiceCapability
}

func GetScaleDriver() *ScaleDriver <span class="cov8" title="1">{
        glog.V(3).Infof("gpfs GetScaleDriver")
        return &amp;ScaleDriver{}
}</span>

func NewIdentityServer(d *ScaleDriver) *ScaleIdentityServer <span class="cov8" title="1">{
        glog.V(3).Infof("gpfs NewIdentityServer")
        return &amp;ScaleIdentityServer{
                Driver: d,
        }
}</span>

func NewControllerServer(d *ScaleDriver, connMap map[string]connectors.SpectrumScaleConnector, cmap settings.ScaleSettingsConfigMap, primary settings.Primary) *ScaleControllerServer <span class="cov8" title="1">{
        glog.V(3).Infof("gpfs NewControllerServer")
        d.connmap = connMap
        d.cmap = cmap
        d.primary = primary
        d.reqmap = make(map[string]int64)
        return &amp;ScaleControllerServer{
                Driver: d,
        }
}</span>

func NewNodeServer(d *ScaleDriver) *ScaleNodeServer <span class="cov8" title="1">{
        glog.V(3).Infof("gpfs NewNodeServer")
        return &amp;ScaleNodeServer{
                Driver: d,
        }
}</span>

func (driver *ScaleDriver) AddVolumeCapabilityAccessModes(vc []csi.VolumeCapability_AccessMode_Mode) error <span class="cov8" title="1">{
        glog.V(3).Infof("gpfs AddVolumeCapabilityAccessModes")
        var vca []*csi.VolumeCapability_AccessMode
        for _, c := range vc </span><span class="cov8" title="1">{
                glog.V(3).Infof("Enabling volume access mode: %v", c.String())
                vca = append(vca, NewVolumeCapabilityAccessMode(c))
        }</span>
        <span class="cov8" title="1">driver.vcap = vca
        return nil</span>
}

func (driver *ScaleDriver) AddControllerServiceCapabilities(cl []csi.ControllerServiceCapability_RPC_Type) error <span class="cov8" title="1">{
        glog.V(3).Infof("gpfs AddControllerServiceCapabilities")
        var csc []*csi.ControllerServiceCapability
        for _, c := range cl </span><span class="cov8" title="1">{
                glog.V(3).Infof("Enabling controller service capability: %v", c.String())
                csc = append(csc, NewControllerServiceCapability(c))
        }</span>
        <span class="cov8" title="1">driver.cscap = csc
        return nil</span>
}

func (driver *ScaleDriver) AddNodeServiceCapabilities(nl []csi.NodeServiceCapability_RPC_Type) error <span class="cov8" title="1">{
        glog.V(3).Infof("gpfs AddNodeServiceCapabilities")
        var nsc []*csi.NodeServiceCapability
        for _, n := range nl </span><span class="cov8" title="1">{
                glog.V(3).Infof("Enabling node service capability: %v", n.String())
                nsc = append(nsc, NewNodeServiceCapability(n))
        }</span>
        <span class="cov8" title="1">driver.nscap = nsc
        return nil</span>
}

func (driver *ScaleDriver) ValidateControllerServiceRequest(c csi.ControllerServiceCapability_RPC_Type) error <span class="cov8" title="1">{
        glog.V(3).Infof("gpfs ValidateControllerServiceRequest")
        if c == csi.ControllerServiceCapability_RPC_UNKNOWN </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">for _, cap := range driver.cscap </span><span class="cov8" title="1">{
                if c == cap.GetRpc().Type </span><span class="cov8" title="1">{
                        return nil
                }</span>
        }
        <span class="cov0" title="0">return status.Error(codes.InvalidArgument, "Invalid controller service request")</span>
}

func (driver *ScaleDriver) SetupScaleDriver(name, vendorVersion, nodeID string, scaleConfig settings.ScaleSettingsConfigMap, scaleConnMap map[string]connectors.SpectrumScaleConnector, myconnectors connectors.GetSpectrumScaleConnectorInt) error <span class="cov8" title="1">{
        glog.V(3).Infof("gpfs SetupScaleDriver. name: %s, version: %v, nodeID: %s", name, vendorVersion, nodeID)
        if name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("Driver name missing")
        }</span>
        <span class="cov8" title="1">scmap, cmap, primary, err := driver.PluginInitialize(myconnectors, scaleConnMap, scaleConfig)
        if err != nil </span><span class="cov0" title="0">{
                glog.Errorf("Error in plugin initialization: %s", err)
                return err
        }</span>
        <span class="cov8" title="1">driver.name = name
        driver.vendorVersion = vendorVersion
        driver.nodeID = nodeID

        // Adding Capabilities
        vcam := []csi.VolumeCapability_AccessMode_Mode{
                csi.VolumeCapability_AccessMode_MULTI_NODE_MULTI_WRITER,
        }
        _ = driver.AddVolumeCapabilityAccessModes(vcam)

        csc := []csi.ControllerServiceCapability_RPC_Type{
                csi.ControllerServiceCapability_RPC_CREATE_DELETE_VOLUME,
                csi.ControllerServiceCapability_RPC_PUBLISH_UNPUBLISH_VOLUME,
                csi.ControllerServiceCapability_RPC_CREATE_DELETE_SNAPSHOT,
                csi.ControllerServiceCapability_RPC_EXPAND_VOLUME,
                csi.ControllerServiceCapability_RPC_CLONE_VOLUME,
        }
        _ = driver.AddControllerServiceCapabilities(csc)

        ns := []csi.NodeServiceCapability_RPC_Type{
                csi.NodeServiceCapability_RPC_GET_VOLUME_STATS,
        }
        _ = driver.AddNodeServiceCapabilities(ns)

        driver.ids = NewIdentityServer(driver)
        driver.ns = NewNodeServer(driver)
        driver.cs = NewControllerServer(driver, scmap, cmap, primary)
        return nil</span>
}

func (driver *ScaleDriver) PluginInitialize(myconnectors connectors.GetSpectrumScaleConnectorInt, scaleConnMap map[string]connectors.SpectrumScaleConnector, scaleConfig settings.ScaleSettingsConfigMap) (map[string]connectors.SpectrumScaleConnector, settings.ScaleSettingsConfigMap, settings.Primary, error) <span class="cov8" title="1">{ //nolint:funlen
        glog.V(3).Infof("gpfs PluginInitialize")
        isValid, err := driver.ValidateScaleConfigParameters(scaleConfig)
        if !isValid </span><span class="cov0" title="0">{
                glog.Errorf("Parameter validation failure")
                return nil, settings.ScaleSettingsConfigMap{}, settings.Primary{}, err
        }</span>

        <span class="cov8" title="1">primaryInfo := settings.Primary{}
        remoteFilesystemName := ""

        for i := 0; i &lt; len(scaleConfig.Clusters); i++ </span><span class="cov8" title="1">{
                cluster := scaleConfig.Clusters[i]

                sc, err := myconnectors.GetSpectrumScaleConnector(cluster)
                if err != nil </span><span class="cov0" title="0">{
                        glog.Errorf("Unable to initialize Spectrum Scale connector for cluster %s", cluster.ID)
                        return nil, scaleConfig, primaryInfo, err
                }</span>
                // validate cluster ID
                <span class="cov8" title="1">clusterId, err := sc.GetClusterId()
                if err != nil </span><span class="cov0" title="0">{
                        glog.Errorf("Error getting cluster ID: %v", err)
                        return nil, scaleConfig, primaryInfo, err
                }</span>
                <span class="cov8" title="1">if cluster.ID != clusterId </span><span class="cov0" title="0">{
                        glog.Errorf("Cluster ID %s from scale config doesnt match the ID from cluster %s.", cluster.ID, clusterId)
                        return nil, scaleConfig, primaryInfo, fmt.Errorf("Cluster ID doesnt match the cluster")
                }</span>

                <span class="cov8" title="1">scaleConnMap[clusterId] = sc

                if cluster.Primary != (settings.Primary{}) </span><span class="cov8" title="1">{
                        scaleConnMap["primary"] = sc

                        // check if primary filesystem exists
                        fsMount, err := sc.GetFilesystemMountDetails(cluster.Primary.GetPrimaryFs())
                        if err != nil </span><span class="cov0" title="0">{
                                glog.Errorf("Error in getting filesystem details for %s", cluster.Primary.GetPrimaryFs())
                                return nil, scaleConfig, cluster.Primary, err
                        }</span>
                        // check if filesystem is mounted on GUI node
                        <span class="cov8" title="1">isFsMounted, err := sc.IsFilesystemMountedOnGUINode(cluster.Primary.GetPrimaryFs())
                        if err != nil </span><span class="cov0" title="0">{
                                glog.Errorf("Error in getting filesystem mount details for %s on Primary cluster", cluster.Primary.GetPrimaryFs())
                                return nil, scaleConfig, cluster.Primary, err
                        }</span>
                        <span class="cov8" title="1">if !isFsMounted </span><span class="cov0" title="0">{
                                glog.Errorf("Primary filesystem %s is not mounted on GUI node of Primary cluster", cluster.Primary.GetPrimaryFs())
                                return nil, scaleConfig, cluster.Primary, fmt.Errorf("Primary filesystem %s not mounted on GUI node Primary cluster", cluster.Primary.GetPrimaryFs())
                        }</span>

                        // In case primary fset value is not specified in configuation then use default
                        <span class="cov8" title="1">if scaleConfig.Clusters[i].Primary.PrimaryFset == "" </span><span class="cov8" title="1">{
                                scaleConfig.Clusters[i].Primary.PrimaryFset = DefaultPrimaryFileset
                                glog.Infof("primaryFset is not specified in configuration using default %s", DefaultPrimaryFileset)
                        }</span>
                        <span class="cov8" title="1">scaleConfig.Clusters[i].Primary.PrimaryFSMount = fsMount.MountPoint
                        scaleConfig.Clusters[i].Primary.PrimaryCid = clusterId

                        primaryInfo = scaleConfig.Clusters[i].Primary

                        // RemoteFS name from Local Filesystem details
                        remoteDeviceName := strings.Split(fsMount.RemoteDeviceName, ":")
                        remoteFilesystemName = remoteDeviceName[len(remoteDeviceName)-1]</span>
                }
                // //check if multiple GUIs are passed
                // if len(cluster.RestAPI) &gt; 1 {
                //         err := driver.cs.checkGuiHASupport(sc)
                //         if err != nil {
                //                 return nil, scaleConfig, cluster.Primary, err
                //         }
                // }
        }

        <span class="cov8" title="1">fs := primaryInfo.GetPrimaryFs()
        sconn := scaleConnMap["primary"]
        fsmount := primaryInfo.PrimaryFSMount
        if primaryInfo.RemoteCluster != "" </span><span class="cov0" title="0">{
                sconn = scaleConnMap[primaryInfo.RemoteCluster]
                if remoteFilesystemName == "" </span><span class="cov0" title="0">{
                        return scaleConnMap, scaleConfig, primaryInfo, fmt.Errorf("Failed to get the name of remote Filesystem")
                }</span>
                <span class="cov0" title="0">fs = remoteFilesystemName
                // check if primary filesystem exists on remote cluster and mounted on atleast one node
                fsMount, err := sconn.GetFilesystemMountDetails(fs)
                if err != nil </span><span class="cov0" title="0">{
                        glog.Errorf("Error in getting filesystem details for %s from cluster %s", fs, primaryInfo.RemoteCluster)
                        return scaleConnMap, scaleConfig, primaryInfo, err
                }</span>

                <span class="cov0" title="0">glog.Infof("remote fsMount = %v", fsMount)
                fsmount = fsMount.MountPoint

                // check if filesystem is mounted on GUI node
                isPfsMounted, err := sconn.IsFilesystemMountedOnGUINode(fs)
                if err != nil </span><span class="cov0" title="0">{
                        glog.Errorf("Error in getting filesystem mount details for %s from cluster %s", fs, primaryInfo.RemoteCluster)
                        return scaleConnMap, scaleConfig, primaryInfo, err
                }</span>

                <span class="cov0" title="0">if !isPfsMounted </span><span class="cov0" title="0">{
                        glog.Errorf("Filesystem %s is not mounted on GUI node of cluster %s", fs, primaryInfo.RemoteCluster)
                        return scaleConnMap, scaleConfig, primaryInfo, fmt.Errorf("Filesystem %s is not mounted on GUI node of cluster %s", fs, primaryInfo.RemoteCluster)
                }</span>
        }

        <span class="cov8" title="1">fsetlinkpath, err := driver.CreatePrimaryFileset(sconn, fs, fsmount, primaryInfo.PrimaryFset, primaryInfo.GetInodeLimit())
        if err != nil </span><span class="cov0" title="0">{
                glog.Errorf("Error in creating primary fileset")
                return scaleConnMap, scaleConfig, primaryInfo, err
        }</span>

        // In case primary FS is remotely mounted, run fileset refresh task on primary cluster
        <span class="cov8" title="1">if primaryInfo.RemoteCluster != "" </span><span class="cov0" title="0">{
                _, err := scaleConnMap["primary"].ListFileset(primaryInfo.GetPrimaryFs(), primaryInfo.PrimaryFset)
                if err != nil </span><span class="cov0" title="0">{
                        glog.Infof("Primary fileset %v not visible on primary cluster. Running fileset refresh task", primaryInfo.PrimaryFset)
                        err = scaleConnMap["primary"].FilesetRefreshTask()
                        if err != nil </span><span class="cov0" title="0">{
                                glog.Errorf("Error in fileset refresh task")
                                return scaleConnMap, scaleConfig, primaryInfo, err
                        }</span>
                }

                // retry listing fileset again after some time after refresh
                <span class="cov0" title="0">time.Sleep(8 * time.Second)
                _, err = scaleConnMap["primary"].ListFileset(primaryInfo.GetPrimaryFs(), primaryInfo.PrimaryFset)
                if err != nil </span><span class="cov0" title="0">{
                        glog.Errorf("Primary fileset %v not visible on primary cluster even after running fileset refresh task", primaryInfo.PrimaryFset)
                        return scaleConnMap, scaleConfig, primaryInfo, err
                }</span>
        }

        <span class="cov8" title="1">if fsmount != primaryInfo.PrimaryFSMount </span><span class="cov0" title="0">{
                fsetlinkpath = strings.Replace(fsetlinkpath, fsmount, primaryInfo.PrimaryFSMount, 1)
        }</span>

        // Create directory where volume symlinks will reside
        <span class="cov8" title="1">symlinkPath, relativePath, err := driver.CreateSymlinkPath(scaleConnMap["primary"], primaryInfo.GetPrimaryFs(), primaryInfo.PrimaryFSMount, fsetlinkpath)
        if err != nil </span><span class="cov0" title="0">{
                glog.Errorf("Error in creating volumes directory")
                return scaleConnMap, scaleConfig, primaryInfo, err
        }</span>
        <span class="cov8" title="1">primaryInfo.SymlinkAbsolutePath = symlinkPath
        primaryInfo.SymlinkRelativePath = relativePath
        primaryInfo.PrimaryFsetLink = fsetlinkpath

        glog.Infof("IBM Spectrum Scale: Plugin initialized")
        return scaleConnMap, scaleConfig, primaryInfo, nil</span>
}

func (driver *ScaleDriver) CreatePrimaryFileset(sc connectors.SpectrumScaleConnector, primaryFS string, fsmount string, filesetName string, inodeLimit string) (string, error) <span class="cov8" title="1">{
        glog.V(4).Infof("gpfs CreatePrimaryFileset. primaryFS: %s, mountpoint: %s, filesetName: %s", primaryFS, fsmount, filesetName)

        // create primary fileset if not already created
        fsetResponse, err := sc.ListFileset(primaryFS, filesetName)
        linkpath := fsetResponse.Config.Path
        newlinkpath := path.Join(fsmount, filesetName)

        if err != nil </span><span class="cov0" title="0">{
                glog.Infof("Primary fileset %s not found. Creating it.", filesetName)
                opts := make(map[string]interface{})
                if inodeLimit != "" </span><span class="cov0" title="0">{
                        opts[connectors.UserSpecifiedInodeLimit] = inodeLimit
                }</span>

                <span class="cov0" title="0">err = sc.CreateFileset(primaryFS, filesetName, opts)
                if err != nil </span><span class="cov0" title="0">{
                        glog.Errorf("Unable to create primary fileset %s", filesetName)
                        return "", err
                }</span>
                <span class="cov0" title="0">linkpath = newlinkpath</span>
        } else<span class="cov8" title="1"> if linkpath == "" || linkpath == "--" </span><span class="cov0" title="0">{
                glog.Infof("Primary fileset %s not linked. Linking it.", filesetName)
                err = sc.LinkFileset(primaryFS, filesetName, newlinkpath)
                if err != nil </span><span class="cov0" title="0">{
                        glog.Errorf("Unable to link primary fileset %s", filesetName)
                        return "", err
                }</span> else<span class="cov0" title="0"> {
                        glog.Infof("Linked primary fileset %s. Linkpath: %s", newlinkpath, filesetName)
                }</span>
                <span class="cov0" title="0">linkpath = newlinkpath</span>
        } else<span class="cov8" title="1"> {
                glog.Infof("Primary fileset %s exists and linked at %s", filesetName, linkpath)
        }</span>

        <span class="cov8" title="1">return linkpath, nil</span>
}

func (driver *ScaleDriver) CreateSymlinkPath(sc connectors.SpectrumScaleConnector, fs string, fsmount string, fsetlinkpath string) (string, string, error) <span class="cov8" title="1">{
        glog.V(4).Infof("gpfs CreateSymlinkPath. filesystem: %s, mountpoint: %s, filesetlinkpath: %s", fs, fsmount, fsetlinkpath)

        dirpath := strings.Replace(fsetlinkpath, fsmount, "", 1)
        dirpath = strings.Trim(dirpath, "!/")
        fsetlinkpath = strings.TrimSuffix(fsetlinkpath, "/")

        dirpath = fmt.Sprintf("%s/.volumes", dirpath)
        symlinkpath := fmt.Sprintf("%s/.volumes", fsetlinkpath)

        err := sc.MakeDirectory(fs, dirpath, "0", "0")
        if err != nil </span><span class="cov0" title="0">{
                glog.Errorf("Make directory failed on filesystem %s, path = %s", fs, dirpath)
                return symlinkpath, dirpath, err
        }</span>

        <span class="cov8" title="1">return symlinkpath, dirpath, nil</span>
}

// ValidateScaleConfigParameters : Validating the Configuration provided for Spectrum Scale CSI Driver
func (driver *ScaleDriver) ValidateScaleConfigParameters(scaleConfig settings.ScaleSettingsConfigMap) (bool, error) <span class="cov8" title="1">{
        glog.V(4).Infof("gpfs ValidateScaleConfigParameters.")
        if len(scaleConfig.Clusters) == 0 </span><span class="cov0" title="0">{
                return false, fmt.Errorf("Missing cluster information in Spectrum Scale configuration")
        }</span>

        <span class="cov8" title="1">primaryClusterFound := false
        rClusterForPrimaryFS := ""
        var cl = make([]string, len(scaleConfig.Clusters))
        issueFound := false

        for i := 0; i &lt; len(scaleConfig.Clusters); i++ </span><span class="cov8" title="1">{
                cluster := scaleConfig.Clusters[i]

                if cluster.ID == "" </span><span class="cov0" title="0">{
                        issueFound = true
                        glog.Errorf("Mandatory parameter 'id' is not specified")
                }</span>
                <span class="cov8" title="1">if len(cluster.RestAPI) == 0 </span><span class="cov0" title="0">{
                        issueFound = true
                        glog.Errorf("Mandatory section 'restApi' is not specified for cluster %v", cluster.ID)
                }</span>
                <span class="cov8" title="1">if len(cluster.RestAPI) != 0 &amp;&amp; cluster.RestAPI[0].GuiHost == "" </span><span class="cov0" title="0">{
                        issueFound = true
                        glog.Errorf("Mandatory parameter 'guiHost' is not specified for cluster %v", cluster.ID)
                }</span>

                <span class="cov8" title="1">if cluster.Primary != (settings.Primary{}) </span><span class="cov8" title="1">{
                        if primaryClusterFound </span><span class="cov0" title="0">{
                                issueFound = true
                                glog.Errorf("More than one primary clusters specified")
                        }</span>

                        <span class="cov8" title="1">primaryClusterFound = true

                        if cluster.Primary.GetPrimaryFs() == "" </span><span class="cov0" title="0">{
                                issueFound = true
                                glog.Errorf("Mandatory parameter 'primaryFs' is not specified for primary cluster %v", cluster.ID)
                        }</span>

                        <span class="cov8" title="1">rClusterForPrimaryFS = cluster.Primary.RemoteCluster</span>
                } else<span class="cov0" title="0"> {
                        cl[i] = cluster.ID
                }</span>

                <span class="cov8" title="1">if cluster.Secrets == "" </span><span class="cov0" title="0">{
                        issueFound = true
                        glog.Errorf("Mandatory parameter 'secrets' is not specified for cluster %v", cluster.ID)
                }</span>

                <span class="cov8" title="1">if cluster.SecureSslMode &amp;&amp; cluster.CacertValue == nil </span><span class="cov0" title="0">{
                        issueFound = true
                        glog.Errorf("CA certificate not specified in secure SSL mode for cluster %v", cluster.ID)
                }</span>
        }

        <span class="cov8" title="1">if !primaryClusterFound </span><span class="cov0" title="0">{
                issueFound = true
                glog.Errorf("No primary clusters specified")
        }</span>

        <span class="cov8" title="1">if rClusterForPrimaryFS != "" &amp;&amp; !utils.StringInSlice(rClusterForPrimaryFS, cl) </span><span class="cov0" title="0">{
                issueFound = true
                glog.Errorf("Remote cluster specified for primary filesystem: %s, but no definition found for it in config", rClusterForPrimaryFS)
        }</span>

        <span class="cov8" title="1">if issueFound </span><span class="cov0" title="0">{
                return false, fmt.Errorf("one or more issue found in Spectrum scale csi driver configuration, check Spectrum Scale csi driver logs")
        }</span>

        <span class="cov8" title="1">return true, nil</span>
}

func (driver *ScaleDriver) Run(endpoint string) <span class="cov0" title="0">{
        glog.Infof("Driver: %v version: %v", driver.name, driver.vendorVersion)
        s := NewNonBlockingGRPCServer()
        s.Start(endpoint, driver.ids, driver.cs, driver.ns)
        s.Wait()
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">/**
 * Copyright 2019 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package scale

import (
        "bytes"
        "fmt"
        "os/exec"
        "strconv"
        "strings"

        "github.com/IBM/ibm-spectrum-scale-csi/driver/csiplugin/connectors"
        "github.com/IBM/ibm-spectrum-scale-csi/driver/csiplugin/utils"
        "github.com/golang/glog"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

const (
        dependentFileset   = "dependent"
        independentFileset = "independent"
        scversion1         = "1"
        scversion2         = "2"
        sharedPermissions  = "777"
)

type scaleVolume struct {
        VolName            string                            `json:"volName"`
        VolSize            uint64                            `json:"volSize"`
        VolBackendFs       string                            `json:"volBackendFs"`
        IsFilesetBased     bool                              `json:"isFilesetBased"`
        VolDirBasePath     string                            `json:"volDirBasePath"`
        VolUid             string                            `json:"volUid"`
        VolGid             string                            `json:"volGid"`
        VolPermissions     string                            `json:"volPermissions"`
        ClusterId          string                            `json:"clusterId"`
        FilesetType        string                            `json:"filesetType"`
        InodeLimit         string                            `json:"inodeLimit"`
        Connector          connectors.SpectrumScaleConnector `json:"connector"`
        PrimaryConnector   connectors.SpectrumScaleConnector `json:"primaryConnector"`
        PrimarySLnkRelPath string                            `json:"primarySLnkRelPath"`
        PrimarySLnkPath    string                            `json:"primarySLnkPath"`
        PrimaryFS          string                            `json:"primaryFS"`
        PrimaryFSMount     string                            `json:"primaryFSMount"`
        ParentFileset      string                            `json:"parentFileset"`
        LocalFS            string                            `json:"localFS"`
        TargetPath         string                            `json:"targetPath"`
        FsetLinkPath       string                            `json:"fsetLinkPath"`
        FsMountPoint       string                            `json:"fsMountPoint"`
        NodeClass          string                            `json:"nodeClass"`
        StorageClassType   string                            `json:"storageClassType"`
        ConsistencyGroup   string                            `json:"consistencyGroup"`
        Compression        string                            `json:"compression"`
        Tier               string                            `json:"tier"`
        Shared             bool                              `json:"shared"`
}

type scaleVolId struct {
        ClusterId        string
        FsUUID           string
        FsName           string
        FsetId           string
        FsetName         string
        DirPath          string
        Path             string
        IsFilesetBased   bool
        StorageClassType string
        ConsistencyGroup string
        VolType          string
}

type scaleSnapId struct {
        ClusterId        string
        FsUUID           string
        FsetName         string
        SnapName         string
        MetaSnapName     string
        Path             string
        FsName           string
        StorageClassType string
        ConsistencyGroup string
        VolType          string
}

//nolint
type scaleVolSnapshot struct {
        SnapName   string `json:"snapName"`
        SourceVol  string `json:"sourceVol"`
        Filesystem string `json:"filesystem"`
        Fileset    string `json:"fileset"`
        ClusterId  string `json:"clusterId"`
        SnapSize   uint64 `json:"snapSize"`
} //nolint

//nolint
type scaleVolSnapId struct {
        ClusterId string
        FsUUID    string
        FsetId    string
        SnapId    string
} //nolint

func IsValidCompressionAlgorithm(input string) bool <span class="cov0" title="0">{
        switch strings.ToLower(input) </span>{
        case
                "z",
                "lz4",
                "zfast",
                "alphae",
                "alphah":<span class="cov0" title="0">
                return true</span>
        }
        <span class="cov0" title="0">return false</span>
}

func getRemoteFsName(remoteDeviceName string) string <span class="cov0" title="0">{
        splitDevName := strings.Split(remoteDeviceName, ":")
        remDevFs := splitDevName[len(splitDevName)-1]
        return remDevFs
}</span>

func getScaleVolumeOptions(volOptions map[string]string) (*scaleVolume, error) <span class="cov0" title="0">{ //nolint:gocyclo,funlen
        //var err error
        scaleVol := &amp;scaleVolume{}

        volBckFs, fsSpecified := volOptions[connectors.UserSpecifiedVolBackendFs]
        volDirPath, volDirPathSpecified := volOptions[connectors.UserSpecifiedVolDirPath]
        clusterID, clusterIDSpecified := volOptions[connectors.UserSpecifiedClusterId]
        uid, uidSpecified := volOptions[connectors.UserSpecifiedUid]
        gid, gidSpecified := volOptions[connectors.UserSpecifiedGid]
        fsType, fsTypeSpecified := volOptions[connectors.UserSpecifiedFilesetType]
        inodeLim, inodeLimSpecified := volOptions[connectors.UserSpecifiedInodeLimit]
        parentFileset, isparentFilesetSpecified := volOptions[connectors.UserSpecifiedParentFset]
        nodeClass, isNodeClassSpecified := volOptions[connectors.UserSpecifiedNodeClass]
        permissions, isPermissionsSpecified := volOptions[connectors.UserSpecifiedPermissions]
        storageClassType, isSCTypeSpecified := volOptions[connectors.UserSpecifiedStorageClassType]
        compression, isCompressionSpecified := volOptions[connectors.UserSpecifiedCompression]
        tier, isTierSpecified := volOptions[connectors.UserSpecifiedTier]
        cg, isCGSpecified := volOptions[connectors.UserSpecifiedConsistencyGroup]
        shared, isSharedSpecified := volOptions[connectors.UserSpecifiedShared]

        // Handling empty values
        scaleVol.VolDirBasePath = ""
        scaleVol.InodeLimit = ""
        scaleVol.FilesetType = ""
        scaleVol.ClusterId = ""
        scaleVol.NodeClass = ""
        scaleVol.ConsistencyGroup = ""
        scaleVol.StorageClassType = ""
        scaleVol.Compression = ""
        scaleVol.Tier = ""

        if isSCTypeSpecified &amp;&amp; storageClassType == "" </span><span class="cov0" title="0">{
                isSCTypeSpecified = false
        }</span>
        <span class="cov0" title="0">isSCAdvanced := false
        if isSCTypeSpecified </span><span class="cov0" title="0">{
                if storageClassType != scversion1 &amp;&amp; storageClassType != scversion2 </span><span class="cov0" title="0">{
                        return &amp;scaleVolume{}, status.Error(codes.InvalidArgument, "The parameter \"version\" can have values only "+
                                "\""+scversion1+"\" or \""+scversion2+"\"")
                }</span>
                <span class="cov0" title="0">if storageClassType == scversion2 </span><span class="cov0" title="0">{
                        isSCAdvanced = true
                        scaleVol.StorageClassType = STORAGECLASS_ADVANCED
                }</span>
                <span class="cov0" title="0">if storageClassType == scversion1 </span><span class="cov0" title="0">{
                        scaleVol.StorageClassType = STORAGECLASS_CLASSIC
                }</span>
        } else<span class="cov0" title="0"> {
                scaleVol.StorageClassType = STORAGECLASS_CLASSIC
        }</span>

        <span class="cov0" title="0">if fsSpecified &amp;&amp; volBckFs == "" </span><span class="cov0" title="0">{
                fsSpecified = false
        }</span>

        <span class="cov0" title="0">if fsSpecified </span><span class="cov0" title="0">{
                scaleVol.VolBackendFs = volBckFs
        }</span> else<span class="cov0" title="0"> {
                return &amp;scaleVolume{}, status.Error(codes.InvalidArgument, "volBackendFs must be specified in storageClass")
        }</span>

        <span class="cov0" title="0">if fsTypeSpecified &amp;&amp; fsType == "" </span><span class="cov0" title="0">{
                fsTypeSpecified = false
        }</span>

        <span class="cov0" title="0">if isCGSpecified &amp;&amp; cg == "" </span><span class="cov0" title="0">{
                isCGSpecified = false
        }</span>

        <span class="cov0" title="0">if volDirPathSpecified &amp;&amp; volDirPath == "" </span><span class="cov0" title="0">{
                volDirPathSpecified = false
        }</span>

        <span class="cov0" title="0">if !fsTypeSpecified &amp;&amp; !volDirPathSpecified &amp;&amp; !isSCAdvanced </span><span class="cov0" title="0">{
                fsTypeSpecified = true
                fsType = independentFileset
        }</span>

        <span class="cov0" title="0">if uidSpecified &amp;&amp; uid == "" </span><span class="cov0" title="0">{
                uidSpecified = false
        }</span>

        <span class="cov0" title="0">if gidSpecified &amp;&amp; gid == "" </span><span class="cov0" title="0">{
                gidSpecified = false
        }</span>

        <span class="cov0" title="0">if gidSpecified &amp;&amp; !uidSpecified </span><span class="cov0" title="0">{
                uidSpecified = true
                uid = "0"
        }</span>

        <span class="cov0" title="0">if inodeLimSpecified &amp;&amp; inodeLim == "" </span><span class="cov0" title="0">{
                inodeLimSpecified = false
        }</span>

        <span class="cov0" title="0">if isparentFilesetSpecified &amp;&amp; parentFileset == "" </span><span class="cov0" title="0">{
                isparentFilesetSpecified = false
        }</span>
        <span class="cov0" title="0">if clusterIDSpecified &amp;&amp; clusterID != "" </span><span class="cov0" title="0">{
                scaleVol.ClusterId = clusterID
        }</span>

        <span class="cov0" title="0">if isPermissionsSpecified &amp;&amp; permissions == "" </span><span class="cov0" title="0">{
                isPermissionsSpecified = false
        }</span>

        <span class="cov0" title="0">if volDirPathSpecified </span><span class="cov0" title="0">{
                if fsTypeSpecified </span><span class="cov0" title="0">{
                        return &amp;scaleVolume{}, status.Error(codes.InvalidArgument, "filesetType and volDirBasePath must not be specified together in storageClass")
                }</span>
                <span class="cov0" title="0">if isparentFilesetSpecified </span><span class="cov0" title="0">{
                        return &amp;scaleVolume{}, status.Error(codes.InvalidArgument, "parentFileset and volDirBasePath must not be specified together in storageClass")
                }</span>
                <span class="cov0" title="0">if inodeLimSpecified </span><span class="cov0" title="0">{
                        return &amp;scaleVolume{}, status.Error(codes.InvalidArgument, "inodeLimit and volDirBasePath must not be specified together in storageClass")
                }</span>
        }

        <span class="cov0" title="0">if fsTypeSpecified </span><span class="cov0" title="0">{
                if fsType == dependentFileset </span><span class="cov0" title="0">{
                        if inodeLimSpecified </span><span class="cov0" title="0">{
                                return &amp;scaleVolume{}, status.Error(codes.InvalidArgument, "inodeLimit and filesetType=dependent must not be specified together in storageClass")
                        }</span>
                } else<span class="cov0" title="0"> if fsType == independentFileset </span><span class="cov0" title="0">{
                        if isparentFilesetSpecified </span><span class="cov0" title="0">{
                                return &amp;scaleVolume{}, status.Error(codes.InvalidArgument, "parentFileset and filesetType=independent(Default) must not be specified together in storageClass")
                        }</span>
                } else<span class="cov0" title="0"> {
                        return &amp;scaleVolume{}, status.Error(codes.InvalidArgument, "Invalid value specified for filesetType in storageClass")
                }</span>
        }

        <span class="cov0" title="0">if fsTypeSpecified &amp;&amp; inodeLimSpecified </span><span class="cov0" title="0">{
                inodelimit, err := strconv.Atoi(inodeLim)
                if err != nil </span><span class="cov0" title="0">{
                        return &amp;scaleVolume{}, status.Error(codes.InvalidArgument, "Invalid value specified for inodeLimit in storageClass")
                }</span>
                <span class="cov0" title="0">if inodelimit &lt; 1024 </span><span class="cov0" title="0">{
                        return &amp;scaleVolume{}, status.Error(codes.InvalidArgument, "inodeLimit specified in storageClass must be equal to or greater than 1024")
                }</span>
        }

        /* Check if either fileset based or LW volume. */

        <span class="cov0" title="0">if volDirPathSpecified </span><span class="cov0" title="0">{
                scaleVol.VolDirBasePath = volDirPath
                scaleVol.IsFilesetBased = false
        }</span>

        <span class="cov0" title="0">if isSCAdvanced &amp;&amp; fsTypeSpecified </span><span class="cov0" title="0">{
                return &amp;scaleVolume{}, status.Error(codes.InvalidArgument, "filesetType and version="+scversion2+" must not be specified together in storageClass")
        }</span>
        <span class="cov0" title="0">if isSCAdvanced &amp;&amp; isparentFilesetSpecified </span><span class="cov0" title="0">{
                return &amp;scaleVolume{}, status.Error(codes.InvalidArgument, "parentFileset and version="+scversion2+" must not be specified together in storageClass")
        }</span>
        <span class="cov0" title="0">if isSCAdvanced &amp;&amp; volDirPathSpecified </span><span class="cov0" title="0">{
                return &amp;scaleVolume{}, status.Error(codes.InvalidArgument, "volDirBasePath and version="+scversion2+" must not be specified together in storageClass")
        }</span>

        <span class="cov0" title="0">if fsTypeSpecified || isSCAdvanced </span><span class="cov0" title="0">{
                scaleVol.IsFilesetBased = true
        }</span>

        <span class="cov0" title="0">if isCompressionSpecified &amp;&amp; (compression == "" || compression == "false") </span><span class="cov0" title="0">{
                isCompressionSpecified = false
        }</span>
        <span class="cov0" title="0">if isTierSpecified &amp;&amp; tier == "" </span><span class="cov0" title="0">{
                isTierSpecified = false
        }</span>
        <span class="cov0" title="0">if scaleVol.IsFilesetBased </span><span class="cov0" title="0">{
                if isCompressionSpecified </span><span class="cov0" title="0">{
                        scaleVol.Compression = compression
                }</span>
                <span class="cov0" title="0">if isTierSpecified </span><span class="cov0" title="0">{
                        scaleVol.Tier = tier
                }</span>
        } else<span class="cov0" title="0"> {
                if isCompressionSpecified || isTierSpecified </span><span class="cov0" title="0">{
                        return &amp;scaleVolume{}, status.Error(codes.InvalidArgument, "The parameters \"compression\" and \"tier\" are not supported in storageClass for lightweight volumes")
                }</span>
        }

        /* Get UID/GID */
        <span class="cov0" title="0">if uidSpecified </span><span class="cov0" title="0">{
                scaleVol.VolUid = uid
        }</span>

        <span class="cov0" title="0">if gidSpecified </span><span class="cov0" title="0">{
                scaleVol.VolGid = gid
        }</span>

        <span class="cov0" title="0">if isSharedSpecified </span><span class="cov0" title="0">{
                //ignore case of passed "shared" parameter
                icShared := strings.ToLower(shared)
                if !(icShared == "true" || icShared == "false") </span><span class="cov0" title="0">{
                        return &amp;scaleVolume{}, status.Error(codes.InvalidArgument, "invalid value specified for parameter shared")
                }</span>
                <span class="cov0" title="0">if icShared == "false" </span><span class="cov0" title="0">{
                        isSharedSpecified = false
                        scaleVol.Shared = false
                }</span> else<span class="cov0" title="0"> {
                        scaleVol.Shared = true
                }</span>
        }

        <span class="cov0" title="0">if isSharedSpecified &amp;&amp; isPermissionsSpecified </span><span class="cov0" title="0">{
                return &amp;scaleVolume{}, status.Error(codes.InvalidArgument, "shared=true and permissions must not be specified together in storageClass")
        }</span>
        <span class="cov0" title="0">if isSharedSpecified </span><span class="cov0" title="0">{
                scaleVol.VolPermissions = sharedPermissions
        }</span>
        <span class="cov0" title="0">if isPermissionsSpecified </span><span class="cov0" title="0">{
                _, err := strconv.Atoi(permissions)
                if err != nil || len(permissions) != 3 </span><span class="cov0" title="0">{
                        return &amp;scaleVolume{}, status.Error(codes.InvalidArgument, "invalid value specified for permissions")
                }</span>

                <span class="cov0" title="0">for _, n := range permissions </span><span class="cov0" title="0">{
                        if n &lt; 48 || n &gt; 55 </span><span class="cov0" title="0">{
                                return &amp;scaleVolume{}, status.Error(codes.InvalidArgument, "invalid value specified for permissions")
                        }</span>
                }

                <span class="cov0" title="0">scaleVol.VolPermissions = permissions</span>
        }

        <span class="cov0" title="0">if scaleVol.IsFilesetBased </span><span class="cov0" title="0">{
                if fsTypeSpecified </span><span class="cov0" title="0">{
                        scaleVol.FilesetType = fsType
                }</span>
                <span class="cov0" title="0">if isparentFilesetSpecified </span><span class="cov0" title="0">{
                        scaleVol.ParentFileset = parentFileset
                }</span>
                <span class="cov0" title="0">if inodeLimSpecified </span><span class="cov0" title="0">{
                        scaleVol.InodeLimit = inodeLim
                }</span>
        }

        <span class="cov0" title="0">if isNodeClassSpecified </span><span class="cov0" title="0">{
                scaleVol.NodeClass = nodeClass
        }</span>

        <span class="cov0" title="0">if isCGSpecified </span><span class="cov0" title="0">{
                scaleVol.ConsistencyGroup = cg
        }</span> else<span class="cov0" title="0"> {
                cgPrefix := utils.GetEnv("CSI_CG_PREFIX", notFound)
                if cgPrefix == notFound </span><span class="cov0" title="0">{
                        return &amp;scaleVolume{}, status.Error(codes.InvalidArgument, "Failed to extract the consistencyGroup prefix")
                }</span>
                <span class="cov0" title="0">scaleVol.ConsistencyGroup = fmt.Sprintf("%s-%s", cgPrefix, volOptions["csi.storage.k8s.io/pvc/namespace"])</span>
        }

        <span class="cov0" title="0">if isCompressionSpecified </span><span class="cov0" title="0">{
                // Default compression will be Z if set but not specified
                if strings.ToLower(compression) == "true" </span><span class="cov0" title="0">{
                        glog.V(5).Infof("gpfs_util compression was set to true. Defaulting to Z")
                        compression = "z"
                }</span>

                <span class="cov0" title="0">if !IsValidCompressionAlgorithm(compression) </span><span class="cov0" title="0">{
                        glog.V(5).Infof("gpfs_util invalid compression algorithm specified: %s",
                                compression)
                        return &amp;scaleVolume{}, status.Errorf(codes.InvalidArgument,
                                "invalid compression algorithm specified: %s", compression)
                }</span>
                <span class="cov0" title="0">scaleVol.Compression = compression
                glog.V(5).Infof("gpfs_util compression was set to %s", compression)</span>
        }

        <span class="cov0" title="0">if isTierSpecified &amp;&amp; tier != "" </span><span class="cov0" title="0">{
                scaleVol.Tier = tier
                glog.V(5).Infof("gpfs_util tier was set: %s", tier)
        }</span>

        <span class="cov0" title="0">return scaleVol, nil</span>
}

func executeCmd(command string, args []string) ([]byte, error) <span class="cov0" title="0">{
        glog.V(5).Infof("gpfs_util executeCmd")

        cmd := exec.Command(command, args...)
        var stdout bytes.Buffer
        var stderr bytes.Buffer

        cmd.Stdout = &amp;stdout
        cmd.Stderr = &amp;stderr
        err := cmd.Run()
        stdOut := stdout.Bytes()
        return stdOut, err
}</span>

func ConvertToBytes(inputStr string) (uint64, error) <span class="cov8" title="1">{
        var Iter int
        var byteSlice []byte
        var retValue uint64
        var uintMax64 uint64

        byteSlice = []byte(inputStr)
        uintMax64 = (1 &lt;&lt; 64) - 1

        for Iter = 0; Iter &lt; len(byteSlice); Iter++ </span><span class="cov8" title="1">{
                if ('0' &lt;= byteSlice[Iter]) &amp;&amp;
                        (byteSlice[Iter] &lt;= '9') </span><span class="cov8" title="1">{
                        continue</span>
                } else<span class="cov8" title="1"> {
                        break</span>
                }
        }
        <span class="cov8" title="1">if Iter == 0 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("Invalid number specified %v", inputStr)
        }</span>

        <span class="cov8" title="1">retValue, err := strconv.ParseUint(inputStr[:Iter], 10, 64)

        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("ParseUint Failed for %v", inputStr[:Iter])
        }</span>

        <span class="cov8" title="1">if Iter == len(inputStr) </span><span class="cov0" title="0">{
                return retValue, nil
        }</span>

        <span class="cov8" title="1">unit := strings.TrimSpace(string(byteSlice[Iter:]))
        unit = strings.ToLower(unit)

        switch unit </span>{
        case "b", "bytes":<span class="cov0" title="0"></span>
                /* Nothing to do here */
        case "k", "kb", "kilobytes", "kilobyte":<span class="cov8" title="1">
                retValue *= 1024</span>
        case "m", "mb", "megabytes", "megabyte":<span class="cov0" title="0">
                retValue *= (1024 * 1024)</span>
        case "g", "gb", "gigabytes", "gigabyte":<span class="cov0" title="0">
                retValue *= (1024 * 1024 * 1024)</span>
        case "t", "tb", "terabytes", "terabyte":<span class="cov0" title="0">
                retValue *= (1024 * 1024 * 1024 * 1024)</span>
        default:<span class="cov0" title="0">
                return 0, fmt.Errorf("Invalid Unit %v supplied with %v", unit, inputStr)</span>
        }

        <span class="cov8" title="1">if retValue &gt; uintMax64 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("Overflow detected %v", inputStr)
        }</span>

        <span class="cov8" title="1">return retValue, nil</span>
}

const (
        SCALE_NODE_MAPPING_PREFIX = "SCALE_NODE_MAPPING_PREFIX"
        DefaultScaleNodeMapPrefix = "K8sNodePrefix_"
)

// getNodeMapping returns the configured mapping to GPFS Admin Node Name given Kubernetes Node ID.
func getNodeMapping(kubernetesNodeID string) (gpfsAdminName string) <span class="cov0" title="0">{
        gpfsAdminName = utils.GetEnv(kubernetesNodeID, notFound)
        // Additional node mapping check in case of k8s node id start with number.
        if gpfsAdminName == notFound </span><span class="cov0" title="0">{
                prefix := utils.GetEnv(SCALE_NODE_MAPPING_PREFIX, DefaultScaleNodeMapPrefix)
                gpfsAdminName = utils.GetEnv(prefix+kubernetesNodeID, notFound)
                if gpfsAdminName == notFound </span><span class="cov0" title="0">{
                        glog.V(4).Infof("getNodeMapping: scale node mapping not found for %s using %s", prefix+kubernetesNodeID, kubernetesNodeID)
                        gpfsAdminName = kubernetesNodeID
                }</span>
        }
        <span class="cov0" title="0">return gpfsAdminName</span>
}

const (
        SHORTNAME_NODE_MAPPING = "SHORTNAME_NODE_MAPPING"
        SKIP_MOUNT_UNMOUNT     = "SKIP_MOUNT_UNMOUNT"
)

func shortnameInSlice(shortname string, nodeNames []string) bool <span class="cov0" title="0">{
        glog.V(6).Infof("gpfs_util shortnameInSlice. string: %s, slice: %v", shortname, nodeNames)
        for _, name := range nodeNames </span><span class="cov0" title="0">{
                short := strings.SplitN(name, ".", 2)[0]
                if strings.EqualFold(short, shortname) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func numberInSlice(a int, list []int) bool <span class="cov0" title="0">{
        for _, b := range list </span><span class="cov0" title="0">{
                if b == a </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func getVolIDMembers(vID string) (scaleVolId, error) <span class="cov8" title="1">{
        splitVid := strings.Split(vID, ";")
        var vIdMem scaleVolId

        if len(splitVid) == 3 </span><span class="cov0" title="0">{
                /* This is LW volume */
                /* &lt;cluster_id&gt;;&lt;filesystem_uuid&gt;;path=&lt;symlink_path&gt; */
                vIdMem.ClusterId = splitVid[0]
                vIdMem.FsUUID = splitVid[1]
                SlnkPart := splitVid[2]
                slnkSplit := strings.Split(SlnkPart, "=")
                if len(slnkSplit) &lt; 2 </span><span class="cov0" title="0">{
                        return scaleVolId{}, status.Error(codes.Internal, fmt.Sprintf("Invalid Volume Id : [%v]", vID))
                }</span>
                <span class="cov0" title="0">vIdMem.Path = slnkSplit[1]
                vIdMem.IsFilesetBased = false
                return vIdMem, nil</span>
        }

        <span class="cov8" title="1">if len(splitVid) == 4 </span><span class="cov0" title="0">{
                /* This is fileset Based volume */
                /* &lt;cluster_id&gt;;&lt;filesystem_uuid&gt;;fileset=&lt;fileset_id&gt;;path=&lt;symlink_path&gt; */
                vIdMem.ClusterId = splitVid[0]
                vIdMem.FsUUID = splitVid[1]
                fileSetPart := splitVid[2]
                fileSetSplit := strings.Split(fileSetPart, "=")
                if len(fileSetSplit) &lt; 2 </span><span class="cov0" title="0">{
                        return scaleVolId{}, status.Error(codes.Internal, fmt.Sprintf("Invalid Volume Id : [%v]", vID))
                }</span>

                <span class="cov0" title="0">if fileSetSplit[0] == "filesetName" </span><span class="cov0" title="0">{
                        vIdMem.FsetName = fileSetSplit[1]
                }</span> else<span class="cov0" title="0"> {
                        vIdMem.FsetId = fileSetSplit[1]
                }</span>

                <span class="cov0" title="0">SlnkPart := splitVid[3]
                slnkSplit := strings.Split(SlnkPart, "=")
                if len(slnkSplit) &lt; 2 </span><span class="cov0" title="0">{
                        return scaleVolId{}, status.Error(codes.Internal, fmt.Sprintf("Invalid Volume Id : [%v]", vID))
                }</span>
                <span class="cov0" title="0">vIdMem.Path = slnkSplit[1]
                vIdMem.IsFilesetBased = true
                return vIdMem, nil</span>
        }

        <span class="cov8" title="1">if len(splitVid) == 7 </span><span class="cov8" title="1">{
                /* Volume ID created from 2.5.0 onwards  */
                /* VolID: &lt;storageclass_type&gt;;&lt;type_of_volume&gt;;&lt;cluster_id&gt;;&lt;filesystem_uuid&gt;;&lt;consistency_group&gt;;&lt;fileset_name&gt;;&lt;path&gt; */
                vIdMem.StorageClassType = splitVid[0]
                vIdMem.VolType = splitVid[1]
                vIdMem.ClusterId = splitVid[2]
                vIdMem.FsUUID = splitVid[3]
                vIdMem.ConsistencyGroup = splitVid[4]
                vIdMem.FsetName = splitVid[5]
                if vIdMem.StorageClassType == STORAGECLASS_CLASSIC </span><span class="cov8" title="1">{
                        if vIdMem.VolType == FILE_DIRECTORYBASED_VOLUME </span><span class="cov0" title="0">{
                                vIdMem.IsFilesetBased = false
                        }</span> else<span class="cov8" title="1"> {
                                vIdMem.IsFilesetBased = true
                        }</span>
                } else<span class="cov0" title="0"> {
                        vIdMem.IsFilesetBased = true
                }</span>
                <span class="cov8" title="1">vIdMem.Path = splitVid[6]
                return vIdMem, nil</span>

        }

        <span class="cov0" title="0">return scaleVolId{}, status.Error(codes.Internal, fmt.Sprintf("Invalid Volume Id : [%v]", vID))</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">/**
 * Copyright 2019 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package scale

import (
        "context"

        "github.com/container-storage-interface/spec/lib/go/csi"
        "github.com/golang/glog"
        "github.com/golang/protobuf/ptypes/wrappers"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

type ScaleIdentityServer struct {
        Driver *ScaleDriver
}

func (is *ScaleIdentityServer) GetPluginCapabilities(ctx context.Context, req *csi.GetPluginCapabilitiesRequest) (*csi.GetPluginCapabilitiesResponse, error) <span class="cov0" title="0">{
        return &amp;csi.GetPluginCapabilitiesResponse{
                Capabilities: []*csi.PluginCapability{
                        {
                                Type: &amp;csi.PluginCapability_Service_{
                                        Service: &amp;csi.PluginCapability_Service{
                                                Type: csi.PluginCapability_Service_CONTROLLER_SERVICE,
                                        },
                                },
                        },
                },
        }, nil
}</span>

func (is *ScaleIdentityServer) Probe(ctx context.Context, req *csi.ProbeRequest) (*csi.ProbeResponse, error) <span class="cov0" title="0">{
        glog.V(4).Infof("Probe called with args: %#v", req)

        // Determine plugin health
        // If unhealthy return gRPC error code
        // more on error codes https://github.com/container-storage-interface/spec/blob/master/spec.md#probe-errors

        // Node mapping check
        scalenodeID := getNodeMapping(is.Driver.nodeID)
        glog.V(4).Infof("Probe: scalenodeID:%s --known as-- k8snodeName: %s", scalenodeID, is.Driver.nodeID)
        // IsNodeComponentHealthy accepts nodeName as admin node name, daemon node name, etc.
        ghealthy, err := is.Driver.connmap["primary"].IsNodeComponentHealthy(scalenodeID, "GPFS")
        if ghealthy == false </span><span class="cov0" title="0">{
                glog.Errorf("Probe: GPFS component on node %v is not healthy. Error: %v", scalenodeID, err)
                return &amp;csi.ProbeResponse{Ready: &amp;wrappers.BoolValue{Value: true}}, nil
        }</span>

        // nhealthy, err := is.Driver.connmap["primary"].IsNodeComponentHealthy(scalenodeID, "NODE")
        // if nhealthy == false {
        //         glog.Errorf("Probe: NODE component on node %v is not healthy. Error: %v", scalenodeID, err)
        //         return &amp;csi.ProbeResponse{Ready: &amp;wrappers.BoolValue{Value: true}}, err
        // }

        <span class="cov0" title="0">glog.V(4).Infof("Probe: GPFS on node %v is healthy", scalenodeID)

        return &amp;csi.ProbeResponse{Ready: &amp;wrappers.BoolValue{Value: true}}, nil</span>
}

func (is *ScaleIdentityServer) GetPluginInfo(ctx context.Context, req *csi.GetPluginInfoRequest) (*csi.GetPluginInfoResponse, error) <span class="cov0" title="0">{
        glog.V(5).Infof("Using default GetPluginInfo")

        if is.Driver.name == "" </span><span class="cov0" title="0">{
                return nil, status.Error(codes.Unavailable, "Driver name not configured")
        }</span>

        <span class="cov0" title="0">return &amp;csi.GetPluginInfoResponse{
                Name:          is.Driver.name,
                VendorVersion: is.Driver.vendorVersion,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">/**
 * Copyright 2019 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package scale

import (
        "fmt"
        "os"
        "strings"
        "sync"

        "github.com/IBM/ibm-spectrum-scale-csi/driver/csiplugin/utils"
        "github.com/golang/glog"
        "golang.org/x/net/context"
        "k8s.io/mount-utils"

        "github.com/container-storage-interface/spec/lib/go/csi"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

type ScaleNodeServer struct {
        Driver *ScaleDriver
        // TODO: Only lock mutually exclusive calls and make locking more fine grained
        mux sync.Mutex
}

const hostDir = "/host"
const errStaleNFSFileHandle = "stale NFS file handle"

// checkGpfsType checks if a given path is of type gpfs and
// returns nil if it is a gpfs type, otherwise returns
// corresponding error.
func checkGpfsType(path string) (bool error) <span class="cov0" title="0">{
        args := []string{"-f", "-c", "%T", path}
        out, err := executeCmd("stat", args)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("checkGpfsType: failed to get type of file with stat of [%s]. Error [%v]", path, err)
        }</span>
        <span class="cov0" title="0">outString := fmt.Sprintf("%s", out)
        outString = strings.TrimRight(outString, "\n")
        if outString != "gpfs" </span><span class="cov0" title="0">{
                return fmt.Errorf("checkGpfsType: the path [%s] is not a valid gpfs path, the path is of type [%s]", strings.TrimPrefix(path, hostDir), outString)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (ns *ScaleNodeServer) NodePublishVolume(ctx context.Context, req *csi.NodePublishVolumeRequest) (*csi.NodePublishVolumeResponse, error) <span class="cov0" title="0">{
        glog.V(3).Infof("nodeserver NodePublishVolume")

        glog.V(4).Infof("NodePublishVolume called with req: %#v", req)

        // Validate Arguments
        targetPath := req.GetTargetPath()
        volumeID := req.GetVolumeId()
        volumeCapability := req.GetVolumeCapability()

        if len(volumeID) == 0 </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "volumeID must be provided")
        }</span>
        <span class="cov0" title="0">if len(targetPath) == 0 </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "target path must be provided")
        }</span>
        <span class="cov0" title="0">if volumeCapability == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "volume capability must be provided")
        }</span>

        <span class="cov0" title="0">volumeIDMembers, err := getVolIDMembers(volumeID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "NodePublishVolume : VolumeID is not in proper format")
        }</span>
        <span class="cov0" title="0">volScalePath := volumeIDMembers.Path

        glog.V(4).Infof("Target SpectrumScale Path : %v\n", volScalePath)

        volScalePathInContainer := hostDir + volScalePath
        f, err := os.Lstat(volScalePathInContainer)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("NodePublishVolume: failed to get lstat of [%s]. Error [%v]", volScalePathInContainer, err)
        }</span>
        <span class="cov0" title="0">if f.Mode()&amp;os.ModeSymlink != 0 </span><span class="cov0" title="0">{
                symlinkTarget, readlinkErr := os.Readlink(volScalePathInContainer)
                if readlinkErr != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("NodePublishVolume: failed to get symlink target for [%s]. Error [%v]", volScalePathInContainer, readlinkErr)
                }</span>
                <span class="cov0" title="0">volScalePathInContainer = hostDir + symlinkTarget
                volScalePath = symlinkTarget
                glog.V(4).Infof("NodePublishVolume: symlink tarrget path is [%s]\n", volScalePathInContainer)</span>
        }

        <span class="cov0" title="0">err = checkGpfsType(volScalePathInContainer)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">notMP, err := mount.IsNotMountPoint(mount.New(""), targetPath)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        if err = os.Mkdir(targetPath, 0750); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to create target path [%s]. Error [%v]", targetPath, err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        return nil, fmt.Errorf("failed to check target path [%s]. Error [%v]", targetPath, err)
                }</span>
        }
        <span class="cov0" title="0">if !notMP </span><span class="cov0" title="0">{
                return &amp;csi.NodePublishVolumeResponse{}, nil
        }</span>

        // create bind mount
        <span class="cov0" title="0">options := []string{"bind"}
        mounter := mount.New("")
        glog.V(4).Infof("NodePublishVolume - creating bind mount [%v] -&gt; [%v]", targetPath, volScalePath)
        if err := mounter.Mount(volScalePath, targetPath, "", options); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to mount: [%s] at [%s]. Error [%v]", volScalePath, targetPath, err)
        }</span>

        //check for the gpfs type again, if not gpfs type, unmount and return error.
        <span class="cov0" title="0">err = checkGpfsType(volScalePathInContainer)
        if err != nil </span><span class="cov0" title="0">{
                uerr := mount.New("").Unmount(targetPath)
                if uerr != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("NodePublishVolume - failed to unmount the path [%s]. Error %v", targetPath, uerr)
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">glog.V(4).Infof("successfully mounted %s", targetPath)
        return &amp;csi.NodePublishVolumeResponse{}, nil</span>
}

// unmountAndDelete unmounts and deletes a targetPath (forcefully if
// foreceful=true is passed) and returns a bool which tells if a
// calling function should return, along with the response and error
// to be returned if there are any.
func unmountAndDelete(targetPath string, forceful bool) (bool, *csi.NodeUnpublishVolumeResponse, error) <span class="cov0" title="0">{
        glog.V(3).Infof("nodeserver unmountAndDelete")
        targetPathInContainer := hostDir + targetPath
        isMP := false
        var err error
        if !forceful </span><span class="cov0" title="0">{
                isMP, err = mount.New("").IsMountPoint(targetPathInContainer)
                if err != nil </span><span class="cov0" title="0">{
                        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                                glog.V(4).Infof("target path %v is already deleted", targetPathInContainer)
                                return true, &amp;csi.NodeUnpublishVolumeResponse{}, nil
                        }</span>
                        <span class="cov0" title="0">return true, nil, fmt.Errorf("failed to check if target path [%s] is a mount point. Error %v", targetPathInContainer, err)</span>
                }
        }
        <span class="cov0" title="0">if forceful || isMP </span><span class="cov0" title="0">{
                // Unmount the targetPath
                err = mount.New("").Unmount(targetPath)
                if err != nil </span><span class="cov0" title="0">{
                        return true, nil, fmt.Errorf("failed to unmount the mount point [%s]. Error %v", targetPath, err)
                }</span>
                <span class="cov0" title="0">glog.V(4).Infof("%v is unmounted successfully", targetPath)</span>
        }
        // Delete the mount point
        <span class="cov0" title="0">if err = os.Remove(targetPathInContainer); err != nil </span><span class="cov0" title="0">{
                return true, nil, fmt.Errorf("failed to remove the mount point [%s]. Error %v", targetPathInContainer, err)
        }</span>
        <span class="cov0" title="0">return false, nil, nil</span>
}

func (ns *ScaleNodeServer) NodeUnpublishVolume(ctx context.Context, req *csi.NodeUnpublishVolumeRequest) (*csi.NodeUnpublishVolumeResponse, error) <span class="cov0" title="0">{
        glog.V(3).Infof("nodeserver NodeUnpublishVolume")
        glog.V(4).Infof("NodeUnpublishVolume called with args: %v", req)
        // Validate Arguments
        targetPath := req.GetTargetPath()
        volID := req.GetVolumeId()
        if len(volID) == 0 </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "volumeID must be provided")
        }</span>
        <span class="cov0" title="0">if len(targetPath) == 0 </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "target path must be provided")
        }</span>

        <span class="cov0" title="0">glog.V(4).Infof("NodeUnpublishVolume - deleting the targetPath - [%v]", targetPath)

        //Check if target is a symlink or bind mount and cleanup accordingly
        f, err := os.Lstat(targetPath)
        if err != nil </span><span class="cov0" title="0">{
                if strings.Contains(err.Error(), errStaleNFSFileHandle) </span><span class="cov0" title="0">{
                        glog.V(4).Infof("error [%v] is observed, trying forceful unmount of [%s]", err, targetPath)
                        needReturn, response, error := unmountAndDelete(targetPath, true)
                        if needReturn </span><span class="cov0" title="0">{
                                return response, error
                        }</span>
                        <span class="cov0" title="0">return &amp;csi.NodeUnpublishVolumeResponse{}, nil</span>
                } else<span class="cov0" title="0"> {
                        return nil, fmt.Errorf("failed to get lstat of target path [%s]. Error %v", targetPath, err)
                }</span>
        }
        <span class="cov0" title="0">if f.Mode()&amp;os.ModeSymlink != 0 </span><span class="cov0" title="0">{
                glog.V(4).Infof("%v is a symlink", targetPath)
                if err := os.Remove(targetPath); err != nil </span><span class="cov0" title="0">{
                        return nil, status.Error(codes.Internal, fmt.Sprintf("failed to remove symlink targetPath [%v]. Error [%v]", targetPath, err.Error()))
                }</span>
        } else<span class="cov0" title="0"> {
                glog.V(4).Infof("%v is a bind mount", targetPath)
                needReturn, response, error := unmountAndDelete(targetPath, false)
                if needReturn </span><span class="cov0" title="0">{
                        return response, error
                }</span>
        }
        <span class="cov0" title="0">glog.V(4).Infof("successfully unpublished %s", targetPath)
        return &amp;csi.NodeUnpublishVolumeResponse{}, nil</span>
}

func (ns *ScaleNodeServer) NodeStageVolume(ctx context.Context, req *csi.NodeStageVolumeRequest) (
        *csi.NodeStageVolumeResponse, error) <span class="cov0" title="0">{
        glog.V(3).Infof("nodeserver NodeStageVolume")
        ns.mux.Lock()
        defer ns.mux.Unlock()
        glog.V(4).Infof("NodeStageVolume called with req: %#v", req)

        // Validate Arguments
        volumeID := req.GetVolumeId()
        stagingTargetPath := req.GetStagingTargetPath()
        volumeCapability := req.GetVolumeCapability()
        if len(volumeID) == 0 </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "NodeStageVolume Volume ID must be provided")
        }</span>
        <span class="cov0" title="0">if len(stagingTargetPath) == 0 </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "NodeStageVolume Staging Target Path must be provided")
        }</span>
        <span class="cov0" title="0">if volumeCapability == nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "NodeStageVolume Volume Capability must be provided")
        }</span>
        <span class="cov0" title="0">return &amp;csi.NodeStageVolumeResponse{}, nil</span>
}

func (ns *ScaleNodeServer) NodeUnstageVolume(ctx context.Context, req *csi.NodeUnstageVolumeRequest) (
        *csi.NodeUnstageVolumeResponse, error) <span class="cov0" title="0">{
        glog.V(3).Infof("nodeserver NodeUnstageVolume")
        ns.mux.Lock()
        defer ns.mux.Unlock()
        glog.V(4).Infof("NodeUnstageVolume called with req: %#v", req)

        // Validate arguments
        volumeID := req.GetVolumeId()
        stagingTargetPath := req.GetStagingTargetPath()
        if len(volumeID) == 0 </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "NodeUnstageVolume Volume ID must be provided")
        }</span>
        <span class="cov0" title="0">if len(stagingTargetPath) == 0 </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "NodeUnstageVolume Staging Target Path must be provided")
        }</span>

        <span class="cov0" title="0">return &amp;csi.NodeUnstageVolumeResponse{}, nil</span>
}

func (ns *ScaleNodeServer) NodeGetCapabilities(ctx context.Context, req *csi.NodeGetCapabilitiesRequest) (*csi.NodeGetCapabilitiesResponse, error) <span class="cov0" title="0">{
        glog.V(4).Infof("NodeGetCapabilities called with req: %#v", req)
        return &amp;csi.NodeGetCapabilitiesResponse{
                Capabilities: ns.Driver.nscap,
        }, nil
}</span>

func (ns *ScaleNodeServer) NodeGetInfo(ctx context.Context, req *csi.NodeGetInfoRequest) (*csi.NodeGetInfoResponse, error) <span class="cov0" title="0">{
        glog.V(4).Infof("NodeGetInfo called with req: %#v", req)
        return &amp;csi.NodeGetInfoResponse{
                NodeId: ns.Driver.nodeID,
        }, nil
}</span>

func (ns *ScaleNodeServer) NodeExpandVolume(ctx context.Context, req *csi.NodeExpandVolumeRequest) (*csi.NodeExpandVolumeResponse, error) <span class="cov0" title="0">{
        return nil, status.Error(codes.Unimplemented, "")
}</span>

func (ns *ScaleNodeServer) NodeGetVolumeStats(ctx context.Context, req *csi.NodeGetVolumeStatsRequest) (*csi.NodeGetVolumeStatsResponse, error) <span class="cov0" title="0">{
        glog.V(4).Infof("NodeGetVolumeStats called with req: %#v", req)

        if len(req.VolumeId) == 0 </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "NodeGetVolumeStats Volume ID must be provided")
        }</span>
        <span class="cov0" title="0">if len(req.VolumePath) == 0 </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "NodeGetVolumeStats Target Path must be provided")
        }</span>

        <span class="cov0" title="0">if _, err := os.Lstat(req.VolumePath); err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return nil, status.Errorf(codes.NotFound, "path %s does not exist", req.VolumePath)
                }</span>
                <span class="cov0" title="0">return nil, status.Errorf(codes.Internal, "failed to stat path %s: %v", req.VolumePath, err)</span>
        }

        <span class="cov0" title="0">volumeIDMembers, err := getVolIDMembers(req.GetVolumeId())
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "NodeGetVolumeStats : VolumeID is not in proper format")
        }</span>

        <span class="cov0" title="0">if !volumeIDMembers.IsFilesetBased </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, "volume stats are not supported for lightweight volumes")
        }</span>

        <span class="cov0" title="0">available, capacity, used, inodes, inodesFree, inodesUsed, err := utils.FsStatInfo(req.GetVolumePath())
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Error(codes.InvalidArgument, fmt.Sprintf("volume stat failed with error %v", err))
        }</span>

        <span class="cov0" title="0">if available &gt; capacity || used &gt; capacity </span><span class="cov0" title="0">{
                glog.V(4).Infof("incorrect values reported for volume (%v) against Available(%v) or Capacity(%v)",
                        volumeIDMembers.FsetName, available, capacity)

                return nil, status.Error(codes.InvalidArgument, fmt.Sprintf("incorrect values reported for volume (%v) against Available(%v) or Capacity(%v)",
                        volumeIDMembers.FsetName, available, capacity))
        }</span>

        <span class="cov0" title="0">glog.V(4).Infof("stat for volume:%v, Total:%v, Used:%v Available:%v, Total Inodes:%v, Used Inodes:%v, Available Inodes:%v,",
                volumeIDMembers.FsetName, capacity, used, available, inodes, inodesUsed, inodesFree)

        return &amp;csi.NodeGetVolumeStatsResponse{
                Usage: []*csi.VolumeUsage{
                        {
                                Available: available,
                                Total:     capacity,
                                Used:      used,
                                Unit:      csi.VolumeUsage_BYTES,
                        }, {
                                Available: inodesFree,
                                Used:      inodesUsed,
                                Total:     inodes,
                                Unit:      csi.VolumeUsage_INODES,
                        },
                },
        }, nil</span>

}
</pre>
		
		<pre class="file" id="file5" style="display: none">/**
 * Copyright 2019 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package scale

import (
        "net"
        "net/url"
        "os"
        "sync"

        "github.com/golang/glog"
        "google.golang.org/grpc"

        csi "github.com/container-storage-interface/spec/lib/go/csi"
)

// Defines Non blocking GRPC server interfaces
type NonBlockingGRPCServer interface {
        // Start services at the endpoint
        Start(endpoint string, ids csi.IdentityServer, cs csi.ControllerServer, ns csi.NodeServer)
        // Waits for the service to stop
        Wait()
        // Stops the service gracefully
        Stop()
        // Stops the service forcefully
        ForceStop()
}

func NewNonBlockingGRPCServer() NonBlockingGRPCServer <span class="cov0" title="0">{
        return &amp;nonBlockingGRPCServer{}
}</span>

// NonBlocking server
type nonBlockingGRPCServer struct {
        wg     sync.WaitGroup
        server *grpc.Server
}

func (s *nonBlockingGRPCServer) Start(endpoint string, ids csi.IdentityServer, cs csi.ControllerServer, ns csi.NodeServer) <span class="cov0" title="0">{
        s.wg.Add(1)

        go s.serve(endpoint, ids, cs, ns)
}</span>

func (s *nonBlockingGRPCServer) Wait() <span class="cov0" title="0">{
        s.wg.Wait()
}</span>

func (s *nonBlockingGRPCServer) Stop() <span class="cov0" title="0">{
        s.server.GracefulStop()
}</span>

func (s *nonBlockingGRPCServer) ForceStop() <span class="cov0" title="0">{
        s.server.Stop()
}</span>

func (s *nonBlockingGRPCServer) serve(endpoint string, ids csi.IdentityServer, cs csi.ControllerServer, ns csi.NodeServer) <span class="cov0" title="0">{
        opts := []grpc.ServerOption{
                grpc.UnaryInterceptor(logGRPC),
        }

        u, err := url.Parse(endpoint)

        if err != nil </span><span class="cov0" title="0">{
                glog.Fatal(err.Error())
        }</span>

        <span class="cov0" title="0">var addr string
        if u.Scheme == "unix" </span><span class="cov0" title="0">{
                addr = u.Path
                if err := os.Remove(addr); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                        glog.Fatalf("Failed to remove %s, error: %s", addr, err.Error())
                }</span>
        } else<span class="cov0" title="0"> if u.Scheme == "tcp" </span><span class="cov0" title="0">{
                addr = u.Host
        }</span> else<span class="cov0" title="0"> {
                glog.Fatalf("%v endpoint scheme not supported", u.Scheme)
        }</span>

        <span class="cov0" title="0">glog.V(4).Infof("Start listening with scheme %v, addr %v", u.Scheme, addr)
        listener, err := net.Listen(u.Scheme, addr)
        if err != nil </span><span class="cov0" title="0">{
                glog.Fatalf("Failed to listen: %v", err)
        }</span>

        <span class="cov0" title="0">server := grpc.NewServer(opts...)
        s.server = server

        if ids != nil </span><span class="cov0" title="0">{
                csi.RegisterIdentityServer(server, ids)
        }</span>
        <span class="cov0" title="0">if cs != nil </span><span class="cov0" title="0">{
                csi.RegisterControllerServer(server, cs)
        }</span>
        <span class="cov0" title="0">if ns != nil </span><span class="cov0" title="0">{
                csi.RegisterNodeServer(server, ns)
        }</span>

        <span class="cov0" title="0">glog.V(4).Infof("Listening for connections on address: %#v", listener.Addr())

        if err := server.Serve(listener); err != nil </span><span class="cov0" title="0">{
                glog.Fatalf("Failed to serve: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">/**
 * Copyright 2019 IBM Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package scale

import (
        csi "github.com/container-storage-interface/spec/lib/go/csi"
        "github.com/golang/glog"
        "golang.org/x/net/context"
        "google.golang.org/grpc"
)

func NewVolumeCapabilityAccessMode(mode csi.VolumeCapability_AccessMode_Mode) *csi.VolumeCapability_AccessMode <span class="cov8" title="1">{
        return &amp;csi.VolumeCapability_AccessMode{Mode: mode}
}</span>

func NewControllerServiceCapability(cap csi.ControllerServiceCapability_RPC_Type) *csi.ControllerServiceCapability <span class="cov8" title="1">{
        return &amp;csi.ControllerServiceCapability{
                Type: &amp;csi.ControllerServiceCapability_Rpc{
                        Rpc: &amp;csi.ControllerServiceCapability_RPC{
                                Type: cap,
                        },
                },
        }
}</span>

func NewNodeServiceCapability(cap csi.NodeServiceCapability_RPC_Type) *csi.NodeServiceCapability <span class="cov8" title="1">{
        return &amp;csi.NodeServiceCapability{
                Type: &amp;csi.NodeServiceCapability_Rpc{
                        Rpc: &amp;csi.NodeServiceCapability_RPC{
                                Type: cap,
                        },
                },
        }
}</span>

func logGRPC(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) <span class="cov0" title="0">{
        glog.V(3).Infof("GRPC call: %s", info.FullMethod)
        glog.V(5).Infof("GRPC request: %+v", req)
        resp, err := handler(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                glog.Errorf("GRPC error: %v", err)
        }</span> else<span class="cov0" title="0"> {
                glog.V(5).Infof("GRPC response: %+v", resp)
        }</span>
        <span class="cov0" title="0">return resp, err</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
